"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _react = _interopRequireWildcard(require("react"));

var _propTypes = _interopRequireDefault(require("prop-types"));

var helpers = _interopRequireWildcard(require("../../core/"));

var _Markdown = require("../Markdown.context");

var _useStyles = require("./useStyles");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function BlockEditable(_ref) {
  var markdown = _ref.markdown,
      onEdit = _ref.onEdit,
      inputFilters = _ref.inputFilters,
      outputFilters = _ref.outputFilters,
      style = _ref.style,
      preview = _ref.preview,
      editable = _ref.editable,
      fontSize = _ref.fontSize;
  var classes = (0, _useStyles.useStyles)();

  var _useContext = (0, _react.useContext)(_Markdown.MarkdownContext),
      actions = _useContext.actions;

  var _oldMarkdown = {
    markdown: markdown
  };

  var _style = (0, _react.useMemo)(function () {
    return helpers.isHebrew(markdown) ? _objectSpread(_objectSpread({}, style), {}, {
      fontSize: '1.5em'
    }) : style;
  }, [style, markdown]);

  var handleBlur = (0, _react.useCallback)(function (_markdown) {
    var oldHTML = (0, helpers.markdownToHtml)({
      markdown: _oldMarkdown.markdown,
      inputFilters: inputFilters
    });
    var newHTML = (0, helpers.markdownToHtml)({
      markdown: _markdown,
      inputFilters: inputFilters
    }); // TODO: do we need to calculate HTML each time??

    if (oldHTML !== newHTML || _oldMarkdown.markdown !== _markdown) {
      _oldMarkdown.markdown = _markdown;
      onEdit(_markdown);
    }
  }, [_oldMarkdown.markdown, inputFilters, onEdit]);
  var handleHTMLBlur = (0, _react.useCallback)(function (e) {
    var html = e.target.innerHTML;

    var _markdown = (0, helpers.htmlToMarkdown)({
      html: html,
      outputFilters: outputFilters
    });

    handleBlur(_markdown);
  }, [handleBlur, outputFilters]);
  var handleRawBlur = (0, _react.useCallback)(function (e) {
    var string = e.target.innerText;
    string = (0, helpers.fromDisplay)(string);

    var _markdown = (0, helpers.filter)({
      string: string,
      filters: outputFilters
    });

    handleBlur(_markdown);
  }, [handleBlur, outputFilters]);
  var handleKeyPress = (0, _react.useCallback)(function (keycode) {
    if (actions && actions.setIsChanged) {
      actions.setIsChanged(true);
    }
  }, [actions]);
  var handledKeyCodes = [8
  /*Delete/Backspace*/
  ];
  var handleKeyUp = (0, _react.useCallback)(function (event) {
    if (actions && actions.setIsChanged) {
      if (handledKeyCodes.includes(event.keyCode)) {
        // NOTE: we don't want to convert HTML on key keyUp.
        // So we cant test for changes.
        actions.setIsChanged(true);
      }
    }
  }, [actions]);
  var handleCutPaste = (0, _react.useCallback)(function () {
    if (actions && actions.setIsChanged) {
      actions.setIsChanged(true);
    }

    if (actions && actions.setIsAutoSaveChanged) {
      actions.setIsAutoSaveChanged(true);
    }
  }, [actions]);
  var component = (0, _react.useMemo)(function () {
    var _component;

    if (!preview) {
      var code = (0, helpers.filter)({
        string: markdown,
        filters: inputFilters
      });
      code = (0, helpers.toDisplay)(code);
      var dangerouslySetInnerHTML = {
        __html: code
      };
      _component = /*#__PURE__*/_react.default.createElement("pre", {
        className: classes.pre
      }, /*#__PURE__*/_react.default.createElement("code", {
        className: classes.markdown,
        style: _objectSpread(_objectSpread({}, _style), {}, {
          fontSize: fontSize
        }),
        dir: "auto",
        contentEditable: editable,
        dangerouslySetInnerHTML: dangerouslySetInnerHTML,
        onBlur: handleRawBlur,
        onKeyPress: handleKeyPress,
        onKeyUp: handleKeyUp,
        onCut: handleCutPaste,
        onPaste: handleCutPaste
      }));
    } else {
      var _dangerouslySetInnerHTML = {
        __html: (0, helpers.markdownToHtml)({
          markdown: markdown,
          inputFilters: inputFilters
        })
      };
      _component = /*#__PURE__*/_react.default.createElement("div", {
        style: _objectSpread(_objectSpread({}, _style), {}, {
          fontSize: fontSize
        }),
        className: classes.html,
        dir: "auto",
        contentEditable: editable,
        dangerouslySetInnerHTML: _dangerouslySetInnerHTML,
        onBlur: handleHTMLBlur,
        onKeyPress: handleKeyPress,
        onKeyUp: handleKeyUp,
        onCut: handleCutPaste,
        onPaste: handleCutPaste
      });
    }

    return _component;
  }, [fontSize, preview, markdown, editable]);
  return /*#__PURE__*/_react.default.createElement("div", {
    className: classes.root
  }, component);
}

BlockEditable.propTypes = {
  /** Initial markdown for the editor. */
  markdown: _propTypes.default.string.isRequired,

  /** Function to propogate changes to the markdown. */
  onEdit: _propTypes.default.func,

  /** Replace strings before rendering. */
  inputFilters: _propTypes.default.array,

  /** Replace strings after editing. */
  outputFilters: _propTypes.default.array,

  /** CSS for the component. */
  style: _propTypes.default.object,

  /** Display Raw Markdown or HTML. */
  preview: _propTypes.default.bool,

  /** Enable/Disable editability. */
  editable: _propTypes.default.bool,

  /** fontSize e.g. '100%' */
  fontSize: _propTypes.default.string
};
BlockEditable.defaultProps = {
  markdown: '',
  onEdit: function onEdit() {},
  inputFilters: [],
  outputFilters: [],
  style: {},
  preview: true,
  editable: true
};
var _default = BlockEditable;
exports.default = _default;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9jb21wb25lbnRzL2Jsb2NrLWVkaXRhYmxlL0Jsb2NrRWRpdGFibGUuanMiXSwibmFtZXMiOlsiQmxvY2tFZGl0YWJsZSIsIm1hcmtkb3duIiwib25FZGl0IiwiaW5wdXRGaWx0ZXJzIiwib3V0cHV0RmlsdGVycyIsInN0eWxlIiwicHJldmlldyIsImVkaXRhYmxlIiwiZm9udFNpemUiLCJjbGFzc2VzIiwiTWFya2Rvd25Db250ZXh0IiwiYWN0aW9ucyIsIl9vbGRNYXJrZG93biIsIl9zdHlsZSIsImhlbHBlcnMiLCJpc0hlYnJldyIsImhhbmRsZUJsdXIiLCJfbWFya2Rvd24iLCJvbGRIVE1MIiwibmV3SFRNTCIsImhhbmRsZUhUTUxCbHVyIiwiZSIsImh0bWwiLCJ0YXJnZXQiLCJpbm5lckhUTUwiLCJoYW5kbGVSYXdCbHVyIiwic3RyaW5nIiwiaW5uZXJUZXh0IiwiZmlsdGVycyIsImhhbmRsZUtleVByZXNzIiwia2V5Y29kZSIsInNldElzQ2hhbmdlZCIsImhhbmRsZWRLZXlDb2RlcyIsImhhbmRsZUtleVVwIiwiZXZlbnQiLCJpbmNsdWRlcyIsImtleUNvZGUiLCJoYW5kbGVDdXRQYXN0ZSIsInNldElzQXV0b1NhdmVDaGFuZ2VkIiwiY29tcG9uZW50IiwiX2NvbXBvbmVudCIsImNvZGUiLCJkYW5nZXJvdXNseVNldElubmVySFRNTCIsIl9faHRtbCIsInByZSIsInJvb3QiLCJwcm9wVHlwZXMiLCJQcm9wVHlwZXMiLCJpc1JlcXVpcmVkIiwiZnVuYyIsImFycmF5Iiwib2JqZWN0IiwiYm9vbCIsImRlZmF1bHRQcm9wcyJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUE7O0FBR0E7O0FBRUE7O0FBUUE7O0FBQ0E7Ozs7Ozs7Ozs7Ozs7O0FBR0EsU0FBU0EsYUFBVCxPQVNHO0FBQUEsTUFSREMsUUFRQyxRQVJEQSxRQVFDO0FBQUEsTUFQREMsTUFPQyxRQVBEQSxNQU9DO0FBQUEsTUFOREMsWUFNQyxRQU5EQSxZQU1DO0FBQUEs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O0FBQ0Q7O0FBRUR2QyxhQUFhLENBQUM4QyxTQUFkLEdBQTBCO0FBQ3hCO0FBQ0E3QyxFQUFBQSxRQUFRLEVBQUU4QyxtQkFBVXJCLE1BQVYsQ0FBaUJzQixVQUZIOztBQUd4QjtBQUNBOUMsRUFBQUEsTUFBTSxFQUFFNkMsbUJBQVVFLElBSk07O0FBS3hCO0FBQ0E5QyxFQUFBQSxZQUFZLEVBQUU0QyxtQkFBVUcsS0FOQTs7QUFPeEI7QUFDQTlDLEVBQUFBLGFBQWEsRUFBRTJDLG1CQUFVRyxLQVJEOztBQVN4QjtBQUNBN0MsRUFBQUEsS0FBSyxFQUFFMEMsbUJBQVVJLE1BVk87O0FBV3hCO0FBQ0E3QyxFQUFBQSxPQUFPLEVBQUV5QyxtQkFBVUssSUFaSzs7QUFheEI7QUFDQTdDLEVBQUFBLFFBQVEsRUFBRXdDLG1CQUFVSyxJQWRJOztBQWV4QjtBQUNBNUMsRUFBQUEsUUFBUSxFQUFFdUMsbUJBQVVyQjtBQWhCSSxDQUExQjtBQW1CQTFCLGFBQWEsQ0FBQ3FELFlBQWQsR0FBNkI7QUFDM0JwRCxFQUFBQSxRQUFRLEVBQUUsRUFEaUI7QUFFM0JDLEVBQUFBLE1BQU0sRUFBRSxrQkFBTSxDQUFHLENBRlU7QUFHM0JDLEVBQUFBLFlBQVksRUFBRSxFQUhhO0FBSTNCQyxFQUFBQSxhQUFhLEVBQUUsRUFKWTtBQUszQkMsRUFBQUEsS0FBSyxFQUFFLEVBTG9CO0FBTTNCQyxFQUFBQSxPQUFPLEVBQUUsSUFOa0I7QUFPM0JDLEVBQUFBLFFBQVEsRUFBRTtBQVBpQixDQUE3QjtlQVVlUCxhIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFJlYWN0LCB7XHJcbiAgdXNlTWVtbywgdXNlQ2FsbGJhY2ssIHVzZUNvbnRleHQsXHJcbn0gZnJvbSAncmVhY3QnO1xyXG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xyXG5cclxuaW1wb3J0ICogYXMgaGVscGVycyBmcm9tICcuLi8uLi9jb3JlLyc7XHJcbmltcG9ydCB7XHJcbiAgbWFya2Rvd25Ub0h0bWwsXHJcbiAgaHRtbFRvTWFya2Rvd24sXHJcbiAgZmlsdGVyLFxyXG4gIGZyb21EaXNwbGF5LFxyXG4gIHRvRGlzcGxheSxcclxufSBmcm9tICcuLi8uLi9jb3JlLyc7XHJcbmltcG9ydCB7IE1hcmtkb3duQ29udGV4dCB9IGZyb20gJy4uL01hcmtkb3duLmNvbnRleHQnO1xyXG5pbXBvcnQgeyB1c2VTdHlsZXMgfSBmcm9tICcuL3VzZVN0eWxlcyc7XHJcblxyXG5cclxuZnVuY3Rpb24gQmxvY2tFZGl0YWJsZSh7XHJcbiAgbWFya2Rvd24sXHJcbiAgb25FZGl0LFxyXG4gIGlucHV0RmlsdGVycyxcclxuICBvdXRwdXRGaWx0ZXJzLFxyXG4gIHN0eWxlLFxyXG4gIHByZXZpZXcsXHJcbiAgZWRpdGFibGUsXHJcbiAgZm9udFNpemUsXHJcbn0pIHtcclxuICBjb25zdCBjbGFzc2VzID0gdXNlU3R5bGVzKCk7XHJcbiAgY29uc3QgeyBhY3Rpb25zIH0gPSB1c2VDb250ZXh0KE1hcmtkb3duQ29udGV4dCk7XHJcbiAgY29uc3QgX29sZE1hcmtkb3duID0geyBtYXJrZG93biB9O1xyXG5cclxuICBjb25zdCBfc3R5bGUgPSB1c2VNZW1vKFxyXG4gICAgKCkgPT5cclxuICAgICAgaGVscGVycy5pc0hlYnJldyhtYXJrZG93bikgPyB7IC4uLnN0eWxlLCBmb250U2l6ZTogJzEuNWVtJyB9IDogc3R5bGUsXHJcbiAgICBbc3R5bGUsIG1hcmtkb3duXVxyXG4gICk7XHJcblxyXG4gIGNvbnN0IGhhbmRsZUJsdXIgPSB1c2VDYWxsYmFjayhcclxuICAgIChfbWFya2Rvd24pID0+IHtcclxuICAgICAgY29uc3Qgb2xkSFRNTCA9IG1hcmtkb3duVG9IdG1sKHtcclxuICAgICAgICBtYXJrZG93bjogX29sZE1hcmtkb3duLm1hcmtkb3duLFxyXG4gICAgICAgIGlucHV0RmlsdGVyczogaW5wdXRGaWx0ZXJzLFxyXG4gICAgICB9KTtcclxuICAgICAgY29uc3QgbmV3SFRNTCA9IG1hcmtkb3duVG9IdG1sKHtcclxuICAgICAgICBtYXJrZG93bjogX21hcmtkb3duLFxyXG4gICAgICAgIGlucHV0RmlsdGVyczogaW5wdXRGaWx0ZXJzLFxyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIC8vIFRPRE86IGRvIHdlIG5lZWQgdG8gY2FsY3VsYXRlIEhUTUwgZWFjaCB0aW1lPz9cclxuICAgICAgaWYgKG9sZEhUTUwgIT09IG5ld0hUTUwgfHwgX29sZE1hcmtkb3duLm1hcmtkb3duICE9PSBfbWFya2Rvd24pIHtcclxuICAgICAgICBfb2xkTWFya2Rvd24ubWFya2Rvd24gPSBfbWFya2Rvd247XHJcbiAgICAgICAgb25FZGl0KF9tYXJrZG93bik7XHJcbiAgICAgIH1cclxuICAgIH0sXHJcbiAgICBbX29sZE1hcmtkb3duLm1hcmtkb3duLCBpbnB1dEZpbHRlcnMsIG9uRWRpdF1cclxuICApO1xyXG5cclxuICBjb25zdCBoYW5kbGVIVE1MQmx1ciA9IHVzZUNhbGxiYWNrKFxyXG4gICAgKGUpID0+IHtcclxuICAgICAgY29uc3QgaHRtbCA9IGUudGFyZ2V0LmlubmVySFRNTDtcclxuICAgICAgY29uc3QgX21hcmtkb3duID0gaHRtbFRvTWFya2Rvd24oeyBodG1sLCBvdXRwdXRGaWx0ZXJzIH0pO1xyXG4gICAgICBoYW5kbGVCbHVyKF9tYXJrZG93bik7XHJcbiAgICB9LFxyXG4gICAgW2hhbmRsZUJsdXIsIG91dHB1dEZpbHRlcnNdXHJcbiAgKTtcclxuXHJcbiAgY29uc3QgaGFuZGxlUmF3Qmx1ciA9IHVzZUNhbGxiYWNrKFxyXG4gICAgKGUpID0+IHtcclxuICAgICAgbGV0IHN0cmluZyA9IGUudGFyZ2V0LmlubmVyVGV4dDtcclxuICAgICAgc3RyaW5nID0gZnJvbURpc3BsYXkoc3RyaW5nKTtcclxuICAgICAgY29uc3QgX21hcmtkb3duID0gZmlsdGVyKHsgc3RyaW5nLCBmaWx0ZXJzOiBvdXRwdXRGaWx0ZXJzIH0pO1xyXG4gICAgICBoYW5kbGVCbHVyKF9tYXJrZG93bik7XHJcbiAgICB9LFxyXG4gICAgW2hhbmRsZUJsdXIsIG91dHB1dEZpbHRlcnNdXHJcbiAgKTtcclxuXHJcbiAgY29uc3QgaGFuZGxlS2V5UHJlc3MgPSB1c2VDYWxsYmFjayhcclxuICAgIChrZXljb2RlKSA9PiB7XHJcbiAgICAgIGlmIChhY3Rpb25zICYmIGFjdGlvbnMuc2V0SXNDaGFuZ2VkKSB7XHJcbiAgICAgICAgYWN0aW9ucy5zZXRJc0NoYW5nZWQodHJ1ZSk7XHJcbiAgICAgIH1cclxuICAgIH0sIFthY3Rpb25zXVxyXG4gICk7XHJcblxyXG4gIGNvbnN0IGhhbmRsZWRLZXlDb2RlcyA9IFs4LypEZWxldGUvQmFja3NwYWNlKi9dO1xyXG5cclxuICBjb25zdCBoYW5kbGVLZXlVcCA9IHVzZUNhbGxiYWNrKFxyXG4gICAgKGV2ZW50KSA9PiB7XHJcbiAgICAgIGlmIChhY3Rpb25zICYmIGFjdGlvbnMuc2V0SXNDaGFuZ2VkKSB7XHJcbiAgICAgICAgaWYgKGhhbmRsZWRLZXlDb2Rlcy5pbmNsdWRlcyhldmVudC5rZXlDb2RlKSkge1xyXG4gICAgICAgICAgLy8gTk9URTogd2UgZG9uJ3Qgd2FudCB0byBjb252ZXJ0IEhUTUwgb24ga2V5IGtleVVwLlxyXG4gICAgICAgICAgLy8gU28gd2UgY2FudCB0ZXN0IGZvciBjaGFuZ2VzLlxyXG4gICAgICAgICAgYWN0aW9ucy5zZXRJc0NoYW5nZWQodHJ1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9LCBbYWN0aW9uc11cclxuICApO1xyXG5cclxuICBjb25zdCBoYW5kbGVDdXRQYXN0ZSA9IHVzZUNhbGxiYWNrKFxyXG4gICAgKCkgPT4ge1xyXG4gICAgICBpZiAoYWN0aW9ucyAmJiBhY3Rpb25zLnNldElzQ2hhbmdlZCkge1xyXG4gICAgICAgIGFjdGlvbnMuc2V0SXNDaGFuZ2VkKHRydWUpO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChhY3Rpb25zICYmIGFjdGlvbnMuc2V0SXNBdXRvU2F2ZUNoYW5nZWQpIHtcclxuICAgICAgICBhY3Rpb25zLnNldElzQXV0b1NhdmVDaGFuZ2VkKHRydWUpO1xyXG4gICAgICB9XHJcbiAgICB9LCBbYWN0aW9uc11cclxuICApO1xyXG5cclxuICBjb25zdCBjb21wb25lbnQgPSB1c2VNZW1vKCgpID0+IHtcclxuICAgIGxldCBfY29tcG9uZW50O1xyXG5cclxuICAgIGlmICghcHJldmlldykge1xyXG4gICAgICBsZXQgY29kZSA9IGZpbHRlcih7IHN0cmluZzogbWFya2Rvd24sIGZpbHRlcnM6IGlucHV0RmlsdGVycyB9KTtcclxuICAgICAgY29kZSA9IHRvRGlzcGxheShjb2RlKTtcclxuICAgICAgY29uc3QgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwgPSB7IF9faHRtbDogY29kZSB9O1xyXG5cclxuICAgICAgX2NvbXBvbmVudCA9IChcclxuICAgICAgICA8cHJlIGNsYXNzTmFtZT17Y2xhc3Nlcy5wcmV9PlxyXG4gICAgICAgICAgPGNvZGVcclxuICAgICAgICAgICAgY2xhc3NOYW1lPXtjbGFzc2VzLm1hcmtkb3dufVxyXG4gICAgICAgICAgICBzdHlsZT17eyAuLi5fc3R5bGUsIGZvbnRTaXplIH19XHJcbiAgICAgICAgICAgIGRpcj0nYXV0bydcclxuICAgICAgICAgICAgY29udGVudEVkaXRhYmxlPXtlZGl0YWJsZX1cclxuICAgICAgICAgICAgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUw9e2Rhbmdlcm91c2x5U2V0SW5uZXJIVE1MfVxyXG4gICAgICAgICAgICBvbkJsdXI9e2hhbmRsZVJhd0JsdXJ9XHJcbiAgICAgICAgICAgIG9uS2V5UHJlc3M9e2hhbmRsZUtleVByZXNzfVxyXG4gICAgICAgICAgICBvbktleVVwPXtoYW5kbGVLZXlVcH1cclxuICAgICAgICAgICAgb25DdXQ9e2hhbmRsZUN1dFBhc3RlfVxyXG4gICAgICAgICAgICBvblBhc3RlPXtoYW5kbGVDdXRQYXN0ZX1cclxuICAgICAgICAgIC8+XHJcbiAgICAgICAgPC9wcmU+XHJcbiAgICAgICk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBjb25zdCBkYW5nZXJvdXNseVNldElubmVySFRNTCA9IHsgX19odG1sOiBtYXJrZG93blRvSHRtbCh7IG1hcmtkb3duLCBpbnB1dEZpbHRlcnMgfSkgfTtcclxuXHJcbiAgICAgIF9jb21wb25lbnQgPSAoXHJcbiAgICAgICAgPGRpdlxyXG4gICAgICAgICAgc3R5bGU9e3sgLi4uX3N0eWxlLCBmb250U2l6ZSB9fVxyXG4gICAgICAgICAgY2xhc3NOYW1lPXtjbGFzc2VzLmh0bWx9XHJcbiAgICAgICAgICBkaXI9J2F1dG8nXHJcbiAgICAgICAgICBjb250ZW50RWRpdGFibGU9e2VkaXRhYmxlfVxyXG4gICAgICAgICAgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUw9e2Rhbmdlcm91c2x5U2V0SW5uZXJIVE1MfVxyXG4gICAgICAgICAgb25CbHVyPXtoYW5kbGVIVE1MQmx1cn1cclxuICAgICAgICAgIG9uS2V5UHJlc3M9e2hhbmRsZUtleVByZXNzfVxyXG4gICAgICAgICAgb25LZXlVcD17aGFuZGxlS2V5VXB9XHJcbiAgICAgICAgICBvbkN1dD17aGFuZGxlQ3V0UGFzdGV9XHJcbiAgICAgICAgICBvblBhc3RlPXtoYW5kbGVDdXRQYXN0ZX1cclxuICAgICAgICAvPlxyXG4gICAgICApO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIF9jb21wb25lbnQ7XHJcbiAgfSwgW2ZvbnRTaXplLCBwcmV2aWV3LCBtYXJrZG93biwgZWRpdGFibGVdKTtcclxuXHJcbiAgcmV0dXJuIDxkaXYgY2xhc3NOYW1lPXtjbGFzc2VzLnJvb3R9Pntjb21wb25lbnR9PC9kaXY+O1xyXG59XHJcblxyXG5CbG9ja0VkaXRhYmxlLnByb3BUeXBlcyA9IHtcclxuICAvKiogSW5pdGlhbCBtYXJrZG93biBmb3IgdGhlIGVkaXRvci4gKi9cclxuICBtYXJrZG93bjogUHJvcFR5cGVzLnN0cmluZy5pc1JlcXVpcmVkLFxyXG4gIC8qKiBGdW5jdGlvbiB0byBwcm9wb2dhdGUgY2hhbmdlcyB0byB0aGUgbWFya2Rvd24uICovXHJcbiAgb25FZGl0OiBQcm9wVHlwZXMuZnVuYyxcclxuICAvKiogUmVwbGFjZSBzdHJpbmdzIGJlZm9yZSByZW5kZXJpbmcuICovXHJcbiAgaW5wdXRGaWx0ZXJzOiBQcm9wVHlwZXMuYXJyYXksXHJcbiAgLyoqIFJlcGxhY2Ugc3RyaW5ncyBhZnRlciBlZGl0aW5nLiAqL1xyXG4gIG91dHB1dEZpbHRlcnM6IFByb3BUeXBlcy5hcnJheSxcclxuICAvKiogQ1NTIGZvciB0aGUgY29tcG9uZW50LiAqL1xyXG4gIHN0eWxlOiBQcm9wVHlwZXMub2JqZWN0LFxyXG4gIC8qKiBEaXNwbGF5IFJhdyBNYXJrZG93biBvciBIVE1MLiAqL1xyXG4gIHByZXZpZXc6IFByb3BUeXBlcy5ib29sLFxyXG4gIC8qKiBFbmFibGUvRGlzYWJsZSBlZGl0YWJpbGl0eS4gKi9cclxuICBlZGl0YWJsZTogUHJvcFR5cGVzLmJvb2wsXHJcbiAgLyoqIGZvbnRTaXplIGUuZy4gJzEwMCUnICovXHJcbiAgZm9udFNpemU6IFByb3BUeXBlcy5zdHJpbmcsXHJcbn07XHJcblxyXG5CbG9ja0VkaXRhYmxlLmRlZmF1bHRQcm9wcyA9IHtcclxuICBtYXJrZG93bjogJycsXHJcbiAgb25FZGl0OiAoKSA9PiB7IH0sXHJcbiAgaW5wdXRGaWx0ZXJzOiBbXSxcclxuICBvdXRwdXRGaWx0ZXJzOiBbXSxcclxuICBzdHlsZToge30sXHJcbiAgcHJldmlldzogdHJ1ZSxcclxuICBlZGl0YWJsZTogdHJ1ZSxcclxufTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IEJsb2NrRWRpdGFibGU7XHJcbiJdfQ==