"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _react = _interopRequireWildcard(require("react"));

var _propTypes = _interopRequireDefault(require("prop-types"));

var _reactMarkdown = _interopRequireDefault(require("react-markdown"));

var _md = _interopRequireDefault(require("md5"));

var _core = require("@material-ui/core");

var _icons = require("@material-ui/icons");

var _blockTranslatable = _interopRequireDefault(require("../block-translatable"));

var _core2 = require("../../core/");

var _styles = require("./styles");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function SectionTranslatable(_ref) {
  var original = _ref.original,
      translation = _ref.translation,
      preview = _ref.preview,
      inputFilters = _ref.inputFilters,
      outputFilters = _ref.outputFilters,
      onTranslation = _ref.onTranslation,
      onExpanded = _ref.onExpanded,
      expanded = _ref.expanded,
      blockable = _ref.blockable,
      style = _ref.style;
  var classes = (0, _styles.useStyles)();

  var _useState = (0, _react.useState)(translation),
      _useState2 = _slicedToArray(_useState, 2),
      editedTranslation = _useState2[0],
      setEditedTranslation = _useState2[1];

  var originalBlocks = (0, _react.useMemo)(function () {
    return blockable ? (0, _core2.blocksFromMarkdown)({
      markdown: original
    }) : [original];
  }, [blockable, original]);

  var _translationBlocks = (0, _react.useMemo)(function () {
    return blockable ? (0, _core2.blocksFromMarkdown)({
      markdown: translation
    }) : [translation];
  }, [blockable, translation]);

  var _useReducer = (0, _react.useReducer)(_core2.itemsReducer, _translationBlocks),
      _useReducer2 = _slicedToArray(_useReducer, 2),
      translationBlocks = _useReducer2[0],
      dispatch = _useReducer2[1];

  var _onExpanded = (0, _react.useCallback)(onExpanded, []); // update translationBlocks to match blockable chained through _translationBlocks


  (0, _react.useEffect)(function () {
    dispatch({
      type: 'SET_ITEMS',
      value: {
        items: _translationBlocks
      }
    });
  }, [_translationBlocks]); // update onTranslation when translationBlocks are updated

  (0, _react.useEffect)(function () {
    var _translation = (0, _core2.markdownFromBlocks)({
      blocks: translationBlocks
    });

    setEditedTranslation(_translation);
  }, [translationBlocks]);
  (0, _react.useEffect)(function () {
    if (editedTranslation !== translation) {
      onTranslation(editedTranslation); // console.log('SectionTranslatable got updated editedTranslation');
    }
  }, [editedTranslation, onTranslation, translation]);
  var expandedToggle = (0, _react.useCallback)(function () {
    _onExpanded(!expanded);
  }, [_onExpanded, expanded]);
  var setTranslationBlock = (0, _react.useCallback)(function (_ref2) {
    var index = _ref2.index,
        item = _ref2.item;
    dispatch({
      type: 'SET_ITEM',
      value: {
        index: index,
        item: item
      }
    });
  }, []);
  var blockTranslatables = (0, _react.useCallback)(function () {
    var mostBlocks = originalBlocks.length > translationBlocks.length ? originalBlocks : translationBlocks;
    var _blocksTranslatables = [];

    var _loop = function _loop(i) {
      var _onTranslation = function _onTranslation(item) {
        return setTranslationBlock({
          index: i,
          item: item
        });
      };

      var translationBlock = translationBlocks[i];
      var originalBlock = originalBlocks[i];
      var key = i + (0, _md.default)(JSON.stringify(originalBlock + translationBlock));

      _blocksTranslatables.push( /*#__PURE__*/_react.default.createElement(_blockTranslatable.default, {
        key: key,
        original: originalBlock,
        translation: translationBlock,
        inputFilters: inputFilters,
        outputFilters: outputFilters,
        onTranslation: _onTranslation,
        preview: preview
      }));
    };

    for (var i = 0; i < mostBlocks.length; i++) {
      _loop(i);
    }

    ;
    return _blocksTranslatables;
  }, [inputFilters, originalBlocks, outputFilters, preview, setTranslationBlock, translationBlocks]);
  var titleBlock = originalBlocks[0].split('\n\n')[0] || translationBlocks[0].split('\n\n')[0];
  var summaryTitle = (0, _react.useMemo)(function () {
    return expanded ? /*#__PURE__*/_react.default.createElement(_react.default.Fragment, null) : /*#__PURE__*/_react.default.createElement(_reactMarkdown.default, {
      source: titleBlock,
      escapeHtml: false
    });
  }, [expanded, titleBlock]);
  var component = (0, _react.useMemo)(function () {
    return /*#__PURE__*/_react.default.createElement(_core.Accordion, {
      style: style,
      className: classes.root,
      expanded: expanded
    }, /*#__PURE__*/_react.default.createElement(_core.AccordionSummary, {
      expandIcon: /*#__PURE__*/_react.default.createElement(_icons.ExpandMore, null) // classes={{content: 'summaryContent'}}
      ,
      className: classes.content,
      onClick: expandedToggle
    }, summaryTitle), /*#__PURE__*/_react.default.createElement(_core.AccordionDetails, {
      className: classes.details
    }, blockTranslatables()), /*#__PURE__*/_react.default.createElement(_core.AccordionActions, {
      className: classes.actions
    }, /*#__PURE__*/_react.default.createElement(_core.IconButton, {
      onClick: expandedToggle
    }, /*#__PURE__*/_react.default.createElement(_icons.ExpandLess, null))));
  }, [blockTranslatables, classes, expanded, expandedToggle, style, summaryTitle]);
  return /*#__PURE__*/_react.default.createElement(_react.default.Fragment, null, component);
}

;
SectionTranslatable.propTypes = {
  /** Original markdown for the editor. */
  original: _propTypes.default.string.isRequired,

  /** Translation markdown for the editor. */
  translation: _propTypes.default.string.isRequired,

  /** Function to propogate changes to the translation. */
  onTranslation: _propTypes.default.func.isRequired,

  /** Preview HTML rendered vs Raw Markdown */
  preview: _propTypes.default.bool,

  /** Function to propogate changes to the Section in focus. */
  onExpanded: _propTypes.default.func,

  /** Set the Section in focus. */
  expanded: _propTypes.default.bool,

  /** Divide segments by blocks */
  blockable: _propTypes.default.bool,

  /** Replace strings before rendering. */
  inputFilters: _propTypes.default.array,

  /** Replace strings after editing. */
  outputFilters: _propTypes.default.array,

  /** CSS for the component. */
  style: _propTypes.default.object
};
SectionTranslatable.defaultProps = {
  original: '',
  translation: '',
  inputFilters: [],
  outputFilters: [],
  blockable: true,
  style: {}
};
var _default = SectionTranslatable;
/* code graveyard
  const blockTranslatables = useMemo(() => (
    originalBlocks.map((originalBlock, index) => {
      const _onTranslation = (item) => setTranslationBlock({ index, item });
      const translationBlock = translationBlocks[index];
      const key = index + md5(JSON.stringify(originalBlock + translationBlock));
      return (
        <BlockTranslatable
          key={key}
          original={originalBlock}
          translation={translationBlock}
          inputFilters={inputFilters}
          outputFilters={outputFilters}
          onTranslation={_onTranslation}
          preview={preview}
        />
      );
    })
  ), [originalBlocks, translationBlocks, inputFilters, outputFilters, preview, setTranslationBlock]);
*/

exports.default = _default;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9jb21wb25lbnRzL3NlY3Rpb24tdHJhbnNsYXRhYmxlL1NlY3Rpb25UcmFuc2xhdGFibGUuanMiXSwibmFtZXMiOlsiU2VjdGlvblRyYW5zbGF0YWJsZSIsIm9yaWdpbmFsIiwidHJhbnNsYXRpb24iLCJwcmV2aWV3IiwiaW5wdXRGaWx0ZXJzIiwib3V0cHV0RmlsdGVycyIsIm9uVHJhbnNsYXRpb24iLCJvbkV4cGFuZGVkIiwiZXhwYW5kZWQiLCJibG9ja2FibGUiLCJzdHlsZSIsImNsYXNzZXMiLCJlZGl0ZWRUcmFuc2xhdGlvbiIsInNldEVkaXRlZFRyYW5zbGF0aW9uIiwib3JpZ2luYWxCbG9ja3MiLCJtYXJrZG93biIsIl90cmFuc2xhdGlvbkJsb2NrcyIsIml0ZW1zUmVkdWNlciIsInRyYW5zbGF0aW9uQmxvY2tzIiwiZGlzcGF0Y2giLCJfb25FeHBhbmRlZCIsInR5cGUiLCJ2YWx1ZSIsIml0ZW1zIiwiX3RyYW5zbGF0aW9uIiwiYmxvY2tzIiwiZXhwYW5kZWRUb2dnbGUiLCJzZXRUcmFuc2xhdGlvbkJsb2NrIiwiaW5kZXgiLCJpdGVtIiwiYmxvY2tUcmFuc2xhdGFibGVzIiwibW9zdEJsb2NrcyIsImxlbmd0aCIsIl9ibG9ja3NUcmFuc2xhdGFibGVzIiwiaSIsIl9vblRyYW5zbGF0aW9uIiwidHJhbnNsYXRpb25CbG9jayIsIm9yaWdpbmFsQmxvY2siLCJrZXkiLCJKU09OIiwic3RyaW5naWZ5IiwicHVzaCIsInRpdGxlQmxvY2siLCJzcGxpdCIsInN1bW1hcnlUaXRsZSIsImNvbXBvbmVudCIsInJvb3QiLCJjb250ZW50IiwiZGV0YWlscyIsImFjdGlvbnMiLCJwcm9wVHlwZXMiLCJQcm9wVHlwZXMiLCJzdHJpbmciLCJpc1JlcXVpcmVkIiwiZnVuYyIsImJvb2wiLCJhcnJheSIsIm9iamVjdCIsImRlZmF1bHRQcm9wcyJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUE7O0FBR0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FB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QjtBQUtqQ0ksRUFBQUEsU0FBUyxFQUFFLElBTHNCO0FBTWpDQyxFQUFBQSxLQUFLLEVBQUU7QUFOMEIsQ0FBbkM7ZUFTZVYsbUI7QUFHZiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBSZWFjdCwge1xyXG4gIHVzZVN0YXRlLCB1c2VFZmZlY3QsIHVzZVJlZHVjZXIsIHVzZU1lbW8sIHVzZUNhbGxiYWNrLFxyXG59IGZyb20gJ3JlYWN0JztcclxuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcclxuaW1wb3J0IFJlYWN0TWFya2Rvd24gZnJvbSAncmVhY3QtbWFya2Rvd24nO1xyXG5pbXBvcnQgbWQ1IGZyb20gJ21kNSc7XHJcbmltcG9ydCB7XHJcbiAgQWNjb3JkaW9uLCBBY2NvcmRpb25TdW1tYXJ5LCBBY2NvcmRpb25EZXRhaWxzLCBBY2NvcmRpb25BY3Rpb25zLCBJY29uQnV0dG9uLFxyXG59IGZyb20gJ0BtYXRlcmlhbC11aS9jb3JlJztcclxuaW1wb3J0IHsgRXhwYW5kTW9yZSwgRXhwYW5kTGVzcyB9IGZyb20gJ0BtYXRlcmlhbC11aS9pY29ucyc7XHJcblxyXG5pbXBvcnQgQmxvY2tUcmFuc2xhdGFibGUgZnJvbSAnLi4vYmxvY2stdHJhbnNsYXRhYmxlJztcclxuXHJcbmltcG9ydCB7XHJcbiAgYmxvY2tzRnJvbU1hcmtkb3duLCBtYXJrZG93bkZyb21CbG9ja3MsIGl0ZW1zUmVkdWNlcixcclxufSBmcm9tICcuLi8uLi9jb3JlLyc7XHJcbmltcG9ydCB7IHVzZVN0eWxlcyB9IGZyb20gJy4vc3R5bGVzJztcclxuXHJcbmZ1bmN0aW9uIFNlY3Rpb25UcmFuc2xhdGFibGUoe1xyXG4gIG9yaWdpbmFsLFxyXG4gIHRyYW5zbGF0aW9uLFxyXG4gIHByZXZpZXcsXHJcbiAgaW5wdXRGaWx0ZXJzLFxyXG4gIG91dHB1dEZpbHRlcnMsXHJcbiAgb25UcmFuc2xhdGlvbixcclxuICBvbkV4cGFuZGVkLFxyXG4gIGV4cGFuZGVkLFxyXG4gIGJsb2NrYWJsZSxcclxuICBzdHlsZSxcclxufSkge1xyXG4gIGNvbnN0IGNsYXNzZXMgPSB1c2VTdHlsZXMoKTtcclxuICBjb25zdCBbZWRpdGVkVHJhbnNsYXRpb24sIHNldEVkaXRlZFRyYW5zbGF0aW9uXSA9IHVzZVN0YXRlKHRyYW5zbGF0aW9uKTtcclxuXHJcbiAgY29uc3Qgb3JpZ2luYWxCbG9ja3MgPSB1c2VNZW1vKCgpID0+IChcclxuICAgIChibG9ja2FibGUpID8gYmxvY2tzRnJvbU1hcmtkb3duKHsgbWFya2Rvd246IG9yaWdpbmFsIH0pIDogW29yaWdpbmFsXVxyXG4gICksIFtibG9ja2FibGUsIG9yaWdpbmFsXSk7XHJcblxyXG4gIGNvbnN0IF90cmFuc2xhdGlvbkJsb2NrcyA9IHVzZU1lbW8oKCkgPT4gKFxyXG4gICAgKGJsb2NrYWJsZSkgPyBibG9ja3NGcm9tTWFya2Rvd24oeyBtYXJrZG93bjogdHJhbnNsYXRpb24gfSkgOiBbdHJhbnNsYXRpb25dXHJcbiAgKSwgW2Jsb2NrYWJsZSwgdHJhbnNsYXRpb25dKTtcclxuICBjb25zdCBbdHJhbnNsYXRpb25CbG9ja3MsIGRpc3BhdGNoXSA9IHVzZVJlZHVjZXIoaXRlbXNSZWR1Y2VyLCBfdHJhbnNsYXRpb25CbG9ja3MpO1xyXG5cclxuICBjb25zdCBfb25FeHBhbmRlZCA9IHVzZUNhbGxiYWNrKG9uRXhwYW5kZWQsIFtdKTtcclxuXHJcbiAgLy8gdXBkYXRlIHRyYW5zbGF0aW9uQmxvY2tzIHRvIG1hdGNoIGJsb2NrYWJsZSBjaGFpbmVkIHRocm91Z2ggX3RyYW5zbGF0aW9uQmxvY2tzXHJcbiAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgIGRpc3BhdGNoKHsgdHlwZTogJ1NFVF9JVEVNUycsIHZhbHVlOiB7IGl0ZW1zOiBfdHJhbnNsYXRpb25CbG9ja3MgfSB9KTtcclxuICB9LCBbX3RyYW5zbGF0aW9uQmxvY2tzXSk7XHJcbiAgLy8gdXBkYXRlIG9uVHJhbnNsYXRpb24gd2hlbiB0cmFuc2xhdGlvbkJsb2NrcyBhcmUgdXBkYXRlZFxyXG4gIHVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICBjb25zdCBfdHJhbnNsYXRpb24gPSBtYXJrZG93bkZyb21CbG9ja3MoeyBibG9ja3M6IHRyYW5zbGF0aW9uQmxvY2tzIH0pO1xyXG4gICAgc2V0RWRpdGVkVHJhbnNsYXRpb24oX3RyYW5zbGF0aW9uKTtcclxuICB9LCBbdHJhbnNsYXRpb25CbG9ja3NdKTtcclxuXHJcbiAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgIGlmIChlZGl0ZWRUcmFuc2xhdGlvbiAhPT0gdHJhbnNsYXRpb24pIHtcclxuICAgICAgb25UcmFuc2xhdGlvbihlZGl0ZWRUcmFuc2xhdGlvbik7XHJcbiAgICAgIC8vIGNvbnNvbGUubG9nKCdTZWN0aW9uVHJhbnNsYXRhYmxlIGdvdCB1cGRhdGVkIGVkaXRlZFRyYW5zbGF0aW9uJyk7XHJcbiAgICB9XHJcbiAgfSwgW2VkaXRlZFRyYW5zbGF0aW9uLCBvblRyYW5zbGF0aW9uLCB0cmFuc2xhdGlvbl0pO1xyXG5cclxuICBjb25zdCBleHBhbmRlZFRvZ2dsZSA9IHVzZUNhbGxiYWNrKCgpID0+IHtcclxuICAgIF9vbkV4cGFuZGVkKCFleHBhbmRlZCk7XHJcbiAgfSwgW19vbkV4cGFuZGVkLCBleHBhbmRlZF0pO1xyXG5cclxuICBjb25zdCBzZXRUcmFuc2xhdGlvbkJsb2NrID0gdXNlQ2FsbGJhY2soKHsgaW5kZXgsIGl0ZW0gfSkgPT4ge1xyXG4gICAgZGlzcGF0Y2goeyB0eXBlOiAnU0VUX0lURU0nLCB2YWx1ZTogeyBpbmRleCwgaXRlbSB9IH0pO1xyXG4gIH0sIFtdKTtcclxuXHJcbiAgY29uc3QgYmxvY2tUcmFuc2xhdGFibGVzID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xyXG4gICAgY29uc3QgbW9zdEJsb2NrcyA9IG9yaWdpbmFsQmxvY2tzLmxlbmd0aCA+IHRyYW5zbGF0aW9uQmxvY2tzLmxlbmd0aCA/XHJcbiAgICAgIG9yaWdpbmFsQmxvY2tzIDogdHJhbnNsYXRpb25CbG9ja3M7XHJcblxyXG4gICAgY29uc3QgX2Jsb2Nrc1RyYW5zbGF0YWJsZXMgPSBbXTtcclxuXHJcbiAgICBmb3IgKCBsZXQgaT0wOyBpIDwgbW9zdEJsb2Nrcy5sZW5ndGg7IGkrKyApIHtcclxuICAgICAgY29uc3QgX29uVHJhbnNsYXRpb24gPSAoaXRlbSkgPT4gc2V0VHJhbnNsYXRpb25CbG9jayh7IGluZGV4OiBpLCBpdGVtIH0pO1xyXG4gICAgICBjb25zdCB0cmFuc2xhdGlvbkJsb2NrID0gdHJhbnNsYXRpb25CbG9ja3NbaV07XHJcbiAgICAgIGNvbnN0IG9yaWdpbmFsQmxvY2sgPSBvcmlnaW5hbEJsb2Nrc1tpXTtcclxuICAgICAgY29uc3Qga2V5ID0gaSArIG1kNShKU09OLnN0cmluZ2lmeShvcmlnaW5hbEJsb2NrICsgdHJhbnNsYXRpb25CbG9jaykpO1xyXG5cclxuICAgICAgX2Jsb2Nrc1RyYW5zbGF0YWJsZXMucHVzaChcclxuICAgICAgICA8QmxvY2tUcmFuc2xhdGFibGVcclxuICAgICAgICAgIGtleT17a2V5fVxyXG4gICAgICAgICAgb3JpZ2luYWw9e29yaWdpbmFsQmxvY2t9XHJcbiAgICAgICAgICB0cmFuc2xhdGlvbj17dHJhbnNsYXRpb25CbG9ja31cclxuICAgICAgICAgIGlucHV0RmlsdGVycz17aW5wdXRGaWx0ZXJzfVxyXG4gICAgICAgICAgb3V0cHV0RmlsdGVycz17b3V0cHV0RmlsdGVyc31cclxuICAgICAgICAgIG9uVHJhbnNsYXRpb249e19vblRyYW5zbGF0aW9ufVxyXG4gICAgICAgICAgcHJldmlldz17cHJldmlld31cclxuICAgICAgICAvPlxyXG4gICAgICApO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBfYmxvY2tzVHJhbnNsYXRhYmxlcztcclxuICB9LCBbaW5wdXRGaWx0ZXJzLCBvcmlnaW5hbEJsb2Nrcywgb3V0cHV0RmlsdGVycywgcHJldmlldywgc2V0VHJhbnNsYXRpb25CbG9jaywgdHJhbnNsYXRpb25CbG9ja3NdKTtcclxuXHJcbiAgY29uc3QgdGl0bGVCbG9jayA9IG9yaWdpbmFsQmxvY2tzWzBdLnNwbGl0KCdcXG5cXG4nKVswXSB8fCB0cmFuc2xhdGlvbkJsb2Nrc1swXS5zcGxpdCgnXFxuXFxuJylbMF07XHJcblxyXG4gIGNvbnN0IHN1bW1hcnlUaXRsZSA9IHVzZU1lbW8oKCkgPT4gKFxyXG4gICAgKGV4cGFuZGVkKSA/IDw+PC8+IDogPFJlYWN0TWFya2Rvd24gc291cmNlPXt0aXRsZUJsb2NrfSBlc2NhcGVIdG1sPXtmYWxzZX0gLz5cclxuICApLCBbZXhwYW5kZWQsIHRpdGxlQmxvY2tdKTtcclxuXHJcbiAgY29uc3QgY29tcG9uZW50ID0gdXNlTWVtbygoKSA9PiAoXHJcbiAgICA8QWNjb3JkaW9uIHN0eWxlPXtzdHlsZX0gY2xhc3NOYW1lPXtjbGFzc2VzLnJvb3R9IGV4cGFuZGVkPXtleHBhbmRlZH0+XHJcbiAgICAgIDxBY2NvcmRpb25TdW1tYXJ5XHJcbiAgICAgICAgZXhwYW5kSWNvbj17PEV4cGFuZE1vcmUgLz59XHJcbiAgICAgICAgLy8gY2xhc3Nlcz17e2NvbnRlbnQ6ICdzdW1tYXJ5Q29udGVudCd9fVxyXG4gICAgICAgIGNsYXNzTmFtZT17Y2xhc3Nlcy5jb250ZW50fVxyXG4gICAgICAgIG9uQ2xpY2s9e2V4cGFuZGVkVG9nZ2xlfT5cclxuICAgICAgICB7c3VtbWFyeVRpdGxlfVxyXG4gICAgICA8L0FjY29yZGlvblN1bW1hcnk+XHJcbiAgICAgIDxBY2NvcmRpb25EZXRhaWxzIGNsYXNzTmFtZT17Y2xhc3Nlcy5kZXRhaWxzfT5cclxuICAgICAgICB7YmxvY2tUcmFuc2xhdGFibGVzKCl9XHJcbiAgICAgIDwvQWNjb3JkaW9uRGV0YWlscz5cclxuICAgICAgPEFjY29yZGlvbkFjdGlvbnMgY2xhc3NOYW1lPXtjbGFzc2VzLmFjdGlvbnN9PlxyXG4gICAgICAgIDxJY29uQnV0dG9uIG9uQ2xpY2s9e2V4cGFuZGVkVG9nZ2xlfT5cclxuICAgICAgICAgIDxFeHBhbmRMZXNzIC8+XHJcbiAgICAgICAgPC9JY29uQnV0dG9uPlxyXG4gICAgICA8L0FjY29yZGlvbkFjdGlvbnM+XHJcbiAgICA8L0FjY29yZGlvbj5cclxuICApLCBbYmxvY2tUcmFuc2xhdGFibGVzLCBjbGFzc2VzLCBleHBhbmRlZCwgZXhwYW5kZWRUb2dnbGUsIHN0eWxlLCBzdW1tYXJ5VGl0bGVdKTtcclxuXHJcbiAgcmV0dXJuIChcclxuICAgIDw+XHJcbiAgICAgIHtjb21wb25lbnR9XHJcbiAgICA8Lz5cclxuICApO1xyXG59O1xyXG5cclxuU2VjdGlvblRyYW5zbGF0YWJsZS5wcm9wVHlwZXMgPSB7XHJcbiAgLyoqIE9yaWdpbmFsIG1hcmtkb3duIGZvciB0aGUgZWRpdG9yLiAqL1xyXG4gIG9yaWdpbmFsOiBQcm9wVHlwZXMuc3RyaW5nLmlzUmVxdWlyZWQsXHJcbiAgLyoqIFRyYW5zbGF0aW9uIG1hcmtkb3duIGZvciB0aGUgZWRpdG9yLiAqL1xyXG4gIHRyYW5zbGF0aW9uOiBQcm9wVHlwZXMuc3RyaW5nLmlzUmVxdWlyZWQsXHJcbiAgLyoqIEZ1bmN0aW9uIHRvIHByb3BvZ2F0ZSBjaGFuZ2VzIHRvIHRoZSB0cmFuc2xhdGlvbi4gKi9cclxuICBvblRyYW5zbGF0aW9uOiBQcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkLFxyXG4gIC8qKiBQcmV2aWV3IEhUTUwgcmVuZGVyZWQgdnMgUmF3IE1hcmtkb3duICovXHJcbiAgcHJldmlldzogUHJvcFR5cGVzLmJvb2wsXHJcbiAgLyoqIEZ1bmN0aW9uIHRvIHByb3BvZ2F0ZSBjaGFuZ2VzIHRvIHRoZSBTZWN0aW9uIGluIGZvY3VzLiAqL1xyXG4gIG9uRXhwYW5kZWQ6IFByb3BUeXBlcy5mdW5jLFxyXG4gIC8qKiBTZXQgdGhlIFNlY3Rpb24gaW4gZm9jdXMuICovXHJcbiAgZXhwYW5kZWQ6IFByb3BUeXBlcy5ib29sLFxyXG4gIC8qKiBEaXZpZGUgc2VnbWVudHMgYnkgYmxvY2tzICovXHJcbiAgYmxvY2thYmxlOiBQcm9wVHlwZXMuYm9vbCxcclxuICAvKiogUmVwbGFjZSBzdHJpbmdzIGJlZm9yZSByZW5kZXJpbmcuICovXHJcbiAgaW5wdXRGaWx0ZXJzOiBQcm9wVHlwZXMuYXJyYXksXHJcbiAgLyoqIFJlcGxhY2Ugc3RyaW5ncyBhZnRlciBlZGl0aW5nLiAqL1xyXG4gIG91dHB1dEZpbHRlcnM6IFByb3BUeXBlcy5hcnJheSxcclxuICAvKiogQ1NTIGZvciB0aGUgY29tcG9uZW50LiAqL1xyXG4gIHN0eWxlOiBQcm9wVHlwZXMub2JqZWN0LFxyXG59O1xyXG5cclxuU2VjdGlvblRyYW5zbGF0YWJsZS5kZWZhdWx0UHJvcHMgPSB7XHJcbiAgb3JpZ2luYWw6ICcnLFxyXG4gIHRyYW5zbGF0aW9uOiAnJyxcclxuICBpbnB1dEZpbHRlcnM6IFtdLFxyXG4gIG91dHB1dEZpbHRlcnM6IFtdLFxyXG4gIGJsb2NrYWJsZTogdHJ1ZSxcclxuICBzdHlsZToge30sXHJcbn07XHJcblxyXG5leHBvcnQgZGVmYXVsdCBTZWN0aW9uVHJhbnNsYXRhYmxlO1xyXG5cclxuXHJcbi8qIGNvZGUgZ3JhdmV5YXJkXHJcbiAgY29uc3QgYmxvY2tUcmFuc2xhdGFibGVzID0gdXNlTWVtbygoKSA9PiAoXHJcbiAgICBvcmlnaW5hbEJsb2Nrcy5tYXAoKG9yaWdpbmFsQmxvY2ssIGluZGV4KSA9PiB7XHJcbiAgICAgIGNvbnN0IF9vblRyYW5zbGF0aW9uID0gKGl0ZW0pID0+IHNldFRyYW5zbGF0aW9uQmxvY2soeyBpbmRleCwgaXRlbSB9KTtcclxuICAgICAgY29uc3QgdHJhbnNsYXRpb25CbG9jayA9IHRyYW5zbGF0aW9uQmxvY2tzW2luZGV4XTtcclxuICAgICAgY29uc3Qga2V5ID0gaW5kZXggKyBtZDUoSlNPTi5zdHJpbmdpZnkob3JpZ2luYWxCbG9jayArIHRyYW5zbGF0aW9uQmxvY2spKTtcclxuICAgICAgcmV0dXJuIChcclxuICAgICAgICA8QmxvY2tUcmFuc2xhdGFibGVcclxuICAgICAgICAgIGtleT17a2V5fVxyXG4gICAgICAgICAgb3JpZ2luYWw9e29yaWdpbmFsQmxvY2t9XHJcbiAgICAgICAgICB0cmFuc2xhdGlvbj17dHJhbnNsYXRpb25CbG9ja31cclxuICAgICAgICAgIGlucHV0RmlsdGVycz17aW5wdXRGaWx0ZXJzfVxyXG4gICAgICAgICAgb3V0cHV0RmlsdGVycz17b3V0cHV0RmlsdGVyc31cclxuICAgICAgICAgIG9uVHJhbnNsYXRpb249e19vblRyYW5zbGF0aW9ufVxyXG4gICAgICAgICAgcHJldmlldz17cHJldmlld31cclxuICAgICAgICAvPlxyXG4gICAgICApO1xyXG4gICAgfSlcclxuICApLCBbb3JpZ2luYWxCbG9ja3MsIHRyYW5zbGF0aW9uQmxvY2tzLCBpbnB1dEZpbHRlcnMsIG91dHB1dEZpbHRlcnMsIHByZXZpZXcsIHNldFRyYW5zbGF0aW9uQmxvY2tdKTtcclxuKi8iXX0=