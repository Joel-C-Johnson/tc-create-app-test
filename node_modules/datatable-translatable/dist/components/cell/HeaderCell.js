"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _react = _interopRequireWildcard(require("react"));

var _propTypes = _interopRequireDefault(require("prop-types"));

var _lodash = _interopRequireDefault(require("lodash.isequal"));

var _ActionsMenu = _interopRequireDefault(require("../actions-menu/ActionsMenu"));

var _styles = _interopRequireDefault(require("./styles"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function HeaderCell(props) {
  var _props$tableMeta = props.tableMeta,
      rowIndex = _props$tableMeta.rowIndex,
      rowData = _props$tableMeta.rowData,
      rowHeader = props.rowHeader,
      delimiters = props.delimiters,
      _props$generateRowId = props.generateRowId,
      generateRowId = _props$generateRowId === void 0 ? function () {} : _props$generateRowId;
  var classes = (0, _styles["default"])();
  var rowHeaderComponent = rowHeader(rowData.slice(1), /*#__PURE__*/_react["default"].createElement(_ActionsMenu["default"], {
    generateRowId: generateRowId,
    rowData: rowData,
    rowIndex: rowIndex,
    delimiters: delimiters
  }));
  return /*#__PURE__*/_react["default"].createElement("div", {
    className: 'header-row ' + classes.root,
    id: generateRowId(rowData)
  }, /*#__PURE__*/_react["default"].createElement("div", {
    className: classes.rowHeader
  }, rowHeaderComponent));
}

;
HeaderCell.propTypes = {
  /** The tableMeta passed from MUIDataTables */
  tableMeta: _propTypes["default"].object.isRequired,

  /** The function to render the rowHeader */
  rowHeader: _propTypes["default"].func,

  /** Set html preview mode, false renders raw markdown */
  generateRowId: _propTypes["default"].func,

  /** Create the row Id for scrolling */
  delimiters: _propTypes["default"].shape({
    /** Delimiters to convert a files into rows "\n" */
    row: _propTypes["default"].string.isRequired,

    /** Delimiters to convert a row into cells "\t" */
    cell: _propTypes["default"].string.isRequired
  }).isRequired
};
HeaderCell.defaultProps = {
  delimiters: {
    row: '\n',
    cell: '\t'
  }
};

var shouldReRender = function shouldReRender(prevProps, nextProps) {
  return (0, _lodash["default"])(prevProps.tableMeta, nextProps.tableMeta);
};

var _default = /*#__PURE__*/(0, _react.memo)(HeaderCell, shouldReRender);

exports["default"] = _default;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9jb21wb25lbnRzL2NlbGwvSGVhZGVyQ2VsbC5qcyJdLCJuYW1lcyI6WyJIZWFkZXJDZWxsIiwicHJvcHMiLCJ0YWJsZU1ldGEiLCJyb3dJbmRleCIsInJvd0RhdGEiLCJyb3dIZWFkZXIiLCJkZWxpbWl0ZXJzIiwiZ2VuZXJhdGVSb3dJZCIsImNsYXNzZXMiLCJyb3dIZWFkZXJDb21wb25lbnQiLCJzbGljZSIsInJvb3QiLCJwcm9wVHlwZXMiLCJQcm9wVHlwZXMiLCJvYmplY3QiLCJpc1JlcXVpcmVkIiwiZnVuYyIsInNoYXBlIiwicm93Iiwic3RyaW5nIiwiY2VsbCIsImRlZmF1bHRQcm9wcyIsInNob3VsZFJlUmVuZGVyIiwicHJldlByb3BzIiwibmV4dFByb3BzIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFFQTs7Ozs7Ozs7QUFFQSxTQUFTQSxVQUFULENBQW9CQyxLQUFwQixFQUEyQjtBQUFBLHlCQVNyQkEsS0FUcUIsQ0FFdkJDLFNBRnVCO0FBQUEsTUFHckJDLFFBSHFCLG9CQUdyQkEsUUFIcUI7QUFBQSxNQUlyQkMsT0FKcUIsb0JBSXJCQSxPQUpxQjtBQUFBLE1BTXZCQyxTQU51QixHQVNyQkosS0FUcUIsQ0FNdkJJLFNBTnVCO0FBQUEsTUFPdkJDLFVBUHVCLEdBU3JCTCxLQVRxQixDQU92QkssVUFQdUI7QUFBQSw2QkFTckJMLEtBVHFCLENBUXZCTSxhQVJ1QjtBQUFBLE1BUXZCQSxhQVJ1QixxQ0FRUCxZQUFNLENBQUUsQ0FSRDtBQVV6QixNQUFNQyxPQUFPLEdBQUcseUJBQWhCO0FBQ0EsTUFBTUMsa0JBQWtCLEdBQUdKLFNBQVMsQ0FBQ0QsT0FBTyxDQUFDTSxLQUFSLENBQWMsQ0FBZCxDQUFELGVBQW1CLGdDQUFDLHVCQUFEO0FBQ3JELElBQUEsYUFBYSxFQUFFSCxhQURzQztBQUVyRCxJQUFBLE9BQU8sRUFBRUgsT0FGNEM7QUFHckQsSUFBQSxRQUFRLEVBQUVELFFBSDJDO0FBSXJELElBQUEsVUFBVSxFQUFFRztBQUp5QyxJQUFuQixDQUFwQztBQU1BLHNCQUNFO0FBQUssSUFBQSxTQUFTLEVBQUUsZ0JBQWdCRSxPQUFPLENBQUNHLElBQXhDO0FBQThDLElBQUEsRUFBRSxFQUFFSixhQUFhLENBQUNILE9BQUQ7QUFBL0Qsa0JBQ0U7QUFBSyxJQUFBLFNBQVMsRUFBRUksT0FBTyxDQUFDSDtBQUF4QixLQUFvQ0ksa0JBQXBDLENBREYsQ0FERjtBQUtEOztBQUFBO0FBRURULFVBQVUsQ0FBQ1ksU0FBWCxHQUF1QjtBQUNyQjtBQUNBVixFQUFBQSxTQUFTLEVBQUVXLHNCQUFVQyxNQUFWLENBQWlCQyxVQUZQOztBQUdyQjtBQUNBVixFQUFBQSxTQUFTLEVBQUVRLHNCQUFVRyxJQUpBOztBQUtyQjtBQUNBVCxFQUFBQSxhQUFhLEVBQUVNLHNCQUFVRyxJQU5KOztBQU9yQjtBQUNBVixFQUFBQSxVQUFVLEVBQUVPLHNCQUFVSSxLQUFWLENBQWdCO0FBQzFCO0FBQ0FDLElBQUFBLEdBQUcsRUFBRUwsc0JBQVVNLE1BQVYsQ0FBaUJKLFVBRkk7O0FBRzFCO0FBQ0FLLElBQUFBLElBQUksRUFBRVAsc0JBQVVNLE1BQVYsQ0FBaUJKO0FBSkcsR0FBaEIsRUFLVEE7QUFia0IsQ0FBdkI7QUFnQkFmLFVBQVUsQ0FBQ3FCLFlBQVgsR0FBMEI7QUFDeEJmLEVBQUFBLFVBQVUsRUFBRTtBQUNWWSxJQUFBQSxHQUFHLEVBQUUsSUFESztBQUVWRSxJQUFBQSxJQUFJLEVBQUU7QUFGSTtBQURZLENBQTFCOztBQVFBLElBQU1FLGNBQWMsR0FBRyxTQUFqQkEsY0FBaUIsQ0FBQ0MsU0FBRCxFQUFZQyxTQUFaO0FBQUEsU0FBMEIsd0JBQVFELFNBQVMsQ0FBQ3JCLFNBQWxCLEVBQTZCc0IsU0FBUyxDQUFDdEIsU0FBdkMsQ0FBMUI7QUFBQSxDQUF2Qjs7NEJBRWUsaUJBQUtGLFVBQUwsRUFBaUJzQixjQUFqQixDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFJlYWN0LCB7IG1lbW8gfSBmcm9tICdyZWFjdCc7XHJcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XHJcbmltcG9ydCBpc0VxdWFsIGZyb20gJ2xvZGFzaC5pc2VxdWFsJztcclxuaW1wb3J0IEFjdGlvbnNNZW51IGZyb20gJy4uL2FjdGlvbnMtbWVudS9BY3Rpb25zTWVudSc7XHJcblxyXG5pbXBvcnQgdXNlU3R5bGVzIGZyb20gJy4vc3R5bGVzJztcclxuXHJcbmZ1bmN0aW9uIEhlYWRlckNlbGwocHJvcHMpIHtcclxuICBjb25zdCB7XHJcbiAgICB0YWJsZU1ldGE6IHtcclxuICAgICAgcm93SW5kZXgsXHJcbiAgICAgIHJvd0RhdGEsXHJcbiAgICB9LFxyXG4gICAgcm93SGVhZGVyLFxyXG4gICAgZGVsaW1pdGVycyxcclxuICAgIGdlbmVyYXRlUm93SWQgPSAoKSA9PiB7fSxcclxuICB9ID0gcHJvcHM7XHJcbiAgY29uc3QgY2xhc3NlcyA9IHVzZVN0eWxlcygpO1xyXG4gIGNvbnN0IHJvd0hlYWRlckNvbXBvbmVudCA9IHJvd0hlYWRlcihyb3dEYXRhLnNsaWNlKDEpLCA8QWN0aW9uc01lbnVcclxuICAgIGdlbmVyYXRlUm93SWQ9e2dlbmVyYXRlUm93SWR9XHJcbiAgICByb3dEYXRhPXtyb3dEYXRhfVxyXG4gICAgcm93SW5kZXg9e3Jvd0luZGV4fVxyXG4gICAgZGVsaW1pdGVycz17ZGVsaW1pdGVyc31cclxuICAvPik7XHJcbiAgcmV0dXJuIChcclxuICAgIDxkaXYgY2xhc3NOYW1lPXsnaGVhZGVyLXJvdyAnICsgY2xhc3Nlcy5yb290fSBpZD17Z2VuZXJhdGVSb3dJZChyb3dEYXRhKX0+XHJcbiAgICAgIDxkaXYgY2xhc3NOYW1lPXtjbGFzc2VzLnJvd0hlYWRlcn0+e3Jvd0hlYWRlckNvbXBvbmVudH08L2Rpdj5cclxuICAgIDwvZGl2PlxyXG4gICk7XHJcbn07XHJcblxyXG5IZWFkZXJDZWxsLnByb3BUeXBlcyA9IHtcclxuICAvKiogVGhlIHRhYmxlTWV0YSBwYXNzZWQgZnJvbSBNVUlEYXRhVGFibGVzICovXHJcbiAgdGFibGVNZXRhOiBQcm9wVHlwZXMub2JqZWN0LmlzUmVxdWlyZWQsXHJcbiAgLyoqIFRoZSBmdW5jdGlvbiB0byByZW5kZXIgdGhlIHJvd0hlYWRlciAqL1xyXG4gIHJvd0hlYWRlcjogUHJvcFR5cGVzLmZ1bmMsXHJcbiAgLyoqIFNldCBodG1sIHByZXZpZXcgbW9kZSwgZmFsc2UgcmVuZGVycyByYXcgbWFya2Rvd24gKi9cclxuICBnZW5lcmF0ZVJvd0lkOiBQcm9wVHlwZXMuZnVuYyxcclxuICAvKiogQ3JlYXRlIHRoZSByb3cgSWQgZm9yIHNjcm9sbGluZyAqL1xyXG4gIGRlbGltaXRlcnM6IFByb3BUeXBlcy5zaGFwZSh7XHJcbiAgICAvKiogRGVsaW1pdGVycyB0byBjb252ZXJ0IGEgZmlsZXMgaW50byByb3dzIFwiXFxuXCIgKi9cclxuICAgIHJvdzogUHJvcFR5cGVzLnN0cmluZy5pc1JlcXVpcmVkLFxyXG4gICAgLyoqIERlbGltaXRlcnMgdG8gY29udmVydCBhIHJvdyBpbnRvIGNlbGxzIFwiXFx0XCIgKi9cclxuICAgIGNlbGw6IFByb3BUeXBlcy5zdHJpbmcuaXNSZXF1aXJlZCxcclxuICB9KS5pc1JlcXVpcmVkLFxyXG59O1xyXG5cclxuSGVhZGVyQ2VsbC5kZWZhdWx0UHJvcHMgPSB7XHJcbiAgZGVsaW1pdGVyczoge1xyXG4gICAgcm93OiAnXFxuJyxcclxuICAgIGNlbGw6ICdcXHQnLFxyXG4gIH0sXHJcbn07XHJcblxyXG5cclxuY29uc3Qgc2hvdWxkUmVSZW5kZXIgPSAocHJldlByb3BzLCBuZXh0UHJvcHMpID0+IGlzRXF1YWwocHJldlByb3BzLnRhYmxlTWV0YSwgbmV4dFByb3BzLnRhYmxlTWV0YSk7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBtZW1vKEhlYWRlckNlbGwsIHNob3VsZFJlUmVuZGVyKTtcclxuIl19