"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = DataTableWrapper;

var _ = require("../..");

var _muiTheme = require("./muiTheme");

var _DataTable = require("./DataTable.context");

var _helpers = require("./helpers");

var _react = _interopRequireWildcard(require("react"));

var _lodash = _interopRequireDefault(require("lodash.isequal"));

var _useDeepCompareEffect = _interopRequireDefault(require("use-deep-compare-effect"));

var _propTypes = _interopRequireDefault(require("prop-types"));

var _muiDatatables = _interopRequireDefault(require("mui-datatables"));

var _styles = require("@material-ui/core/styles");

var _markdownTranslatable = require("markdown-translatable");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

var fixedHeaderOptions = {
  xAxis: false,
  yAxis: false
};
var rowsPerPageOptions = [25, 50, 100];

function DataTableWrapper(props) {
  return /*#__PURE__*/_react["default"].createElement(_markdownTranslatable.MarkdownContextProvider, null, /*#__PURE__*/_react["default"].createElement(_DataTable.DataTableContextProvider, props, /*#__PURE__*/_react["default"].createElement(DataTable, props)));
} // eslint-disable-next-line react/display-name


var DatatableMemo = /*#__PURE__*/_react["default"].memo(function (_ref) {
  var columns = _ref.columns,
      options = _ref.options,
      data = _ref.data,
      dataTableElement = _ref.dataTableElement;
  return /*#__PURE__*/_react["default"].createElement(_muiDatatables["default"], {
    ref: dataTableElement,
    columns: columns,
    options: options,
    data: data
  });
}, function (prevProps, nextProps) {
  var equal = (0, _lodash["default"])(prevProps.data, nextProps.data) && (0, _lodash["default"])(prevProps.columns, nextProps.columns) && (0, _lodash["default"])(prevProps.options, nextProps.options);
  return equal;
});

function DataTable(_ref2) {
  var _ref2$options = _ref2.options,
      options = _ref2$options === void 0 ? {} : _ref2$options,
      delimiters = _ref2.delimiters,
      config = _ref2.config,
      onSave = _ref2.onSave,
      onEdit = _ref2.onEdit,
      onValidate = _ref2.onValidate,
      onContentIsDirty = _ref2.onContentIsDirty,
      sourceFile = _ref2.sourceFile,
      _generateRowId = _ref2.generateRowId,
      props = _objectWithoutProperties(_ref2, ["options", "delimiters", "config", "onSave", "onEdit", "onValidate", "onContentIsDirty", "sourceFile", "generateRowId"]);

  var columnsFilter = config.columnsFilter,
      columnsShowDefault = config.columnsShowDefault,
      rowHeader = config.rowHeader;
  var dataTableElement = (0, _react.useRef)();

  var _useState = (0, _react.useState)(options.rowsPerPage || 25),
      _useState2 = _slicedToArray(_useState, 2),
      rowsPerPage = _useState2[0],
      setRowsPerPage = _useState2[1];

  var _useState3 = (0, _react.useState)(true),
      _useState4 = _slicedToArray(_useState3, 2),
      preview = _useState4[0],
      setPreview = _useState4[1];

  var _useState5 = (0, _react.useState)(columnsShowDefault),
      _useState6 = _slicedToArray(_useState5, 2),
      columnsShow = _useState6[0],
      setColumnsShow = _useState6[1];

  var _useState7 = (0, _react.useState)(false),
      _useState8 = _slicedToArray(_useState7, 2),
      isAutoSaveChanged = _useState8[0],
      setIsAutoSaveChanged = _useState8[1];

  var _useContext = (0, _react.useContext)(_DataTable.DataTableContext),
      state = _useContext.state,
      actions = _useContext.actions;

  var columnNames = state.columnNames,
      data = state.data,
      columnsFilterOptions = state.columnsFilterOptions;
  var _cellEdit = actions.cellEdit;

  var _ref3 = (0, _react.useContext)(_markdownTranslatable.MarkdownContext) || {},
      markdownState = _ref3.state,
      markdownActions = _ref3.actions;

  var generateRowId = (0, _react.useCallback)(_generateRowId, []);
  var cellEdit = (0, _react.useCallback)(function (parms) {
    _cellEdit(parms);

    setIsAutoSaveChanged(true);
  }, [_cellEdit, setIsAutoSaveChanged]);
  var changePage = (0, _react.useCallback)(function (page) {
    dataTableElement.current.changePage(page);
  }, [dataTableElement]);
  (0, _useDeepCompareEffect["default"])(function () {
    changePage(0);
  }, [changePage]); // Push "isChanged," so app knows when SAVE button is enabled.
  // See also Translatable in markdown-translatable.

  (0, _react.useEffect)(function () {
    if (onContentIsDirty) {
      onContentIsDirty(markdownState.isChanged);
    }
  }, [markdownState.isChanged, onContentIsDirty]);
  var togglePreview = (0, _react.useCallback)(function () {
    return setPreview(!preview);
  }, [preview]); // _onSave is called by Toolbar; cellEdit is called by DataTable.
  // State (contents) are different at these two times. (cellEdit lags)

  var _onSave = (0, _react.useCallback)(function () {
    var savedFile = actions.targetFileSave();
    onSave(savedFile);

    if (markdownActions && markdownActions.setIsChanged) {
      markdownActions.setIsChanged(false);
    }
  }, [actions, onSave, markdownActions]);

  (0, _useDeepCompareEffect["default"])(function () {
    console.log("useDeepEffect for isAutoSaveChanged");

    if (onEdit && isAutoSaveChanged) {
      var savedFile = actions.targetFileSave();
      onEdit(savedFile);
      setIsAutoSaveChanged(false); // if (markdownActions && markdownActions.setIsAutoSaveChanged) {
      //   markdownActions.setIsAutoSaveChanged(false);
      // }
    }
  }, [isAutoSaveChanged, onEdit, markdownActions, actions]);
  var onColumnViewChange = (0, _react.useCallback)(function (changedColumn, action) {
    var _columnsShow = _toConsumableArray(columnsShow);

    if (action === 'add') {
      _columnsShow.push(changedColumn);
    } else if (action === 'remove') {
      _columnsShow = _columnsShow.filter(function (col) {
        return col !== changedColumn;
      });
    }

    setColumnsShow(_columnsShow);
  }, [columnsShow]);
  var scrollToTop = (0, _react.useCallback)(function () {
    window.scrollTo(0, 0); // if (dataTableElement && dataTableElement.current) {
    //   window.scrollTo(0, dataTableElement.current.tableRef.offsetParent.offsetTop);
    // }
  }, []);
  var onChangeRowsPerPage = (0, _react.useCallback)(function () {
    return function (rows) {
      setRowsPerPage(rows);
      scrollToTop();
    };
  }, [scrollToTop]);

  var _onValidate = (0, _react.useCallback)(function () {
    // Note 1: the content on-screen, in-memory does NOT include
    // the headers. Since this component has no awareness of 
    // specific resource requirements, the header must be added
    // as first row by the app itself.
    // Note 2: the content on-screen, in-memory contains both
    // source and target data. The target data must be teased
    // out. A new array of rows (target rows) will be created 
    // and this is the data that will be passed to the validation
    // closure passed to this component.
    var targetRows = [];

    if (state && state.data) {
      var rows = state.data;

      for (var i = 0; i < rows.length; i++) {
        var row = rows[i];
        var targetRow = []; // now each cell has both source and target values, delimited by tab

        for (var j = 0; j < row.length; j++) {
          var values = row[j].split("\t");
          var targetValue = values[1];
          targetValue = targetValue.replaceAll('\\[', '[').replaceAll('\\]', ']');
          targetRow.push(targetValue);
        }

        targetRows.push(targetRow);
      }
    }

    onValidate && onValidate(targetRows);
  }, [onValidate, state]);

  var customToolbar = (0, _react.useCallback)(function () {
    return /*#__PURE__*/_react["default"].createElement(_.Toolbar, {
      preview: preview,
      onPreview: togglePreview,
      changed: markdownState.isChanged,
      onSave: _onSave,
      onValidate: onValidate ? _onValidate : undefined
    });
  }, [_onSave, markdownState.isChanged, preview, togglePreview, _onValidate, onValidate]);

  var _options = (0, _react.useMemo)(function () {
    return _objectSpread({
      responsive: 'scrollFullHeight',
      fixedHeaderOptions: fixedHeaderOptions,
      resizableColumns: false,
      selectableRows: 'none',
      rowHover: false,
      rowsPerPage: rowsPerPage,
      rowsPerPageOptions: rowsPerPageOptions,
      onChangeRowsPerPage: onChangeRowsPerPage,
      onColumnViewChange: onColumnViewChange,
      onChangePage: scrollToTop,
      download: false,
      print: false,
      customToolbar: customToolbar
    }, options);
  }, [customToolbar, onChangeRowsPerPage, onColumnViewChange, options, rowsPerPage, scrollToTop]);

  var _data = (0, _react.useMemo)(function () {
    return (0, _helpers.getData)({
      data: data,
      columnNames: columnNames,
      rowHeader: rowHeader
    });
  }, [columnNames, data, rowHeader]);

  var columns = (0, _react.useMemo)(function () {
    return (0, _helpers.getColumns)({
      columnNames: columnNames,
      columnsFilter: columnsFilter,
      columnsFilterOptions: columnsFilterOptions,
      columnsShow: columnsShow,
      delimiters: delimiters,
      rowHeader: rowHeader,
      generateRowId: generateRowId,
      cellEdit: cellEdit,
      preview: preview
    });
  }, [cellEdit, columnNames, columnsFilter, columnsFilterOptions, columnsShow, delimiters, generateRowId, preview, rowHeader]);
  return /*#__PURE__*/_react["default"].createElement(_styles.MuiThemeProvider, {
    theme: _muiTheme.getMuiTheme
  }, /*#__PURE__*/_react["default"].createElement(DatatableMemo, _extends({
    dataTableElement: dataTableElement,
    columns: columns,
    data: _data,
    options: _options
  }, props)));
}

DataTable.propTypes = {
  /** Original DataTable raw string or file contents */
  sourceFile: _propTypes["default"].string.isRequired,

  /** Translated DataTable raw string or file contents */
  targetFile: _propTypes["default"].string.isRequired,

  /** The callback to save the edited targetFile */
  onSave: _propTypes["default"].func.isRequired,

  /** The callback to validate the edited targetFile */
  onValidate: _propTypes["default"].func,

  /** The delimiters for converting the file into rows/columns */
  delimiters: _propTypes["default"].shape({
    /** Delimiters to convert a files into rows "\n" */
    row: _propTypes["default"].string.isRequired,

    /** Delimiters to convert a row into cells "\t" */
    cell: _propTypes["default"].string.isRequired
  }).isRequired,

  /** Configuration options */
  config: _propTypes["default"].shape({
    /** Combined Column Indices to correlate original and translated rows  */
    compositeKeyIndices: _propTypes["default"].arrayOf(_propTypes["default"].number).isRequired,

    /** Filterable columns */
    columnsFilter: _propTypes["default"].arrayOf(_propTypes["default"].string).isRequired,

    /** Columns shown */
    columnsShowDefault: _propTypes["default"].arrayOf(_propTypes["default"].string).isRequired,

    /** Function to render the row header.
     * `rowHeader(rowData) => React Component`
    */
    rowHeader: _propTypes["default"].func
  }).isRequired,

  /** Options to override or pass through to MUIDataTables.
   *  https://github.com/gregnb/mui-datatables
   */
  options: _propTypes["default"].object
};
DataTable.defaultProps = {
  delimiters: {
    row: '\n',
    cell: '\t'
  }
};
/* code graveyard

  const _onValidate = useCallback(() => {
    // NOTE! the content on-screen, in-memory does NOT include
    // the headers. So the initial value of tsvRows will be the headers.
    let tsvRows = "Book\tChapter\tVerse\tID\tSupportReference\tOrigQuote\tOccurrence\tGLQuote\tOccurrenceNote\n";
    if (state && state.data) {
      let rows = state.data;
      for (let i = 0; i < rows.length; i++) {
        let _row = rows[i];
        let _tsvRow = "";
        // now each cell has both source and target values, delimited by tab
        for (let j = 0; j < _row.length; j++) {
          let values = _row[j].split("\t");
          let targetValue = values[1];
          targetValue = targetValue.replaceAll('\\[', '[').replaceAll('\\]', ']');
          _tsvRow = _tsvRow + targetValue + "\t";
        }
        // add new row and a newline at end of row
        _tsvRow = _tsvRow.trim('\t');
        // check if row has content on target side
        if ( _tsvRow === '' ) continue;
        tsvRows = tsvRows + _tsvRow + "\n";
      }
    }
    onValidate && onValidate(tsvRows);
  }, [onValidate, state]);

*/
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9jb21wb25lbnRzL2RhdGF0YWJsZS9EYXRhVGFibGUuanMiXSwibmFtZXMiOlsiZml4ZWRIZWFkZXJPcHRpb25zIiwieEF4aXMiLCJ5QXhpcyIsInJvd3NQZXJQYWdlT3B0aW9ucyIsIkRhdGFUYWJsZVdyYXBwZXIiLCJwcm9wcyIsIkRhdGF0YWJsZU1lbW8iLCJSZWFjdCIsIm1lbW8iLCJjb2x1bW5zIiwib3B0aW9ucyIsImRhdGEiLCJkYXRhVGFibGVFbGVtZW50IiwicHJldlByb3BzIiwibmV4dFByb3BzIiwiZXF1YWwiLCJEYXRhVGFibGUiLCJkZWxpbWl0ZXJzIiwiY29uZmlnIiwib25TYXZlIiwib25FZGl0Iiwib25WYWxpZGF0ZSIsIm9uQ29udGVudElzRGlydHkiLCJzb3VyY2VGaWxlIiwiX2dlbmVyYXRlUm93SWQiLCJnZW5lcmF0ZVJvd0lkIiwiY29sdW1uc0ZpbHRlciIsImNvbHVtbnNTaG93RGVmYXVsdCIsInJvd0hlYWRlciIsInJvd3NQZXJQYWdlIiwic2V0Um93c1BlclBhZ2UiLCJwcmV2aWV3Iiwic2V0UHJldmlldyIsImNvbHVtbnNTaG93Iiwic2V0Q29sdW1uc1Nob3ciLCJpc0F1dG9TYXZlQ2hhbmdlZCIsInNldElzQXV0b1NhdmVDaGFuZ2VkIiwiRGF0YVRhYmxlQ29udGV4dCIsInN0YXRlIiwiYWN0aW9ucyIsImNvbHVtbk5hbWVzIiwiY29sdW1uc0ZpbHRlck9wdGlvbnMiLCJfY2VsbEVkaXQiLCJjZWxsRWRpdCIsIk1hcmtkb3duQ29udGV4dCIsIm1hcmtkb3duU3RhdGUiLCJtYXJrZG93bkFjdGlvbnMiLCJwYXJtcyIsImNoYW5nZVBhZ2UiLCJwYWdlIiwiY3VycmVudCIsImlzQ2hhbmdlZCIsInRvZ2dsZVByZXZpZXciLCJfb25TYXZlIiwic2F2ZWRGaWxlIiwidGFyZ2V0RmlsZVNhdmUiLCJzZXRJc0NoYW5nZWQiLCJjb25zb2xlIiwibG9nIiwib25Db2x1bW5WaWV3Q2hhbmdlIiwiY2hhbmdlZENvbHVtbiIsImFjdGlvbiIsIl9jb2x1bW5zU2hvdyIsInB1c2giLCJmaWx0ZXIiLCJjb2wiLCJzY3JvbGxUb1RvcCIsIndpbmRvdyIsInNjcm9sbFRvIiwib25DaGFuZ2VSb3dzUGVyUGFnZSIsInJvd3MiLCJfb25WYWxpZGF0ZSIsInRhcmdldFJvd3MiLCJpIiwibGVuZ3RoIiwicm93IiwidGFyZ2V0Um93IiwiaiIsInZhbHVlcyIsInNwbGl0IiwidGFyZ2V0VmFsdWUiLCJyZXBsYWNlQWxsIiwiY3VzdG9tVG9vbGJhciIsInVuZGVmaW5lZCIsIl9vcHRpb25zIiwicmVzcG9uc2l2ZSIsInJlc2l6YWJsZUNvbHVtbnMiLCJzZWxlY3RhYmxlUm93cyIsInJvd0hvdmVyIiwib25DaGFuZ2VQYWdlIiwiZG93bmxvYWQiLCJwcmludCIsIl9kYXRhIiwiZ2V0TXVpVGhlbWUiLCJwcm9wVHlwZXMiLCJQcm9wVHlwZXMiLCJzdHJpbmciLCJpc1JlcXVpcmVkIiwidGFyZ2V0RmlsZSIsImZ1bmMiLCJzaGFwZSIsImNlbGwiLCJjb21wb3NpdGVLZXlJbmRpY2VzIiwiYXJyYXlPZiIsIm51bWJlciIsIm9iamVjdCIsImRlZmF1bHRQcm9wcyJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUE7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBRUE7O0FBR0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBRUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFFQSxJQUFNQSxrQkFBa0IsR0FBRztBQUFFQyxFQUFBQSxLQUFLLEVBQUUsS0FBVDtBQUFnQkMsRUFBQUEsS0FBSyxFQUFFO0FBQXZCLENBQTNCO0FBQ0EsSUFBTUMsa0JBQWtCLEdBQUcsQ0FBQyxFQUFELEVBQUssRUFBTCxFQUFTLEdBQVQsQ0FBM0I7O0FBRWUsU0FBU0MsZ0JBQVQsQ0FBMEJDLEtBQTFCLEVBQWlDO0FBQzlDLHNCQUNFLGdDQUFDLDZDQUFELHFCQUNFLGdDQUFDLG1DQUFELEVBQThCQSxLQUE5QixlQUNFLGdDQUFDLFNBQUQs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RjtBQUNBO0FBQ0V2RixFQUFBQSxPQUFPLEVBQUVxRixzQkFBVVU7QUFoQ0MsQ0FBdEI7QUFtQ0F6RixTQUFTLENBQUMwRixZQUFWLEdBQXlCO0FBQ3ZCekYsRUFBQUEsVUFBVSxFQUFFO0FBQ1YwRCxJQUFBQSxHQUFHLEVBQUUsSUFESztBQUVWMEIsSUFBQUEsSUFBSSxFQUFFO0FBRkk7QUFEVyxDQUF6QjtBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBUb29sYmFyIH0gZnJvbSAnLi4vLi4nO1xyXG5pbXBvcnQgeyBnZXRNdWlUaGVtZSB9IGZyb20gJy4vbXVpVGhlbWUnO1xyXG5pbXBvcnQgeyBEYXRhVGFibGVDb250ZXh0LCBEYXRhVGFibGVDb250ZXh0UHJvdmlkZXIgfSBmcm9tICcuL0RhdGFUYWJsZS5jb250ZXh0JztcclxuaW1wb3J0IHsgZ2V0Q29sdW1ucywgZ2V0RGF0YSB9IGZyb20gJy4vaGVscGVycyc7XHJcblxyXG5pbXBvcnQgUmVhY3QsIHtcclxuICB1c2VTdGF0ZSwgdXNlQ29udGV4dCwgdXNlUmVmLCB1c2VDYWxsYmFjaywgdXNlTWVtbywgdXNlRWZmZWN0LFxyXG59IGZyb20gJ3JlYWN0JztcclxuaW1wb3J0IGlzRXF1YWwgZnJvbSAnbG9kYXNoLmlzZXF1YWwnO1xyXG5pbXBvcnQgdXNlRGVlcEVmZmVjdCBmcm9tICd1c2UtZGVlcC1jb21wYXJlLWVmZmVjdCc7XHJcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XHJcbmltcG9ydCBNVUlEYXRhVGFibGUgZnJvbSAnbXVpLWRhdGF0YWJsZXMnO1xyXG5pbXBvcnQgeyBNdWlUaGVtZVByb3ZpZGVyIH0gZnJvbSAnQG1hdGVyaWFsLXVpL2NvcmUvc3R5bGVzJztcclxuXHJcbmltcG9ydCB7IE1hcmtkb3duQ29udGV4dCwgTWFya2Rvd25Db250ZXh0UHJvdmlkZXIgfSBmcm9tICdtYXJrZG93bi10cmFuc2xhdGFibGUnO1xyXG5cclxuY29uc3QgZml4ZWRIZWFkZXJPcHRpb25zID0geyB4QXhpczogZmFsc2UsIHlBeGlzOiBmYWxzZSB9O1xyXG5jb25zdCByb3dzUGVyUGFnZU9wdGlvbnMgPSBbMjUsIDUwLCAxMDBdO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gRGF0YVRhYmxlV3JhcHBlcihwcm9wcykge1xyXG4gIHJldHVybiAoXHJcbiAgICA8TWFya2Rvd25Db250ZXh0UHJvdmlkZXI+XHJcbiAgICAgIDxEYXRhVGFibGVDb250ZXh0UHJvdmlkZXIgey4uLnByb3BzfT5cclxuICAgICAgICA8RGF0YVRhYmxlIHsuLi5wcm9wc30gLz5cclxuICAgICAgPC9EYXRhVGFibGVDb250ZXh0UHJvdmlkZXI+XHJcbiAgICA8L01hcmtkb3duQ29udGV4dFByb3ZpZGVyPlxyXG4gICk7XHJcbn1cclxuXHJcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC9kaXNwbGF5LW5hbWVcclxuY29uc3QgRGF0YXRhYmxlTWVtbyA9IFJlYWN0Lm1lbW8oZnVuY3Rpb24gKHtcclxuICBjb2x1bW5zLCBvcHRpb25zLCBkYXRhLCBkYXRhVGFibGVFbGVtZW50LFxyXG59KSB7XHJcbiAgcmV0dXJuICg8TVVJRGF0YVRhYmxlIHJlZj17ZGF0YVRhYmxlRWxlbWVudH0gY29sdW1ucz17Y29sdW1uc30gb3B0aW9ucz17b3B0aW9uc30gZGF0YT17ZGF0YX0gLz4pO1xyXG59LCAocHJldlByb3BzLCBuZXh0UHJvcHMpID0+IHtcclxuICBjb25zdCBlcXVhbCA9IGlzRXF1YWwocHJldlByb3BzLmRhdGEsIG5leHRQcm9wcy5kYXRhKSAmJlxyXG4gICAgaXNFcXVhbChwcmV2UHJvcHMuY29sdW1ucywgbmV4dFByb3BzLmNvbHVtbnMpICYmXHJcbiAgICBpc0VxdWFsKHByZXZQcm9wcy5vcHRpb25zLCBuZXh0UHJvcHMub3B0aW9ucyk7XHJcbiAgcmV0dXJuIGVxdWFsO1xyXG59KTtcclxuXHJcbmZ1bmN0aW9uIERhdGFUYWJsZSh7XHJcbiAgb3B0aW9ucyA9IHt9LFxyXG4gIGRlbGltaXRlcnMsXHJcbiAgY29uZmlnLFxyXG4gIG9uU2F2ZSxcclxuICBvbkVkaXQsXHJcbiAgb25WYWxpZGF0ZSxcclxuICBvbkNvbnRlbnRJc0RpcnR5LFxyXG4gIHNvdXJjZUZpbGUsXHJcbiAgZ2VuZXJhdGVSb3dJZDogX2dlbmVyYXRlUm93SWQsXHJcbiAgLi4ucHJvcHNcclxufSkge1xyXG4gIGNvbnN0IHtcclxuICAgIGNvbHVtbnNGaWx0ZXIsXHJcbiAgICBjb2x1bW5zU2hvd0RlZmF1bHQsXHJcbiAgICByb3dIZWFkZXIsXHJcbiAgfSA9IGNvbmZpZztcclxuICBjb25zdCBkYXRhVGFibGVFbGVtZW50ID0gdXNlUmVmKCk7XHJcbiAgY29uc3QgW3Jvd3NQZXJQYWdlLCBzZXRSb3dzUGVyUGFnZV0gPSB1c2VTdGF0ZShvcHRpb25zLnJvd3NQZXJQYWdlIHx8IDI1KTtcclxuICBjb25zdCBbcHJldmlldywgc2V0UHJldmlld10gPSB1c2VTdGF0ZSh0cnVlKTtcclxuICBjb25zdCBbY29sdW1uc1Nob3csIHNldENvbHVtbnNTaG93XSA9IHVzZVN0YXRlKGNvbHVtbnNTaG93RGVmYXVsdCk7XHJcbiAgY29uc3QgW2lzQXV0b1NhdmVDaGFuZ2VkLCBzZXRJc0F1dG9TYXZlQ2hhbmdlZF0gPSB1c2VTdGF0ZShmYWxzZSk7XHJcblxyXG4gIGNvbnN0IHsgc3RhdGUsIGFjdGlvbnMgfSA9IHVzZUNvbnRleHQoRGF0YVRhYmxlQ29udGV4dCk7XHJcbiAgY29uc3Qge1xyXG4gICAgY29sdW1uTmFtZXMsIGRhdGEsIGNvbHVtbnNGaWx0ZXJPcHRpb25zLFxyXG4gIH0gPSBzdGF0ZTtcclxuICBjb25zdCB7IGNlbGxFZGl0OiBfY2VsbEVkaXQgfSA9IGFjdGlvbnM7XHJcblxyXG4gIGNvbnN0IHsgc3RhdGU6IG1hcmtkb3duU3RhdGUsIGFjdGlvbnM6IG1hcmtkb3duQWN0aW9ucyB9ID0gdXNlQ29udGV4dChNYXJrZG93bkNvbnRleHQpIHx8IHt9O1xyXG5cclxuICBjb25zdCBnZW5lcmF0ZVJvd0lkID0gdXNlQ2FsbGJhY2soX2dlbmVyYXRlUm93SWQsIFtdKTtcclxuXHJcbiAgY29uc3QgY2VsbEVkaXQgPSB1c2VDYWxsYmFjayhwYXJtcyA9PiB7XHJcbiAgICBfY2VsbEVkaXQocGFybXMpO1xyXG4gICAgc2V0SXNBdXRvU2F2ZUNoYW5nZWQodHJ1ZSk7XHJcbiAgfSwgW19jZWxsRWRpdCwgc2V0SXNBdXRvU2F2ZUNoYW5nZWRdKTtcclxuXHJcbiAgY29uc3QgY2hhbmdlUGFnZSA9IHVzZUNhbGxiYWNrKGZ1bmN0aW9uIChwYWdlKSB7XHJcbiAgICBkYXRhVGFibGVFbGVtZW50LmN1cnJlbnQuY2hhbmdlUGFnZShwYWdlKTtcclxuICB9LCBbZGF0YVRhYmxlRWxlbWVudF0pO1xyXG5cclxuICB1c2VEZWVwRWZmZWN0KCgpID0+IHtcclxuICAgIGNoYW5nZVBhZ2UoMCk7XHJcbiAgfSwgW2NoYW5nZVBhZ2VdKTtcclxuICBcclxuICAvLyBQdXNoIFwiaXNDaGFuZ2VkLFwiIHNvIGFwcCBrbm93cyB3aGVuIFNBVkUgYnV0dG9uIGlzIGVuYWJsZWQuXHJcbiAgLy8gU2VlIGFsc28gVHJhbnNsYXRhYmxlIGluIG1hcmtkb3duLXRyYW5zbGF0YWJsZS5cclxuICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgaWYgKG9uQ29udGVudElzRGlydHkpIHtcclxuICAgICAgb25Db250ZW50SXNEaXJ0eShtYXJrZG93blN0YXRlLmlzQ2hhbmdlZCk7XHJcbiAgICB9XHJcbiAgfSwgW21hcmtkb3duU3RhdGUuaXNDaGFuZ2VkLCBvbkNvbnRlbnRJc0RpcnR5XSk7XHJcblxyXG4gIGNvbnN0IHRvZ2dsZVByZXZpZXcgPSB1c2VDYWxsYmFjaygoKSA9PiBzZXRQcmV2aWV3KCFwcmV2aWV3KSwgW3ByZXZpZXddKTtcclxuXHJcbiAgLy8gX29uU2F2ZSBpcyBjYWxsZWQgYnkgVG9vbGJhcjsgY2VsbEVkaXQgaXMgY2FsbGVkIGJ5IERhdGFUYWJsZS5cclxuICAvLyBTdGF0ZSAoY29udGVudHMpIGFyZSBkaWZmZXJlbnQgYXQgdGhlc2UgdHdvIHRpbWVzLiAoY2VsbEVkaXQgbGFncylcclxuICBjb25zdCBfb25TYXZlID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xyXG4gICAgY29uc3Qgc2F2ZWRGaWxlID0gYWN0aW9ucy50YXJnZXRGaWxlU2F2ZSgpO1xyXG4gICAgb25TYXZlKHNhdmVkRmlsZSk7XHJcblxyXG4gICAgaWYgKG1hcmtkb3duQWN0aW9ucyAmJiBtYXJrZG93bkFjdGlvbnMuc2V0SXNDaGFuZ2VkKSB7XHJcbiAgICAgIG1hcmtkb3duQWN0aW9ucy5zZXRJc0NoYW5nZWQoZmFsc2UpO1xyXG4gICAgfVxyXG4gIH0sIFthY3Rpb25zLCBvblNhdmUsIG1hcmtkb3duQWN0aW9uc10pO1xyXG5cclxuICB1c2VEZWVwRWZmZWN0KCgpID0+IHtcclxuICAgIGNvbnNvbGUubG9nKFwidXNlRGVlcEVmZmVjdCBmb3IgaXNBdXRvU2F2ZUNoYW5nZWRcIik7XHJcbiAgICBpZiAob25FZGl0ICYmIGlzQXV0b1NhdmVDaGFuZ2VkKVxyXG4gICAge1xyXG4gICAgICBjb25zdCBzYXZlZEZpbGUgPSBhY3Rpb25zLnRhcmdldEZpbGVTYXZlKCk7XHJcbiAgICAgIG9uRWRpdChzYXZlZEZpbGUpO1xyXG4gICAgICBcclxuICAgICAgc2V0SXNBdXRvU2F2ZUNoYW5nZWQoZmFsc2UpO1xyXG4gICAgICAvLyBpZiAobWFya2Rvd25BY3Rpb25zICYmIG1hcmtkb3duQWN0aW9ucy5zZXRJc0F1dG9TYXZlQ2hhbmdlZCkge1xyXG4gICAgICAvLyAgIG1hcmtkb3duQWN0aW9ucy5zZXRJc0F1dG9TYXZlQ2hhbmdlZChmYWxzZSk7XHJcbiAgICAgIC8vIH1cclxuICAgIH1cclxuICB9LCBbaXNBdXRvU2F2ZUNoYW5nZWQsIG9uRWRpdCwgbWFya2Rvd25BY3Rpb25zLCBhY3Rpb25zXSk7XHJcbiAgXHJcbiAgY29uc3Qgb25Db2x1bW5WaWV3Q2hhbmdlID0gdXNlQ2FsbGJhY2soKGNoYW5nZWRDb2x1bW4sIGFjdGlvbikgPT4ge1xyXG4gICAgbGV0IF9jb2x1bW5zU2hvdyA9IFsuLi5jb2x1bW5zU2hvd107XHJcblxyXG4gICAgaWYgKGFjdGlvbiA9PT0gJ2FkZCcpIHtcclxuICAgICAgX2NvbHVtbnNTaG93LnB1c2goY2hhbmdlZENvbHVtbik7XHJcbiAgICB9IGVsc2UgaWYgKGFjdGlvbiA9PT0gJ3JlbW92ZScpIHtcclxuICAgICAgX2NvbHVtbnNTaG93ID0gX2NvbHVtbnNTaG93LmZpbHRlcihjb2wgPT4gY29sICE9PSBjaGFuZ2VkQ29sdW1uKTtcclxuICAgIH1cclxuICAgIHNldENvbHVtbnNTaG93KF9jb2x1bW5zU2hvdyk7XHJcbiAgfSwgW2NvbHVtbnNTaG93XSk7XHJcblxyXG4gIGNvbnN0IHNjcm9sbFRvVG9wID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xyXG4gICAgd2luZG93LnNjcm9sbFRvKDAsIDApO1xyXG4gICAgLy8gaWYgKGRhdGFUYWJsZUVsZW1lbnQgJiYgZGF0YVRhYmxlRWxlbWVudC5jdXJyZW50KSB7XHJcbiAgICAvLyAgIHdpbmRvdy5zY3JvbGxUbygwLCBkYXRhVGFibGVFbGVtZW50LmN1cnJlbnQudGFibGVSZWYub2Zmc2V0UGFyZW50Lm9mZnNldFRvcCk7XHJcbiAgICAvLyB9XHJcbiAgfSwgW10pO1xyXG5cclxuICBjb25zdCBvbkNoYW5nZVJvd3NQZXJQYWdlID0gdXNlQ2FsbGJhY2soKCkgPT4gKHJvd3MpID0+IHtcclxuICAgIHNldFJvd3NQZXJQYWdlKHJvd3MpO1xyXG4gICAgc2Nyb2xsVG9Ub3AoKTtcclxuICB9LCBbc2Nyb2xsVG9Ub3BdKTtcclxuXHJcbiAgY29uc3QgX29uVmFsaWRhdGUgPSB1c2VDYWxsYmFjaygoKSA9PiB7XHJcbiAgICAvLyBOb3RlIDE6IHRoZSBjb250ZW50IG9uLXNjcmVlbiwgaW4tbWVtb3J5IGRvZXMgTk9UIGluY2x1ZGVcclxuICAgIC8vIHRoZSBoZWFkZXJzLiBTaW5jZSB0aGlzIGNvbXBvbmVudCBoYXMgbm8gYXdhcmVuZXNzIG9mIFxyXG4gICAgLy8gc3BlY2lmaWMgcmVzb3VyY2UgcmVxdWlyZW1lbnRzLCB0aGUgaGVhZGVyIG11c3QgYmUgYWRkZWRcclxuICAgIC8vIGFzIGZpcnN0IHJvdyBieSB0aGUgYXBwIGl0c2VsZi5cclxuXHJcbiAgICAvLyBOb3RlIDI6IHRoZSBjb250ZW50IG9uLXNjcmVlbiwgaW4tbWVtb3J5IGNvbnRhaW5zIGJvdGhcclxuICAgIC8vIHNvdXJjZSBhbmQgdGFyZ2V0IGRhdGEuIFRoZSB0YXJnZXQgZGF0YSBtdXN0IGJlIHRlYXNlZFxyXG4gICAgLy8gb3V0LiBBIG5ldyBhcnJheSBvZiByb3dzICh0YXJnZXQgcm93cykgd2lsbCBiZSBjcmVhdGVkIFxyXG4gICAgLy8gYW5kIHRoaXMgaXMgdGhlIGRhdGEgdGhhdCB3aWxsIGJlIHBhc3NlZCB0byB0aGUgdmFsaWRhdGlvblxyXG4gICAgLy8gY2xvc3VyZSBwYXNzZWQgdG8gdGhpcyBjb21wb25lbnQuXHJcbiAgICBsZXQgdGFyZ2V0Um93cyA9IFtdO1xyXG4gICAgaWYgKHN0YXRlICYmIHN0YXRlLmRhdGEpIHtcclxuICAgICAgbGV0IHJvd3MgPSBzdGF0ZS5kYXRhO1xyXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJvd3MubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBsZXQgcm93ID0gcm93c1tpXTtcclxuICAgICAgICBsZXQgdGFyZ2V0Um93ID0gW107XHJcbiAgICAgICAgLy8gbm93IGVhY2ggY2VsbCBoYXMgYm90aCBzb3VyY2UgYW5kIHRhcmdldCB2YWx1ZXMsIGRlbGltaXRlZCBieSB0YWJcclxuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHJvdy5sZW5ndGg7IGorKykge1xyXG4gICAgICAgICAgbGV0IHZhbHVlcyA9IHJvd1tqXS5zcGxpdChcIlxcdFwiKTtcclxuICAgICAgICAgIGxldCB0YXJnZXRWYWx1ZSA9IHZhbHVlc1sxXTtcclxuICAgICAgICAgIHRhcmdldFZhbHVlID0gdGFyZ2V0VmFsdWUucmVwbGFjZUFsbCgnXFxcXFsnLCAnWycpLnJlcGxhY2VBbGwoJ1xcXFxdJywgJ10nKTtcclxuICAgICAgICAgIHRhcmdldFJvdy5wdXNoKHRhcmdldFZhbHVlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGFyZ2V0Um93cy5wdXNoKHRhcmdldFJvdyk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIG9uVmFsaWRhdGUgJiYgb25WYWxpZGF0ZSh0YXJnZXRSb3dzKTtcclxuICB9LCBbb25WYWxpZGF0ZSwgc3RhdGVdKTtcclxuXHJcbiAgY29uc3QgY3VzdG9tVG9vbGJhciA9IHVzZUNhbGxiYWNrKCgpID0+XHJcbiAgICA8VG9vbGJhciBwcmV2aWV3PXtwcmV2aWV3fSBvblByZXZpZXc9e3RvZ2dsZVByZXZpZXd9IGNoYW5nZWQ9e21hcmtkb3duU3RhdGUuaXNDaGFuZ2VkfSBvblNhdmU9e19vblNhdmV9IG9uVmFsaWRhdGU9e29uVmFsaWRhdGUgPyBfb25WYWxpZGF0ZSA6IHVuZGVmaW5lZH0gLz4sXHJcbiAgICBbX29uU2F2ZSwgbWFya2Rvd25TdGF0ZS5pc0NoYW5nZWQsIHByZXZpZXcsIHRvZ2dsZVByZXZpZXcsIF9vblZhbGlkYXRlLCBvblZhbGlkYXRlXVxyXG4gICk7XHJcblxyXG4gIGNvbnN0IF9vcHRpb25zID0gdXNlTWVtbygoKSA9PiAoe1xyXG4gICAgcmVzcG9uc2l2ZTogJ3Njcm9sbEZ1bGxIZWlnaHQnLFxyXG4gICAgZml4ZWRIZWFkZXJPcHRpb25zLFxyXG4gICAgcmVzaXphYmxlQ29sdW1uczogZmFsc2UsXHJcbiAgICBzZWxlY3RhYmxlUm93czogJ25vbmUnLFxyXG4gICAgcm93SG92ZXI6IGZhbHNlLFxyXG4gICAgcm93c1BlclBhZ2UsXHJcbiAgICByb3dzUGVyUGFnZU9wdGlvbnMsXHJcbiAgICBvbkNoYW5nZVJvd3NQZXJQYWdlLFxyXG4gICAgb25Db2x1bW5WaWV3Q2hhbmdlLFxyXG4gICAgb25DaGFuZ2VQYWdlOiBzY3JvbGxUb1RvcCxcclxuICAgIGRvd25sb2FkOiBmYWxzZSxcclxuICAgIHByaW50OiBmYWxzZSxcclxuICAgIGN1c3RvbVRvb2xiYXIsXHJcbiAgICAuLi5vcHRpb25zLFxyXG4gIH0pLCBbY3VzdG9tVG9vbGJhciwgb25DaGFuZ2VSb3dzUGVyUGFnZSwgb25Db2x1bW5WaWV3Q2hhbmdlLCBvcHRpb25zLCByb3dzUGVyUGFnZSwgc2Nyb2xsVG9Ub3BdKTtcclxuXHJcbiAgY29uc3QgX2RhdGEgPSB1c2VNZW1vKCgpID0+IGdldERhdGEoe1xyXG4gICAgZGF0YSwgY29sdW1uTmFtZXMsIHJvd0hlYWRlcixcclxuICB9KSwgW2NvbHVtbk5hbWVzLCBkYXRhLCByb3dIZWFkZXJdKTtcclxuXHJcbiAgY29uc3QgY29sdW1ucyA9IHVzZU1lbW8oKCkgPT4gZ2V0Q29sdW1ucyh7XHJcbiAgICBjb2x1bW5OYW1lcywgY29sdW1uc0ZpbHRlciwgY29sdW1uc0ZpbHRlck9wdGlvbnMsXHJcbiAgICBjb2x1bW5zU2hvdywgZGVsaW1pdGVycywgcm93SGVhZGVyLFxyXG4gICAgZ2VuZXJhdGVSb3dJZCwgY2VsbEVkaXQsIHByZXZpZXcsXHJcbiAgfSksIFtjZWxsRWRpdCwgY29sdW1uTmFtZXMsIGNvbHVtbnNGaWx0ZXIsIGNvbHVtbnNGaWx0ZXJPcHRpb25zLCBjb2x1bW5zU2hvdywgZGVsaW1pdGVycywgZ2VuZXJhdGVSb3dJZCwgcHJldmlldywgcm93SGVhZGVyXSk7XHJcblxyXG4gIHJldHVybiAoXHJcbiAgICA8TXVpVGhlbWVQcm92aWRlciB0aGVtZT17Z2V0TXVpVGhlbWV9PlxyXG4gICAgICA8RGF0YXRhYmxlTWVtbyBkYXRhVGFibGVFbGVtZW50PXtkYXRhVGFibGVFbGVtZW50fSBjb2x1bW5zPXtjb2x1bW5zfSBkYXRhPXtfZGF0YX0gb3B0aW9ucz17X29wdGlvbnN9IHsuLi5wcm9wc30gLz5cclxuICAgIDwvTXVpVGhlbWVQcm92aWRlcj5cclxuICApO1xyXG59XHJcblxyXG5EYXRhVGFibGUucHJvcFR5cGVzID0ge1xyXG4gIC8qKiBPcmlnaW5hbCBEYXRhVGFibGUgcmF3IHN0cmluZyBvciBmaWxlIGNvbnRlbnRzICovXHJcbiAgc291cmNlRmlsZTogUHJvcFR5cGVzLnN0cmluZy5pc1JlcXVpcmVkLFxyXG4gIC8qKiBUcmFuc2xhdGVkIERhdGFUYWJsZSByYXcgc3RyaW5nIG9yIGZpbGUgY29udGVudHMgKi9cclxuICB0YXJnZXRGaWxlOiBQcm9wVHlwZXMuc3RyaW5nLmlzUmVxdWlyZWQsXHJcbiAgLyoqIFRoZSBjYWxsYmFjayB0byBzYXZlIHRoZSBlZGl0ZWQgdGFyZ2V0RmlsZSAqL1xyXG4gIG9uU2F2ZTogUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZCxcclxuICAvKiogVGhlIGNhbGxiYWNrIHRvIHZhbGlkYXRlIHRoZSBlZGl0ZWQgdGFyZ2V0RmlsZSAqL1xyXG4gIG9uVmFsaWRhdGU6IFByb3BUeXBlcy5mdW5jLFxyXG4gIC8qKiBUaGUgZGVsaW1pdGVycyBmb3IgY29udmVydGluZyB0aGUgZmlsZSBpbnRvIHJvd3MvY29sdW1ucyAqL1xyXG4gIGRlbGltaXRlcnM6IFByb3BUeXBlcy5zaGFwZSh7XHJcbiAgICAvKiogRGVsaW1pdGVycyB0byBjb252ZXJ0IGEgZmlsZXMgaW50byByb3dzIFwiXFxuXCIgKi9cclxuICAgIHJvdzogUHJvcFR5cGVzLnN0cmluZy5pc1JlcXVpcmVkLFxyXG4gICAgLyoqIERlbGltaXRlcnMgdG8gY29udmVydCBhIHJvdyBpbnRvIGNlbGxzIFwiXFx0XCIgKi9cclxuICAgIGNlbGw6IFByb3BUeXBlcy5zdHJpbmcuaXNSZXF1aXJlZCxcclxuICB9KS5pc1JlcXVpcmVkLFxyXG4gIC8qKiBDb25maWd1cmF0aW9uIG9wdGlvbnMgKi9cclxuICBjb25maWc6IFByb3BUeXBlcy5zaGFwZSh7XHJcbiAgICAvKiogQ29tYmluZWQgQ29sdW1uIEluZGljZXMgdG8gY29ycmVsYXRlIG9yaWdpbmFsIGFuZCB0cmFuc2xhdGVkIHJvd3MgICovXHJcbiAgICBjb21wb3NpdGVLZXlJbmRpY2VzOiBQcm9wVHlwZXMuYXJyYXlPZihQcm9wVHlwZXMubnVtYmVyKS5pc1JlcXVpcmVkLFxyXG4gICAgLyoqIEZpbHRlcmFibGUgY29sdW1ucyAqL1xyXG4gICAgY29sdW1uc0ZpbHRlcjogUHJvcFR5cGVzLmFycmF5T2YoUHJvcFR5cGVzLnN0cmluZykuaXNSZXF1aXJlZCxcclxuICAgIC8qKiBDb2x1bW5zIHNob3duICovXHJcbiAgICBjb2x1bW5zU2hvd0RlZmF1bHQ6IFByb3BUeXBlcy5hcnJheU9mKFByb3BUeXBlcy5zdHJpbmcpLmlzUmVxdWlyZWQsXHJcbiAgICAvKiogRnVuY3Rpb24gdG8gcmVuZGVyIHRoZSByb3cgaGVhZGVyLlxyXG4gICAgICogYHJvd0hlYWRlcihyb3dEYXRhKSA9PiBSZWFjdCBDb21wb25lbnRgXHJcbiAgICAqL1xyXG4gICAgcm93SGVhZGVyOiBQcm9wVHlwZXMuZnVuYyxcclxuICB9KS5pc1JlcXVpcmVkLFxyXG4gIC8qKiBPcHRpb25zIHRvIG92ZXJyaWRlIG9yIHBhc3MgdGhyb3VnaCB0byBNVUlEYXRhVGFibGVzLlxyXG4gICAqICBodHRwczovL2dpdGh1Yi5jb20vZ3JlZ25iL211aS1kYXRhdGFibGVzXHJcbiAgICovXHJcbiAgb3B0aW9uczogUHJvcFR5cGVzLm9iamVjdCxcclxufTtcclxuXHJcbkRhdGFUYWJsZS5kZWZhdWx0UHJvcHMgPSB7XHJcbiAgZGVsaW1pdGVyczoge1xyXG4gICAgcm93OiAnXFxuJyxcclxuICAgIGNlbGw6ICdcXHQnLFxyXG4gIH0sXHJcbn07XHJcblxyXG5cclxuLyogY29kZSBncmF2ZXlhcmRcclxuXHJcbiAgY29uc3QgX29uVmFsaWRhdGUgPSB1c2VDYWxsYmFjaygoKSA9PiB7XHJcbiAgICAvLyBOT1RFISB0aGUgY29udGVudCBvbi1zY3JlZW4sIGluLW1lbW9yeSBkb2VzIE5PVCBpbmNsdWRlXHJcbiAgICAvLyB0aGUgaGVhZGVycy4gU28gdGhlIGluaXRpYWwgdmFsdWUgb2YgdHN2Um93cyB3aWxsIGJlIHRoZSBoZWFkZXJzLlxyXG4gICAgbGV0IHRzdlJvd3MgPSBcIkJvb2tcXHRDaGFwdGVyXFx0VmVyc2VcXHRJRFxcdFN1cHBvcnRSZWZlcmVuY2VcXHRPcmlnUXVvdGVcXHRPY2N1cnJlbmNlXFx0R0xRdW90ZVxcdE9jY3VycmVuY2VOb3RlXFxuXCI7XHJcbiAgICBpZiAoc3RhdGUgJiYgc3RhdGUuZGF0YSkge1xyXG4gICAgICBsZXQgcm93cyA9IHN0YXRlLmRhdGE7XHJcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcm93cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGxldCBfcm93ID0gcm93c1tpXTtcclxuICAgICAgICBsZXQgX3RzdlJvdyA9IFwiXCI7XHJcbiAgICAgICAgLy8gbm93IGVhY2ggY2VsbCBoYXMgYm90aCBzb3VyY2UgYW5kIHRhcmdldCB2YWx1ZXMsIGRlbGltaXRlZCBieSB0YWJcclxuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IF9yb3cubGVuZ3RoOyBqKyspIHtcclxuICAgICAgICAgIGxldCB2YWx1ZXMgPSBfcm93W2pdLnNwbGl0KFwiXFx0XCIpO1xyXG4gICAgICAgICAgbGV0IHRhcmdldFZhbHVlID0gdmFsdWVzWzFdO1xyXG4gICAgICAgICAgdGFyZ2V0VmFsdWUgPSB0YXJnZXRWYWx1ZS5yZXBsYWNlQWxsKCdcXFxcWycsICdbJykucmVwbGFjZUFsbCgnXFxcXF0nLCAnXScpO1xyXG4gICAgICAgICAgX3RzdlJvdyA9IF90c3ZSb3cgKyB0YXJnZXRWYWx1ZSArIFwiXFx0XCI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGFkZCBuZXcgcm93IGFuZCBhIG5ld2xpbmUgYXQgZW5kIG9mIHJvd1xyXG4gICAgICAgIF90c3ZSb3cgPSBfdHN2Um93LnRyaW0oJ1xcdCcpO1xyXG4gICAgICAgIC8vIGNoZWNrIGlmIHJvdyBoYXMgY29udGVudCBvbiB0YXJnZXQgc2lkZVxyXG4gICAgICAgIGlmICggX3RzdlJvdyA9PT0gJycgKSBjb250aW51ZTtcclxuICAgICAgICB0c3ZSb3dzID0gdHN2Um93cyArIF90c3ZSb3cgKyBcIlxcblwiO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBvblZhbGlkYXRlICYmIG9uVmFsaWRhdGUodHN2Um93cyk7XHJcbiAgfSwgW29uVmFsaWRhdGUsIHN0YXRlXSk7XHJcblxyXG4qLyJdfQ==