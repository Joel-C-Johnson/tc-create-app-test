"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DataTableContextProvider = DataTableContextProvider;
exports.DataTableContext = void 0;

var _react = _interopRequireWildcard(require("react"));

var _lodash = _interopRequireDefault(require("lodash.isequal"));

var _useDeepCompareEffect = _interopRequireDefault(require("use-deep-compare-effect"));

var _deepFreeze = _interopRequireDefault(require("deep-freeze"));

var _datatable = require("../../core/datatable");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

var DataTableContext = /*#__PURE__*/_react["default"].createContext();

exports.DataTableContext = DataTableContext;

function DataTableContextProvider(_ref) {
  var children = _ref.children,
      sourceFile = _ref.sourceFile,
      targetFile = _ref.targetFile,
      delimiters = _ref.delimiters,
      parser = _ref.parser,
      _ref$config = _ref.config,
      compositeKeyIndices = _ref$config.compositeKeyIndices,
      columnsFilter = _ref$config.columnsFilter;

  var _useState = (0, _react.useState)({}),
      _useState2 = _slicedToArray(_useState, 2),
      data = _useState2[0],
      setData = _useState2[1];

  var rowsReducer = function rowsReducer(rows, action) {
    var _rows;

    var type = action.type,
        value = action.value;
    var rowIndex = value.rowIndex,
        rowData = value.rowData,
        columnIndex = value.columnIndex;

    switch (type) {
      case 'SET_ROWS':
        return (0, _deepFreeze["default"])(value.rows);

      case 'ROW_MOVE_ABOVE':
        _rows = (0, _datatable.rowMoveAbove)({
          rows: rows,
          rowIndex: rowIndex
        });
        return (0, _deepFreeze["default"])(_rows);

      case 'ROW_MOVE_BELOW':
        _rows = (0, _datatable.rowMoveBelow)({
          rows: rows,
          rowIndex: rowIndex
        });
        return (0, _deepFreeze["default"])(_rows);

      case 'ROW_ADD_BELOW':
        _rows = (0, _datatable.rowAddBelow)({
          rows: rows,
          rowIndex: rowIndex,
          rowData: rowData
        });
        return (0, _deepFreeze["default"])(_rows);

      case 'ROW_DELETE':
        _rows = (0, _datatable.rowDelete)({
          rows: rows,
          rowIndex: rowIndex
        });
        return (0, _deepFreeze["default"])(_rows);

      case 'CELL_EDIT':
        _rows = (0, _datatable.cellEdit)({
          rows: rows,
          rowIndex: rowIndex,
          columnIndex: columnIndex,
          value: value.value,
          data: data
        });
        return (0, _deepFreeze["default"])(_rows);

      default:
        throw new Error("Unsupported action type: ".concat(action.type));
    }

    ;
  };

  var _useState3 = (0, _react.useState)({}),
      _useState4 = _slicedToArray(_useState3, 2),
      sourceRows = _useState4[0],
      setSourceRows = _useState4[1];

  var _useReducer = (0, _react.useReducer)(rowsReducer, {}),
      _useReducer2 = _slicedToArray(_useReducer, 2),
      targetRows = _useReducer2[0],
      targetRowsDispatch = _useReducer2[1];

  var setTargetRows = function setTargetRows(rows) {
    return targetRowsDispatch({
      type: 'SET_ROWS',
      value: {
        rows: rows
      }
    });
  };

  var _useState5 = (0, _react.useState)(false),
      _useState6 = _slicedToArray(_useState5, 2),
      changed = _useState6[0],
      setChanged = _useState6[1];

  var _useState7 = (0, _react.useState)({}),
      _useState8 = _slicedToArray(_useState7, 2),
      columnNames = _useState8[0],
      setColumnNames = _useState8[1];

  var _useState9 = (0, _react.useState)([]),
      _useState10 = _slicedToArray(_useState9, 2),
      columnsFilterOptions = _useState10[0],
      setColumnsFilterOptions = _useState10[1]; // populate columnsFilterOptions when ready


  (0, _react.useEffect)(function () {
    if (columnsFilter && columnNames && Object.keys(data).length) {
      var columnIndices = columnsFilter.map(function (columnName) {
        return columnNames.indexOf(columnName);
      });

      var _columnsFilterOptions = (0, _datatable.getColumnsFilterOptions)({
        columnIndices: columnIndices,
        data: data,
        delimiters: delimiters
      });

      if (!(0, _lodash["default"])(_columnsFilterOptions, columnsFilterOptions)) {
        setColumnsFilterOptions(_columnsFilterOptions);
      }
    }
  }, [columnsFilter, columnNames, data, delimiters, columnsFilterOptions]); // parse sourceFile when updated

  (0, _react.useEffect)(function () {
    if (parser && parser.tsvStringToTable) {
      console.log("DataTable.context() using tsv parser for source");

      var _parser$tsvStringToTa = parser.tsvStringToTable(sourceFile),
          rows = _parser$tsvStringToTa.data;

      setSourceRows(rows);
    } else {
      if (delimiters) {
        var _parseDataTable = (0, _datatable.parseDataTable)({
          table: sourceFile,
          delimiters: delimiters
        }),
            _rows2 = _parseDataTable.rows;

        setSourceRows(_rows2);
      }
    }
  }, [sourceFile, delimiters, parser]); // parse targetFile when updated

  (0, _react.useEffect)(function () {
    if (parser && parser.tsvStringToTable) {
      console.log("DataTable.context() using tsv parser for target");

      var _parser$tsvStringToTa2 = parser.tsvStringToTable(targetFile),
          _columnNames = _parser$tsvStringToTa2.header,
          rows = _parser$tsvStringToTa2.data;

      setColumnNames(_columnNames);
      setTargetRows(rows);
      setChanged(false);
    } else if (delimiters) {
      var _parseDataTable2 = (0, _datatable.parseDataTable)({
        table: targetFile,
        delimiters: delimiters
      }),
          _columnNames2 = _parseDataTable2.columnNames,
          _rows3 = _parseDataTable2.rows;

      setColumnNames(_columnNames2);
      setTargetRows(_rows3);
      setChanged(false);
    }
  }, [targetFile, delimiters, parser]); // correlate data by compositeKeyIndices when sourceRows or targetRows updated

  (0, _useDeepCompareEffect["default"])(function () {
    if (Object.keys(sourceRows).length && Object.keys(targetRows).length) {
      var _data = (0, _datatable.correlateData)({
        sourceRows: sourceRows,
        targetRows: targetRows,
        compositeKeyIndices: compositeKeyIndices,
        delimiters: delimiters
      });

      setData(_data);
    }
  }, [sourceRows, targetRows, compositeKeyIndices, delimiters]);
  var actions = (0, _react.useMemo)(function () {
    return {
      rowMoveAbove: function rowMoveAbove(_ref2) {
        var rowIndex = _ref2.rowIndex;
        targetRowsDispatch({
          type: 'ROW_MOVE_ABOVE',
          value: {
            rowIndex: rowIndex
          }
        });
        setChanged(true);
      },
      rowMoveBelow: function rowMoveBelow(_ref3) {
        var rowIndex = _ref3.rowIndex;
        targetRowsDispatch({
          type: 'ROW_MOVE_BELOW',
          value: {
            rowIndex: rowIndex
          }
        });
        setChanged(true);
      },
      rowAddBelow: function rowAddBelow(_ref4) {
        var rowIndex = _ref4.rowIndex,
            rowData = _ref4.rowData;
        targetRowsDispatch({
          type: 'ROW_ADD_BELOW',
          value: {
            rowIndex: rowIndex,
            rowData: rowData
          }
        });
        setChanged(true);
      },
      rowDelete: function rowDelete(_ref5) {
        var rowIndex = _ref5.rowIndex;
        targetRowsDispatch({
          type: 'ROW_DELETE',
          value: {
            rowIndex: rowIndex
          }
        });
        console.log("row deleted");
        setChanged(true);
      },
      cellEdit: function cellEdit(_ref6) {
        var rowIndex = _ref6.rowIndex,
            columnIndex = _ref6.columnIndex,
            value = _ref6.value;
        targetRowsDispatch({
          type: 'CELL_EDIT',
          value: {
            rowIndex: rowIndex,
            columnIndex: columnIndex,
            value: value
          }
        });
        setChanged(true);
      },
      rowGenerate: function rowGenerate(_ref7) {
        var rowIndex = _ref7.rowIndex;
        return (0, _datatable.rowGenerate)({
          rows: targetRows,
          columnNames: columnNames,
          rowIndex: rowIndex
        });
      },
      targetFileSave: function targetFileSave() {
        if (parser && parser.tableToTsvString) {
          // combine header rows and data rows
          var table = [];
          table.push(columnNames);

          for (var i = 0; i < targetRows.length; i++) {
            table.push(targetRows[i]);
          }

          var _parser$tableToTsvStr = parser.tableToTsvString(table),
              _data2 = _parser$tableToTsvStr.data,
              errors = _parser$tableToTsvStr.errors;

          if (errors.length !== 0) {
            throw JSON.stringify(errors, null, 4);
          }

          return _data2;
        } else {
          return (0, _datatable.stringify)({
            columnNames: columnNames,
            rows: targetRows,
            delimiters: delimiters
          });
        }
      },
      setChanged: setChanged
    };
  }, [columnNames, delimiters, targetRows, parser]);
  var value = (0, _react.useMemo)(function () {
    return (0, _deepFreeze["default"])({
      state: {
        columnNames: columnNames,
        data: data,
        changed: changed,
        columnsFilterOptions: columnsFilterOptions
      },
      actions: actions
    });
  }, [actions, changed, columnNames, columnsFilterOptions, data]);

  var component = /*#__PURE__*/_react["default"].createElement(_react["default"].Fragment, null);

  if (columnNames && Object.keys(data).length) {
    component = /*#__PURE__*/_react["default"].createElement(DataTableContext.Provider, {
      value: value
    }, children);
  }

  return component;
}

;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9jb21wb25lbnRzL2RhdGF0YWJsZS9EYXRhVGFibGUuY29udGV4dC5qcyJdLCJuYW1lcyI6WyJEYXRhVGFibGVDb250ZXh0IiwiUmVhY3QiLCJjcmVhdGVDb250ZXh0IiwiRGF0YVRhYmxlQ29udGV4dFByb3ZpZGVyIiwiY2hpbGRyZW4iLCJzb3VyY2VGaWxlIiwidGFyZ2V0RmlsZSIsImRlbGltaXRlcnMiLCJwYXJzZXIiLCJjb25maWciLCJjb21wb3NpdGVLZXlJbmRpY2VzIiwiY29sdW1uc0ZpbHRlciIsImRhdGEiLCJzZXREYXRhIiwicm93c1JlZHVjZXIiLCJyb3dzIiwiYWN0aW9uIiwiX3Jvd3MiLCJ0eXBlIiwidmFsdWUiLCJyb3dJbmRleCIsInJvd0RhdGEiLCJjb2x1bW5JbmRleCIsIkVycm9yIiwic291cmNlUm93cyIsInNldFNvdXJjZVJvd3MiLCJ0YXJnZXRSb3dzIiwidGFyZ2V0Um93c0Rpc3BhdGNoIiwic2V0VGFyZ2V0Um93cyIsImNoYW5nZWQiLCJzZXRDaGFuZ2VkIiwiY29sdW1uTmFtZXMiLCJzZXRDb2x1bW5OYW1lcyIsImNvbHVtbnNGaWx0ZXJPcHRpb25zIiwic2V0Q29sdW1uc0ZpbHRlck9wdGlvbnMiLCJPYmplY3QiLCJrZXlzIiwibGVuZ3RoIiwiY29sdW1uSW5kaWNlcyIsIm1hcCIsImNvbHVtbk5hbWUiLCJpbmRleE9mIiwiX2NvbHVtbnNGaWx0ZXJPcHRpb25zIiwidHN2U3RyaW5nVG9UYWJsZSIsImNvbnNvbGUiLCJsb2ciLCJ0YWJsZSIsImhlYWRlciIsIl9kYXRhIiwiYWN0aW9ucyIsInJvd01vdmVBYm92ZSIsInJvd01vdmVCZWxvdyIsInJvd0FkZEJlbG93Iiwicm93RGVsZXRlIiwiY2VsbEVkaXQiLCJyb3dHZW5lcmF0ZSIsInRhcmdldEZpbGVTYXZlIiwidGFibGVUb1RzdlN0cmluZyIsInB1c2giLCJpIiwiZXJyb3JzIiwiSlNPTiIsInN0cmluZ2lmeSIsInN0YXRlIiwiY29tcG9uZW50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LENBQWtCLFFBQWxCO0FBQTJCLE1BQUEsS0FBSyxFQUFFN0M7QUFBbEMsT0FDR2YsUUFESCxDQURGO0FBS0Q7O0FBQ0QsU0FBTzRELFNBQVA7QUFDRDs7QUFBQSIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBSZWFjdCwge1xyXG4gIHVzZVN0YXRlLCB1c2VSZWR1Y2VyLCB1c2VFZmZlY3QsIHVzZU1lbW8sXHJcbn0gZnJvbSAncmVhY3QnO1xyXG5pbXBvcnQgaXNFcXVhbCBmcm9tICdsb2Rhc2guaXNlcXVhbCc7XHJcbmltcG9ydCB1c2VEZWVwRWZmZWN0IGZyb20gJ3VzZS1kZWVwLWNvbXBhcmUtZWZmZWN0JztcclxuaW1wb3J0IGRlZXBGcmVlemUgZnJvbSAnZGVlcC1mcmVlemUnO1xyXG5cclxuaW1wb3J0IHtcclxuICByb3dNb3ZlQWJvdmUsIHJvd01vdmVCZWxvdywgcm93QWRkQmVsb3csIHJvd0RlbGV0ZSwgY2VsbEVkaXQsXHJcbiAgcGFyc2VEYXRhVGFibGUsIGNvcnJlbGF0ZURhdGEsIHJvd0dlbmVyYXRlLCBzdHJpbmdpZnksIGdldENvbHVtbnNGaWx0ZXJPcHRpb25zLFxyXG59IGZyb20gJy4uLy4uL2NvcmUvZGF0YXRhYmxlJztcclxuXHJcbmV4cG9ydCBjb25zdCBEYXRhVGFibGVDb250ZXh0ID0gUmVhY3QuY3JlYXRlQ29udGV4dCgpO1xyXG5cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBEYXRhVGFibGVDb250ZXh0UHJvdmlkZXIoe1xyXG4gIGNoaWxkcmVuLFxyXG4gIHNvdXJjZUZpbGUsXHJcbiAgdGFyZ2V0RmlsZSxcclxuICBkZWxpbWl0ZXJzLFxyXG4gIHBhcnNlcixcclxuICBjb25maWc6IHtcclxuICAgIGNvbXBvc2l0ZUtleUluZGljZXMsXHJcbiAgICBjb2x1bW5zRmlsdGVyLFxyXG4gIH0sXHJcbn0pIHtcclxuICBjb25zdCBbZGF0YSwgc2V0RGF0YV0gPSB1c2VTdGF0ZSh7fSk7XHJcbiAgY29uc3Qgcm93c1JlZHVjZXIgPSAocm93cywgYWN0aW9uKSA9PiB7XHJcbiAgICBsZXQgX3Jvd3M7XHJcbiAgICBjb25zdCB7IHR5cGUsIHZhbHVlIH0gPSBhY3Rpb247XHJcbiAgICBjb25zdCB7XHJcbiAgICAgIHJvd0luZGV4LCByb3dEYXRhLCBjb2x1bW5JbmRleCxcclxuICAgIH0gPSB2YWx1ZTtcclxuICBcclxuICAgIHN3aXRjaCAodHlwZSkge1xyXG4gICAgICBjYXNlICdTRVRfUk9XUyc6XHJcbiAgICAgICAgcmV0dXJuIGRlZXBGcmVlemUodmFsdWUucm93cyk7XHJcbiAgICAgIGNhc2UgJ1JPV19NT1ZFX0FCT1ZFJzpcclxuICAgICAgICBfcm93cyA9IHJvd01vdmVBYm92ZSh7IHJvd3MsIHJvd0luZGV4IH0pO1xyXG4gICAgICAgIHJldHVybiBkZWVwRnJlZXplKF9yb3dzKTtcclxuICAgICAgY2FzZSAnUk9XX01PVkVfQkVMT1cnOlxyXG4gICAgICAgIF9yb3dzID0gcm93TW92ZUJlbG93KHsgcm93cywgcm93SW5kZXggfSk7XHJcbiAgICAgICAgcmV0dXJuIGRlZXBGcmVlemUoX3Jvd3MpO1xyXG4gICAgICBjYXNlICdST1dfQUREX0JFTE9XJzpcclxuICAgICAgICBfcm93cyA9IHJvd0FkZEJlbG93KHtcclxuICAgICAgICAgIHJvd3MsIHJvd0luZGV4LCByb3dEYXRhLFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBkZWVwRnJlZXplKF9yb3dzKTtcclxuICAgICAgY2FzZSAnUk9XX0RFTEVURSc6XHJcbiAgICAgICAgX3Jvd3MgPSByb3dEZWxldGUoeyByb3dzLCByb3dJbmRleCB9KTtcclxuICAgICAgICByZXR1cm4gZGVlcEZyZWV6ZShfcm93cyk7XHJcbiAgICAgIGNhc2UgJ0NFTExfRURJVCc6XHJcbiAgICAgICAgX3Jvd3MgPSBjZWxsRWRpdCh7XHJcbiAgICAgICAgICByb3dzLCByb3dJbmRleCwgY29sdW1uSW5kZXgsIHZhbHVlOiB2YWx1ZS52YWx1ZSwgZGF0YSxcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gZGVlcEZyZWV6ZShfcm93cyk7XHJcbiAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBhY3Rpb24gdHlwZTogJHthY3Rpb24udHlwZX1gKTtcclxuICAgIH07XHJcbiAgfTtcclxuXHJcbiAgY29uc3QgW3NvdXJjZVJvd3MsIHNldFNvdXJjZVJvd3NdID0gdXNlU3RhdGUoe30pO1xyXG4gIGNvbnN0IFt0YXJnZXRSb3dzLCB0YXJnZXRSb3dzRGlzcGF0Y2hdID0gdXNlUmVkdWNlcihyb3dzUmVkdWNlciwge30pO1xyXG4gIGNvbnN0IHNldFRhcmdldFJvd3MgPSAocm93cykgPT4gdGFyZ2V0Um93c0Rpc3BhdGNoKHsgdHlwZTogJ1NFVF9ST1dTJywgdmFsdWU6IHsgcm93cyB9IH0pO1xyXG4gIGNvbnN0IFtjaGFuZ2VkLCBzZXRDaGFuZ2VkXSA9IHVzZVN0YXRlKGZhbHNlKTtcclxuICBjb25zdCBbY29sdW1uTmFtZXMsIHNldENvbHVtbk5hbWVzXSA9IHVzZVN0YXRlKHt9KTtcclxuICBjb25zdCBbY29sdW1uc0ZpbHRlck9wdGlvbnMsIHNldENvbHVtbnNGaWx0ZXJPcHRpb25zXSA9IHVzZVN0YXRlKFtdKTtcclxuXHJcblxyXG4gIC8vIHBvcHVsYXRlIGNvbHVtbnNGaWx0ZXJPcHRpb25zIHdoZW4gcmVhZHlcclxuICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgaWYgKGNvbHVtbnNGaWx0ZXIgJiYgY29sdW1uTmFtZXMgJiYgT2JqZWN0LmtleXMoZGF0YSkubGVuZ3RoKSB7XHJcbiAgICAgIGNvbnN0IGNvbHVtbkluZGljZXMgPSBjb2x1bW5zRmlsdGVyLm1hcChjb2x1bW5OYW1lID0+IGNvbHVtbk5hbWVzLmluZGV4T2YoY29sdW1uTmFtZSkpO1xyXG4gICAgICBjb25zdCBfY29sdW1uc0ZpbHRlck9wdGlvbnMgPSBnZXRDb2x1bW5zRmlsdGVyT3B0aW9ucyh7XHJcbiAgICAgICAgY29sdW1uSW5kaWNlcywgZGF0YSwgZGVsaW1pdGVycyxcclxuICAgICAgfSk7XHJcblxyXG4gICAgICBpZiAoIWlzRXF1YWwoX2NvbHVtbnNGaWx0ZXJPcHRpb25zLCBjb2x1bW5zRmlsdGVyT3B0aW9ucykpIHtcclxuICAgICAgICBzZXRDb2x1bW5zRmlsdGVyT3B0aW9ucyhfY29sdW1uc0ZpbHRlck9wdGlvbnMpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfSwgW2NvbHVtbnNGaWx0ZXIsIGNvbHVtbk5hbWVzLCBkYXRhLCBkZWxpbWl0ZXJzLCBjb2x1bW5zRmlsdGVyT3B0aW9uc10pO1xyXG4gIC8vIHBhcnNlIHNvdXJjZUZpbGUgd2hlbiB1cGRhdGVkXHJcbiAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgIGlmIChwYXJzZXIgJiYgcGFyc2VyLnRzdlN0cmluZ1RvVGFibGUpIHtcclxuICAgICAgY29uc29sZS5sb2coXCJEYXRhVGFibGUuY29udGV4dCgpIHVzaW5nIHRzdiBwYXJzZXIgZm9yIHNvdXJjZVwiKVxyXG4gICAgICBjb25zdCB7IGRhdGE6IHJvd3MgfSA9IHBhcnNlci50c3ZTdHJpbmdUb1RhYmxlKHNvdXJjZUZpbGUpO1xyXG4gICAgICBzZXRTb3VyY2VSb3dzKHJvd3MpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgaWYgKGRlbGltaXRlcnMpIHtcclxuICAgICAgICBjb25zdCB7IHJvd3MgfSA9IHBhcnNlRGF0YVRhYmxlKHsgdGFibGU6IHNvdXJjZUZpbGUsIGRlbGltaXRlcnMgfSk7XHJcbiAgICAgICAgc2V0U291cmNlUm93cyhyb3dzKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH0sIFtzb3VyY2VGaWxlLCBkZWxpbWl0ZXJzLCBwYXJzZXJdKTtcclxuICAvLyBwYXJzZSB0YXJnZXRGaWxlIHdoZW4gdXBkYXRlZFxyXG4gIHVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICBpZiAocGFyc2VyICYmIHBhcnNlci50c3ZTdHJpbmdUb1RhYmxlKSB7XHJcbiAgICAgIGNvbnNvbGUubG9nKFwiRGF0YVRhYmxlLmNvbnRleHQoKSB1c2luZyB0c3YgcGFyc2VyIGZvciB0YXJnZXRcIilcclxuICAgICAgY29uc3QgeyBoZWFkZXI6IGNvbHVtbk5hbWVzLCBkYXRhOiByb3dzIH0gPSBwYXJzZXIudHN2U3RyaW5nVG9UYWJsZSh0YXJnZXRGaWxlKTtcclxuICAgICAgc2V0Q29sdW1uTmFtZXMoY29sdW1uTmFtZXMpO1xyXG4gICAgICBzZXRUYXJnZXRSb3dzKHJvd3MpO1xyXG4gICAgICBzZXRDaGFuZ2VkKGZhbHNlKTtcclxuICAgIH0gZWxzZSBpZiAoZGVsaW1pdGVycykge1xyXG4gICAgICAgIGNvbnN0IHsgY29sdW1uTmFtZXMsIHJvd3MgfSA9IHBhcnNlRGF0YVRhYmxlKHsgdGFibGU6IHRhcmdldEZpbGUsIGRlbGltaXRlcnMgfSk7XHJcbiAgICAgICAgc2V0Q29sdW1uTmFtZXMoY29sdW1uTmFtZXMpO1xyXG4gICAgICAgIHNldFRhcmdldFJvd3Mocm93cyk7XHJcbiAgICAgICAgc2V0Q2hhbmdlZChmYWxzZSk7XHJcbiAgICB9XHJcbiAgfSwgW3RhcmdldEZpbGUsIGRlbGltaXRlcnMsIHBhcnNlcl0pO1xyXG4gIC8vIGNvcnJlbGF0ZSBkYXRhIGJ5IGNvbXBvc2l0ZUtleUluZGljZXMgd2hlbiBzb3VyY2VSb3dzIG9yIHRhcmdldFJvd3MgdXBkYXRlZFxyXG4gIHVzZURlZXBFZmZlY3QoKCkgPT4ge1xyXG4gICAgaWYgKE9iamVjdC5rZXlzKHNvdXJjZVJvd3MpLmxlbmd0aCAmJiBPYmplY3Qua2V5cyh0YXJnZXRSb3dzKS5sZW5ndGgpIHtcclxuICAgICAgY29uc3QgX2RhdGEgPSBjb3JyZWxhdGVEYXRhKHtcclxuICAgICAgICBzb3VyY2VSb3dzLCB0YXJnZXRSb3dzLCBjb21wb3NpdGVLZXlJbmRpY2VzLCBkZWxpbWl0ZXJzLFxyXG4gICAgICB9KTtcclxuICAgICAgc2V0RGF0YShfZGF0YSk7XHJcbiAgICB9XHJcbiAgfSwgW3NvdXJjZVJvd3MsIHRhcmdldFJvd3MsIGNvbXBvc2l0ZUtleUluZGljZXMsIGRlbGltaXRlcnNdKTtcclxuXHJcbiAgY29uc3QgYWN0aW9ucyA9IHVzZU1lbW8oKCkgPT4gKHtcclxuICAgIHJvd01vdmVBYm92ZTogKHsgcm93SW5kZXggfSkgPT4ge1xyXG4gICAgICB0YXJnZXRSb3dzRGlzcGF0Y2goeyB0eXBlOiAnUk9XX01PVkVfQUJPVkUnLCB2YWx1ZTogeyByb3dJbmRleCB9IH0pO1xyXG4gICAgICBzZXRDaGFuZ2VkKHRydWUpO1xyXG4gICAgfSxcclxuICAgIHJvd01vdmVCZWxvdzogKHsgcm93SW5kZXggfSkgPT4ge1xyXG4gICAgICB0YXJnZXRSb3dzRGlzcGF0Y2goeyB0eXBlOiAnUk9XX01PVkVfQkVMT1cnLCB2YWx1ZTogeyByb3dJbmRleCB9IH0pO1xyXG4gICAgICBzZXRDaGFuZ2VkKHRydWUpO1xyXG4gICAgfSxcclxuICAgIHJvd0FkZEJlbG93OiAoeyByb3dJbmRleCwgcm93RGF0YSB9KSA9PiB7XHJcbiAgICAgIHRhcmdldFJvd3NEaXNwYXRjaCh7IHR5cGU6ICdST1dfQUREX0JFTE9XJywgdmFsdWU6IHsgcm93SW5kZXgsIHJvd0RhdGEgfSB9KTtcclxuICAgICAgc2V0Q2hhbmdlZCh0cnVlKTtcclxuICAgIH0sXHJcbiAgICByb3dEZWxldGU6ICh7IHJvd0luZGV4IH0pID0+IHtcclxuICAgICAgdGFyZ2V0Um93c0Rpc3BhdGNoKHsgdHlwZTogJ1JPV19ERUxFVEUnLCB2YWx1ZTogeyByb3dJbmRleCB9IH0pO1xyXG4gICAgICBjb25zb2xlLmxvZyhcInJvdyBkZWxldGVkXCIpO1xyXG4gICAgICBzZXRDaGFuZ2VkKHRydWUpO1xyXG4gICAgfSxcclxuICAgIGNlbGxFZGl0OiAoe1xyXG4gICAgICByb3dJbmRleCwgY29sdW1uSW5kZXgsIHZhbHVlLCBcclxuICAgIH0pID0+IHtcclxuICAgICAgdGFyZ2V0Um93c0Rpc3BhdGNoKHtcclxuICAgICAgICB0eXBlOiAnQ0VMTF9FRElUJywgdmFsdWU6IHtcclxuICAgICAgICAgIHJvd0luZGV4LCBjb2x1bW5JbmRleCwgdmFsdWUsIFxyXG4gICAgICAgIH0sXHJcbiAgICAgIH0pO1xyXG4gICAgICBzZXRDaGFuZ2VkKHRydWUpO1xyXG4gICAgfSxcclxuICAgIHJvd0dlbmVyYXRlOiAoeyByb3dJbmRleCB9KSA9PiByb3dHZW5lcmF0ZSh7XHJcbiAgICAgIHJvd3M6IHRhcmdldFJvd3MsIGNvbHVtbk5hbWVzLCByb3dJbmRleCxcclxuICAgIH0pLFxyXG4gICAgdGFyZ2V0RmlsZVNhdmU6ICgpID0+IHtcclxuICAgICAgaWYgKHBhcnNlciAmJiBwYXJzZXIudGFibGVUb1RzdlN0cmluZykge1xyXG4gICAgICAgIC8vIGNvbWJpbmUgaGVhZGVyIHJvd3MgYW5kIGRhdGEgcm93c1xyXG4gICAgICAgIGxldCB0YWJsZSA9IFtdO1xyXG4gICAgICAgIHRhYmxlLnB1c2goY29sdW1uTmFtZXMpO1xyXG4gICAgICAgIGZvciAobGV0IGk9MDsgaTx0YXJnZXRSb3dzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICB0YWJsZS5wdXNoKHRhcmdldFJvd3NbaV0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCB7ZGF0YSwgZXJyb3JzfSA9IHBhcnNlci50YWJsZVRvVHN2U3RyaW5nKHRhYmxlKTtcclxuICAgICAgICBpZiAoIGVycm9ycy5sZW5ndGggIT09IDAgKSB7XHJcbiAgICAgICAgICB0aHJvdyhKU09OLnN0cmluZ2lmeShlcnJvcnMsbnVsbCw0KSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBkYXRhO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHJldHVybiBzdHJpbmdpZnkoe1xyXG4gICAgICAgIGNvbHVtbk5hbWVzLCByb3dzOiB0YXJnZXRSb3dzLCBkZWxpbWl0ZXJzLFxyXG4gICAgfSl9fSxcclxuICAgIHNldENoYW5nZWQsXHJcbiAgfSksIFtjb2x1bW5OYW1lcywgZGVsaW1pdGVycywgdGFyZ2V0Um93cywgcGFyc2VyXSk7XHJcblxyXG4gIGNvbnN0IHZhbHVlID0gdXNlTWVtbygoKSA9PiBkZWVwRnJlZXplKHtcclxuICAgIHN0YXRlOiB7XHJcbiAgICAgIGNvbHVtbk5hbWVzLFxyXG4gICAgICBkYXRhLFxyXG4gICAgICBjaGFuZ2VkLFxyXG4gICAgICBjb2x1bW5zRmlsdGVyT3B0aW9ucyxcclxuICAgIH0sXHJcbiAgICBhY3Rpb25zLFxyXG4gIH0pLCBbYWN0aW9ucywgY2hhbmdlZCwgY29sdW1uTmFtZXMsIGNvbHVtbnNGaWx0ZXJPcHRpb25zLCBkYXRhXSk7XHJcblxyXG4gIGxldCBjb21wb25lbnQgPSA8PjwvPjtcclxuXHJcbiAgaWYgKGNvbHVtbk5hbWVzICYmIE9iamVjdC5rZXlzKGRhdGEpLmxlbmd0aCkge1xyXG4gICAgY29tcG9uZW50ID0gKFxyXG4gICAgICA8RGF0YVRhYmxlQ29udGV4dC5Qcm92aWRlciB2YWx1ZT17dmFsdWV9PlxyXG4gICAgICAgIHtjaGlsZHJlbn1cclxuICAgICAgPC9EYXRhVGFibGVDb250ZXh0LlByb3ZpZGVyPlxyXG4gICAgKTtcclxuICB9XHJcbiAgcmV0dXJuIGNvbXBvbmVudDtcclxufTtcclxuIl19