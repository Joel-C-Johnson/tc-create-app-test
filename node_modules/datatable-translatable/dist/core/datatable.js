"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getOffset = getOffset;
exports.getRowElement = exports.parseCells = exports.parseRows = exports.getRows = exports.getColumnNames = exports.stringify = exports.parseDataTable = exports.getColumnsFilterOptions = exports.correlateData = exports.rowGenerate = exports.cellEdit = exports.rowDelete = exports.rowAddBelow = exports.rowAddAbove = exports.rowMoveBelow = exports.rowMoveAbove = void 0;

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

var rowMoveAbove = function rowMoveAbove(_ref) {
  var rows = _ref.rows,
      rowIndex = _ref.rowIndex;
  return arrayMove(rows, rowIndex, rowIndex - 1);
};

exports.rowMoveAbove = rowMoveAbove;

var rowMoveBelow = function rowMoveBelow(_ref2) {
  var rows = _ref2.rows,
      rowIndex = _ref2.rowIndex;
  return arrayMove(rows, rowIndex, rowIndex + 1);
};

exports.rowMoveBelow = rowMoveBelow;

var rowAddAbove = function rowAddAbove(_ref3) {
  var rows = _ref3.rows,
      rowIndex = _ref3.rowIndex,
      rowData = _ref3.rowData;

  var _rows = _toConsumableArray(rows);

  _rows.splice(rowIndex - 1, 0, rowData);

  return _rows;
};

exports.rowAddAbove = rowAddAbove;

var rowAddBelow = function rowAddBelow(_ref4) {
  var rows = _ref4.rows,
      rowIndex = _ref4.rowIndex,
      rowData = _ref4.rowData;

  var _rows = _toConsumableArray(rows);

  _rows.splice(rowIndex + 1, 0, rowData);

  return _rows;
};

exports.rowAddBelow = rowAddBelow;

var rowDelete = function rowDelete(_ref5) {
  var rows = _ref5.rows,
      rowIndex = _ref5.rowIndex;

  var _rows = _toConsumableArray(rows);

  _rows.splice(rowIndex, 1);

  return _rows;
};

exports.rowDelete = rowDelete;

var cellEdit = function cellEdit(_ref6) {
  var rows = _ref6.rows,
      rowIndex = _ref6.rowIndex,
      columnIndex = _ref6.columnIndex,
      value = _ref6.value,
      data = _ref6.data;

  var _rows = rows.map(function (cells) {
    return _toConsumableArray(cells);
  }); // if row index points beyond end of array, 
  // then add as many empty rows as needed to 
  // make it a valid, even if empty row


  if (rowIndex >= rows.length || rows[rowIndex] === undefined) {
    //console.log("Undo delete process begins")
    //console.log("[datatable.js] cellEdit() number of row=", rows.length, " rowIndex=", rowIndex, " rows[rowIndex]", rows[rowIndex]);
    for (var i = -1; i < rowIndex - rows.length; i++) {
      var _row = new Array(rows[0].length); // set each cell in new row to be empty string


      for (var j = 0; j < _row.length; j++) {//_row[j] = "";
      }

      _rows.push(_row);
    } // now do an "undo" by filling in values from source


    for (var _i = 0; _i < _rows[rowIndex].length; _i++) {
      _rows[rowIndex][_i] = data[rowIndex][_i].trim();
    } //console.log("Undo delete process ends")

  }

  _rows[rowIndex][columnIndex] = value; //console.log("_rows before filter:", _rows);
  // next remove any empty rows created by the undo delete process

  _rows = _rows.filter(function (arow) {
    return arow[0] !== undefined;
  }); //console.log("_rows after filter:", _rows);

  return _rows;
};

exports.cellEdit = cellEdit;

var rowGenerate = function rowGenerate(_ref7) {
  var rows = _ref7.rows,
      columnNames = _ref7.columnNames,
      rowIndex = _ref7.rowIndex;
  var rowsIndex = {};
  var lengthIndex = {};
  var rowData = rows[rowIndex];
  rows.forEach(function (_row) {
    _row.forEach(function (value, index) {
      var column = columnNames[index];

      if (!rowsIndex[column]) {
        rowsIndex[column] = {};
      }

      if (!rowsIndex[column][value]) {
        rowsIndex[column][value] = 0;
      }

      rowsIndex[column][value]++;
      var valueLength = value.length;

      if (!lengthIndex[column]) {
        lengthIndex[column] = {};
      }

      if (!lengthIndex[column][valueLength]) {
        lengthIndex[column][valueLength] = 0;
      }

      lengthIndex[column][valueLength]++;
    });
  });
  var rowCount = rows.length;
  var newRow = rowData.map(function (value, index) {
    var column = columnNames[index];
    var values = Object.keys(rowsIndex[column]).length;
    var valuesRatio = values / rowCount;
    var duplicateValue = valuesRatio < 0.5;
    var valuesLengths = Object.keys(lengthIndex[column]);
    var valuesLengthsLength = valuesLengths.length;
    var needRandomId = valuesRatio > 0.99 && valuesLengthsLength <= 2;
    var newValue = '';

    if (duplicateValue) {
      newValue = value;
    } else if (needRandomId) {
      var length = value.length;
      var notUnique = true;
      var counter = 0;
      var allIds = Object.keys(rowsIndex[column]);
      var UNIQUE_COUNTER_THRESHOLD = 1000;

      while (notUnique && counter < UNIQUE_COUNTER_THRESHOLD) {
        newValue = randomId({
          length: length
        });
        notUnique = allIds.includes(newValue);
        counter++;
      }

      if (counter >= UNIQUE_COUNTER_THRESHOLD) {
        console.log("Duplicate IDs found after " + UNIQUE_COUNTER_THRESHOLD + " tries");
      }
    }

    return newValue;
  });
  return newRow;
};

exports.rowGenerate = rowGenerate;

var correlateData = function correlateData(_ref8) {
  var sourceRows = _ref8.sourceRows,
      targetRows = _ref8.targetRows,
      compositeKeyIndices = _ref8.compositeKeyIndices,
      delimiters = _ref8.delimiters;
  var data = [];

  if (sourceRows[0].length === targetRows[0].length) {
    var rowIndex = {};
    targetRows.forEach(function (row) {
      var compositeKey = compositeKeyIndices.map(function (index) {
        return row[index];
      }).join(':');
      rowIndex[compositeKey] = {
        target: row
      };
    });
    sourceRows.forEach(function (row) {
      var compositeKey = compositeKeyIndices.map(function (index) {
        return row[index];
      }).join(':'); // rowIndex[compositeKey] = rowIndex[compositeKey] || {};

      rowIndex[compositeKey] = _objectSpread({
        source: row
      }, rowIndex[compositeKey]);
    });
    data = Object.values(rowIndex).map(function (row) {
      var _row;

      if (row.source) {
        _row = row.source.map(function (sourceCell, index) {
          return "".concat(sourceCell).concat(delimiters.cell).concat(row.target ? row.target[index].replace(/^\u200B+/, '').replace(/\u200B+$/, '') : '');
        });
      } else {
        _row = row.target.map(function (targetCell, index) {
          return "".concat(delimiters.cell).concat(targetCell.replace(/^\u200B+/, '').replace(/\u200B+$/, ''));
        });
      }

      return _row;
    });
  }

  return data;
};

exports.correlateData = correlateData;

var getColumnsFilterOptions = function getColumnsFilterOptions(_ref9) {
  var columnIndices = _ref9.columnIndices,
      data = _ref9.data,
      delimiters = _ref9.delimiters;
  var _columnsFilterOptions = [];
  data.forEach(function (row) {
    columnIndices.forEach(function (columnIndex) {
      var values = row[columnIndex].split(delimiters.cell);
      values.forEach(function (value) {
        if (value) {
          if (!_columnsFilterOptions[columnIndex]) {
            _columnsFilterOptions[columnIndex] = [];
          }

          if (!_columnsFilterOptions[columnIndex].includes(value)) {
            _columnsFilterOptions[columnIndex].push(value);
          }
        }
      });
    });
  });
  return _columnsFilterOptions;
};

exports.getColumnsFilterOptions = getColumnsFilterOptions;

var parseDataTable = function parseDataTable(_ref10) {
  var table = _ref10.table,
      delimiters = _ref10.delimiters;
  var rows = parseRows({
    table: table,
    delimiter: delimiters.row
  }).map(function (row) {
    return parseCells({
      row: row,
      delimiter: delimiters.cell
    });
  });
  var dataTable = {
    columnNames: getColumnNames(rows),
    rows: getRows(rows)
  };
  return dataTable;
};

exports.parseDataTable = parseDataTable;

var stringify = function stringify(_ref11) {
  var columnNames = _ref11.columnNames,
      rows = _ref11.rows,
      delimiters = _ref11.delimiters;
  var string = '';

  if (columnNames && rows) {
    var dataTable = [columnNames].concat(_toConsumableArray(rows));

    for (var i = 0; i < dataTable.length; i++) {
      var rowstring = '';

      for (var j = 0; j < dataTable[i].length; j++) {
        rowstring += dataTable[i][j].replaceAll(/\n/gi, '<br>');

        if (j < dataTable[i].length - 1) {
          rowstring += delimiters.cell;
        }

        ;
      }

      string += rowstring;
      string += delimiters.row;
    } // The below is commented out and replaced with the 2d for loop above.
    // This is needed in order to only apply the outputFilter to make newlines 
    // into <br> elements when no parser is provided to the component. 
    // This makes up for the unconditional removal 
    // from the datatable outputfilter specified in Cell.js
    //string = dataTable.map(cells => cells.join(delimiters.cell)).join(delimiters.row);

  }

  return string;
};

exports.stringify = stringify;

var getColumnNames = function getColumnNames(rows) {
  return rows[0];
};

exports.getColumnNames = getColumnNames;

var getRows = function getRows(rows) {
  return rows.slice(1);
};

exports.getRows = getRows;

var parseRows = function parseRows(_ref12) {
  var table = _ref12.table,
      delimiter = _ref12.delimiter;
  return table.split(delimiter).filter(function (row) {
    return row !== '';
  });
};

exports.parseRows = parseRows;

var parseCells = function parseCells(_ref13) {
  var row = _ref13.row,
      delimiter = _ref13.delimiter;
  return row.split(delimiter);
}; // Private
// ids must begin with a letter


exports.parseCells = parseCells;

var randomId = function randomId(_ref14) {
  var length = _ref14.length;
  // get the initial letter first
  var letters = ["a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z"];
  var random = Math.floor(Math.random() * letters.length);
  var number = Math.random(); // 0.9394456857981651
  // number.toString(36); // '0.xtis06h6'

  if (length > 9) {
    length = 9;
  }

  var id = letters[random] + number.toString(36).substr(2, length - 1); // 'xtis06h6'

  return id;
};

var arrayMove = function arrayMove(array, oldIndex, newIndex) {
  var _array = _toConsumableArray(array);

  var tooLow = newIndex < 0;
  var tooHigh = newIndex > array.length - 1;

  if (!tooLow && !tooHigh) {
    var element = _array[oldIndex];

    _array.splice(oldIndex, 1);

    _array.splice(newIndex, 0, element);
  }

  return _array;
};

var getRowElement = function getRowElement(generateRowId, rowData, position) {
  var id = generateRowId(rowData);
  var currentHeader = document.getElementById(id);
  var previousSiblingHeader = getSiblingByClassName(currentHeader, '.header-row', position);
  return previousSiblingHeader;
};

exports.getRowElement = getRowElement;

function getSiblingByClassName(div, className, position) {
  var allInstances = Array.from(document.querySelectorAll(className));
  var indexOfCurrentElement = allInstances.indexOf(div);
  return allInstances[indexOfCurrentElement + position];
}

function getOffset(element) {
  var rect, win;

  if (!element) {
    return;
  } // Return zeros for disconnected and hidden (display: none) elements (gh-2310)
  // Support: IE <=11+
  // Running getBoundingClientRect on a
  // disconnected node in IE throws an error


  if (!element.getClientRects().length) {
    return {
      top: 0,
      left: 0
    };
  } // Get document-relative position by adding viewport scroll to viewport-relative gBCR


  rect = element.getBoundingClientRect();
  win = element.ownerDocument.defaultView;
  return {
    top: rect.top + win.pageYOffset,
    left: rect.left + win.pageXOffset
  };
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9jb3JlL2RhdGF0YWJsZS5qcyJdLCJuYW1lcyI6WyJyb3dNb3ZlQWJvdmUiLCJyb3dzIiwicm93SW5kZXgiLCJhcnJheU1vdmUiLCJyb3dNb3ZlQmVsb3ciLCJyb3dBZGRBYm92ZSIsInJvd0RhdGEiLCJfcm93cyIsInNwbGljZSIsInJvd0FkZEJlbG93Iiwicm93RGVsZXRlIiwiY2VsbEVkaXQiLCJjb2x1bW5JbmRleCIsInZhbHVlIiwiZGF0YSIsIm1hcCIsImNlbGxzIiwibGVuZ3RoIiwidW5kZWZpbmVkIiwiaSIsIl9yb3ciLCJBcnJheSIsImoiLCJwdXNoIiwidHJpbSIsImZpbHRlciIsImFyb3ciLCJyb3dHZW5lcmF0ZSIsImNvbHVtbk5hbWVzIiwicm93c0luZGV4IiwibGVuZ3RoSW5kZXgiLCJmb3JFYWNoIiwiaW5kZXgiLCJjb2x1bW4iLCJ2YWx1ZUxlbmd0aCIsInJvd0NvdW50IiwibmV3Um93IiwidmFsdWVzIiwiT2JqZWN0Iiwia2V5cyIsInZhbHVlc1JhdGlvIiwiZHVwbGljYXRlVmFsdWUiLCJ2YWx1ZXNMZW5ndGhzIiwidmFsdWVzTGVuZ3Roc0xlbmd0aCIsIm5lZWRSYW5kb21JZCIsIm5ld1ZhbHVlIiwibm90VW5pcXVlIiwiY291bnRlciIsImFsbElkcyIsIlVOSVFVRV9DT1VOVEVSX1RIUkVTSE9MRCIsInJhbmRvbUlkIiwiaW5jbHVkZXMiLCJjb25zb2xlIiwibG9nIiwiY29ycmVsYXRlRGF0YSIsInNvdXJjZVJvd3MiLCJ0YXJnZXRSb3dzIiwiY29tcG9zaXRlS2V5SW5kaWNlcyIsImRlbGltaXRlcnMiLCJyb3ciLCJjb21wb3NpdGVLZXkiLCJqb2luIiwidGFyZ2V0Iiwic291cmNlIiwic291cmNlQ2VsbCIsImNlbGwiLCJyZXBsYWNlIiwidGFyZ2V0Q2VsbCIsImdldENvbHVtbnNGaWx0ZXJPcHRpb25zIiwiY29sdW1uSW5kaWNlcyIsIl9jb2x1bW5zRmlsdGVyT3B0aW9ucyIsInNwbGl0IiwicGFyc2VEYXRhVGFibGUiLCJ0YWJsZSIsInBhcnNlUm93cyIsImRlbGltaXRlciIsInBhcnNlQ2VsbHMiLCJkYXRhVGFibGUiLCJnZXRDb2x1bW5OYW1lcyIsImdldFJvd3MiLCJzdHJpbmdpZnkiLCJzdHJpbmciLCJyb3dzdHJpbmciLCJyZXBsYWNlQWxsIiwic2xpY2UiLCJsZXR0ZXJzIiwicmFuZG9tIiwiTWF0aCIsImZsb29yIiwibnVtYmVyIiwiaWQiLCJ0b1N0cmluZyIsInN1YnN0ciIsImFycmF5Iiwib2xkSW5kZXgiLCJuZXdJbmRleCIsIl9hcnJheSIsInRvb0xvdyIsInRvb0hpZ2giLCJlbGVtZW50IiwiZ2V0Um93RWxlbWVudCIsImdlbmVyYXRlUm93SWQiLCJwb3NpdGlvbiIsImN1cnJlbnRIZWFkZXIiLCJkb2N1bWVudCIsImdldEVsZW1lbnRCeUlkIiwicHJldmlvdXNTaWJsaW5nSGVhZGVyIiwiZ2V0U2libGluZ0J5Q2xhc3NOYW1lIiwiZGl2IiwiY2xhc3NOYW1lIiwiYWxsSW5zdGFuY2VzIiwiZnJvbSIsInF1ZXJ5U2VsZWN0b3JBbGwiLCJpbmRleE9mQ3VycmVudEVsZW1lbnQiLCJpbmRleE9mIiwiZ2V0T2Zmc2V0IiwicmVjdCIsIndpbiIsImdldENsaWVudFJlY3RzIiwidG9wIiwibGVmdCIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsIm93bmVyRG9jdW1lbnQiLCJkZWZhdWx0VmlldyIsInBhZ2VZT2Zmc2V0IiwicGFnZVhPZmZzZXQiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQ08sSUFBTUEsWUFBWSxHQUFHLFNBQWZBLFlBQWU7QUFBQSxNQUFHQyxJQUFILFFBQUdBLElBQUg7QUFBQSxNQUFTQyxRQUFULFFBQVNBLFFBQVQ7QUFBQSxTQUF3QkMsU0FBUyxDQUFDRixJQUFELEVBQU9DLFFBQVAsRUFBaUJBLFFBQVEsR0FBRyxDQUE1QixDQUFqQztBQUFBLENBQXJCOzs7O0FBQ0EsSUFBTUUsWUFBWSxHQUFHLFNBQWZBLFlBQWU7QUFBQSxNQUFHSCxJQUFILFNBQUdBLElBQUg7QUFBQSxNQUFTQyxRQUFULFNBQVNBLFFBQVQ7QUFBQSxTQUF3QkMsU0FBUyxDQUFDRixJQUFELEVBQU9DLFFBQVAsRUFBaUJBLFFBQVEsR0FBRyxDQUE1QixDQUFqQztBQUFBLENBQXJCOzs7O0FBQ0EsSUFBTUcsV0FBVyxHQUFHLFNBQWRBLFdBQWMsUUFFckI7QUFBQSxNQURKSixJQUNJLFNBREpBLElBQ0k7QUFBQSxNQURFQyxRQUNGLFNBREVBLFFBQ0Y7QUFBQSxNQURZSSxPQUNaLFNBRFlBLE9BQ1o7O0FBQ0osTUFBSUMsS0FBSyxzQkFBT04sSUFBUCxDQUFUOztBQUNBTSxFQUFBQSxLQUFLLENBQUNDLE1BQU4sQ0FBYU4sUUFBUSxHQUFHLENBQXhCLEVBQTJCLENBQTNCLEVBQThCSSxPQUE5Qjs7QUFDQSxTQUFPQyxLQUFQO0FBQ0QsQ0FOTTs7OztBQU9BLElBQU1FLFdBQVcsR0FBRyxTQUFkQSxXQUFjLFFBRXJCO0FBQUEsTUFESlIsSUFDSSxTQURKQSxJQUNJO0FBQUEsTUFERUMsUUFDRixTQURFQSxRQUNGO0FBQUEsTUFEWUksT0FDWixTQURZQSxPQUNaOztBQUNKLE1BQUlDLEtBQUssc0JBQU9OLElBQVAsQ0FBVDs7QUFDQU0sRUFBQUEsS0FBSyxDQUFDQyxNQUFOLENBQWFOLFFBQVEsR0FBRyxDQUF4QixFQUEyQixDQUEzQixFQUE4QkksT0FBOUI7O0FBQ0EsU0FBT0MsS0FBUDtBQUNELENBTk07Ozs7QUFPQSxJQUFNRyxTQUFTLEdBQUcsU0FBWkEsU0FBWSxRQUF3QjtBQUFBLE1BQXJCVCxJQUFxQixTQUFyQkEsSUFBcUI7QUFBQSxNQUFmQyxRQUFlLFNBQWZBLFFBQWU7O0FBQy9DLE1BQUlLLEtBQUssc0JBQU9OLElBQVAsQ0FBVDs7QUFDQU0sRUFBQUEsS0FBSyxDQUFDQyxNQUFOLENBQWFOLFFBQWIsRUFBdUIsQ0FBdkI7O0FBQ0EsU0FBT0ssS0FBUDtBQUNELENBSk07Ozs7QUFLQSxJQUFNSSxRQUFRLEdBQUcsU0FBWEEsUUFBVyxRQUVsQjtBQUFBLE1BREpWLElBQ0ksU0FESkEsSUFDSTtBQUFBLE1BREVDLFFBQ0YsU0FERUEsUUFDRjtBQUFBLE1BRFlVLFdBQ1osU0FEWUEsV0FDWjtBQUFBLE1BRHlCQyxLQUN6QixTQUR5QkEsS0FDekI7QUFBQSxNQURnQ0MsSUFDaEMsU0FEZ0NBLElBQ2hDOztBQUNKLE1BQUlQLEtBQUssR0FBR04sSUFBSSxDQUFDYyxHQUFMLENBQVMsVUFBQUMsS0FBSztBQUFBLDhCQUFRQSxLQUFSO0FBQUEsR0FBZCxDQUFaLENBREksQ0FFSjtBQUNBO0FBQ0E7OztBQUNBLE1BQUtkLFFBQVEsSUFBSUQsSUFBSSxDQUFDZ0IsTUFBakIsSUFBMkJoQixJQUFJLENBQUNDLFFBQUQsQ0FBSixLQUFtQmdCLFNBQW5ELEVBQStEO0FBQzdEO0FBQ0E7QUFDQSxTQUFLLElBQUlDLENBQUMsR0FBQyxDQUFDLENBQVosRUFBZUEsQ0FBQyxHQUFJakIsUUFBUSxHQUFHRCxJQUFJLENBQUNnQixNQUFwQyxFQUE2Q0UsQ0FBQyxFQUE5QyxFQUFrRDtBQUNoRCxVQUFJQyxJQUFJLEdBQUcsSUFBSUMsS0FBSixDQUFVcEIsSUFBSSxDQUFDLENBQUQsQ0FBSixDQUFRZ0IsTUFBbEIsQ0FBWCxDQURnRCxDQUVoRDs7O0FBQ0EsV0FBSyxJQUFJSyxDQUFDLEdBQUMsQ0FBWCxFQUFjQSxDQUFDLEdBQUdGLElBQUksQ0FBQ0gsTUFBdkIsRUFBK0JLLENBQUMsRUFBaEMsRUFBb0MsQ0FDbEM7QUFDRDs7QUFDRGYsTUFBQUEsS0FBSyxDQUFDZ0IsSUFBTixDQUFZSCxJQUFaO0FBQ0QsS0FWNEQsQ0FXN0Q7OztBQUNBLFNBQUssSUFBSUQsRUFBQyxHQUFDLENBQVgsRUFBY0EsRUFBQyxHQUFHWixLQUFLLENBQUNMLFFBQUQsQ0FBTCxDQUFnQmUsTUFBbEMsRUFBMENFLEVBQUMsRUFBM0MsRUFBK0M7QUFDN0NaLE1BQUFBLEtBQUssQ0FBQ0wsUUFBRCxDQUFMLENBQWdCaUIsRUFBaEIsSUFBcUJMLElBQUksQ0FBQ1osUUFBRCxDQUFKLENBQWVpQixFQUFmLEVBQWtCSyxJQUFsQixFQUFyQjtBQUNELEtBZDRELENBZTdEOztBQUNEOztBQUVEakIsRUFBQUEsS0FBSyxDQUFDTCxRQUFELENBQUwsQ0FBZ0JVLFdBQWhCLElBQStCQyxLQUEvQixDQXZCSSxDQXdCSjtBQUNBOztBQUNBTixFQUFBQSxLQUFLLEdBQUdBLEtBQUssQ0FBQ2tCLE1BQU4sQ0FBYyxVQUFBQyxJQUFJO0FBQUEsV0FBSUEsSUFBSSxDQUFDLENBQUQsQ0FBSixLQUFZUixTQUFoQjtBQUFBLEdBQWxCLENBQVIsQ0ExQkksQ0EyQko7O0FBRUEsU0FBT1gsS0FBUDtBQUNELENBaENNOzs7O0FBa0NBLElBQU1vQixXQUFXLEdBQUcsU0FBZEEsV0FBYyxRQUVyQjtBQUFBLE1BREoxQixJQUNJLFNBREpBLElBQ0k7QUFBQSxNQURFMkIsV0FDRixTQURFQSxXQUNGO0FBQUEsTUFEZTFCLFFBQ2YsU0FEZUEsUUFDZjtBQUNKLE1BQUkyQixTQUFTLEdBQUcsRUFBaEI7QUFDQSxNQUFJQyxXQUFXLEdBQUcsRUFBbEI7QUFDQSxNQUFNeEIsT0FBTyxHQUFHTCxJQUFJLENBQUNDLFFBQUQsQ0FBcEI7QUFFQUQsRUFBQUEsSUFBSSxDQUFDOEIsT0FBTCxDQUFhLFVBQUFYLElBQUksRUFBSTtBQUNuQkEsSUFBQUEsSUFBSSxDQUFDVyxPQUFMLENBQWEsVUFBQ2xCLEtBQUQsRUFBUW1CLEtBQVIsRUFBa0I7QUFDN0IsVUFBTUMsTUFBTSxHQUFHTCxXQUFXLENBQUNJLEtBQUQsQ0FBMUI7O0FBRUEsVUFBSSxDQUFDSCxTQUFTLENBQUNJLE1BQUQsQ0FBZCxFQUF3QjtBQUN0QkosUUFBQUEsU0FBUyxDQUFDSSxNQUFELENBQVQsR0FBb0IsRUFBcEI7QUFDRDs7QUFFRCxVQUFJLENBQUNKLFNBQVMsQ0FBQ0ksTUFBRCxDQUFULENBQWtCcEIsS0FBbEIsQ0FBTCxFQUErQjtBQUM3QmdCLFFBQUFBLFNBQVMsQ0FBQ0ksTUFBRCxDQUFULENBQWtCcEIsS0FBbEIsSUFBMkIsQ0FBM0I7QUFDRDs7QUFDRGdCLE1BQUFBLFNBQVMsQ0FBQ0ksTUFBRCxDQUFULENBQWtCcEIsS0FBbEI7QUFDQSxVQUFNcUIsV0FBVyxHQUFHckIsS0FBSyxDQUFDSSxNQUExQjs7QUFFQSxVQUFJLENBQUNhLFdBQVcsQ0FBQ0csTUFBRCxDQUFoQixFQUEwQjtBQUN4QkgsUUFBQUEsV0FBVyxDQUFDRyxNQUFELENBQVgsR0FBc0IsRUFBdEI7QUFDRDs7QUFFRCxVQUFJLENBQUNILFdBQVcsQ0FBQ0csTUFBRCxDQUFYLENBQW9CQyxXQUFwQixDQUFMLEVBQXVDO0FBQ3JDSixRQUFBQSxXQUFXLENBQUNHLE1BQUQsQ0FBWCxDQUFvQkMsV0FBcEIsSUFBbUMsQ0FBbkM7QUFDRDs7QUFDREosTUFBQUEsV0FBVyxDQUFDRyxNQUFELENBQVgsQ0FBb0JDLFdBQXBCO0FBQ0QsS0FyQkQ7QUFzQkQsR0F2QkQ7QUF5QkEsTUFBTUMsUUFBUSxHQUFHbEMsSUFBSSxDQUFDZ0IsTUFBdEI7QUFDQSxNQUFJbUIsTUFBTSxHQUFHOUIsT0FBTyxDQUFDUyxHQUFSLENBQVksVUFBQ0YsS0FBRCxFQUFRbUIsS0FBUixFQUFrQjtBQUN6QyxRQUFNQyxNQUFNLEdBQUdMLFdBQVcsQ0FBQ0ksS0FBRCxDQUExQjtBQUNBLFFBQU1LLE1BQU0sR0FBR0MsTUFBTSxDQUFDQyxJQUFQLENBQVlWLFNBQVMsQ0FBQ0ksTUFBRCxDQUFyQixFQUErQmhCLE1BQTlDO0FBQ0EsUUFBTXVCLFdBQVcsR0FBR0gsTUFBTSxHQUFHRixRQUE3QjtBQUNBLFFBQU1NLGNBQWMsR0FBSUQsV0FBVyxHQUFHLEdBQXRDO0FBRUEsUUFBTUUsYUFBYSxHQUFHSixNQUFNLENBQUNDLElBQVAsQ0FBWVQsV0FBVyxDQUFDRyxNQUFELENBQXZCLENBQXRCO0FBQ0EsUUFBTVUsbUJBQW1CLEdBQUdELGFBQWEsQ0FBQ3pCLE1BQTFDO0FBQ0EsUUFBTTJCLFlBQVksR0FBSUosV0FBVyxHQUFHLElBQWQsSUFBc0JHLG1CQUFtQixJQUFJLENBQW5FO0FBQ0EsUUFBSUUsUUFBUSxHQUFHLEVBQWY7O0FBRUEsUUFBSUosY0FBSixFQUFvQjtBQUNsQkksTUFBQUEsUUFBUSxHQUFHaEMsS0FBWDtBQUNELEtBRkQsTUFFTyxJQUFJK0IsWUFBSixFQUFrQjtBQUFBLFVBQ2YzQixNQURlLEdBQ0pKLEtBREksQ0FDZkksTUFEZTtBQUV2QixVQUFJNkIsU0FBUyxHQUFHLElBQWhCO0FBQ0EsVUFBSUMsT0FBTyxHQUFHLENBQWQ7QUFDQSxVQUFNQyxNQUFNLEdBQUdWLE1BQU0sQ0FBQ0MsSUFBUCxDQUFZVixTQUFTLENBQUNJLE1BQUQsQ0FBckIsQ0FBZjtBQUNBLFVBQU1nQix3QkFBd0IsR0FBRyxJQUFqQzs7QUFDQSxhQUFRSCxTQUFTLElBQUlDLE9BQU8sR0FBR0Usd0JBQS9CLEVBQTBEO0FBQ3hESixRQUFBQSxRQUFRLEdBQUdLLFFBQVEsQ0FBQztBQUFFakMsVUFBQUEsTUFBTSxFQUFOQTtBQUFGLFNBQUQsQ0FBbkI7QUFDQTZCLFFBQUFBLFNBQVMsR0FBR0UsTUFBTSxDQUFDRyxRQUFQLENBQWdCTixRQUFoQixDQUFaO0FBQ0FFLFFBQUFBLE9BQU87QUFDUjs7QUFDRCxVQUFLQSxPQUFPLElBQUlFLHdCQUFoQixFQUEwQztBQUFDRyxRQUFBQSxPQUFPLENBQUNDLEdBQVIsQ0FBWSwrQkFBK0JKLHdCQUEvQixHQUEwRCxRQUF0RTtBQUFnRjtBQUM1SDs7QUFDRCxXQUFPSixRQUFQO0FBQ0QsR0EzQlksQ0FBYjtBQTRCQSxTQUFPVCxNQUFQO0FBQ0QsQ0E5RE07Ozs7QUFnRUEsSUFBTWtCLGFBQWEsR0FBRyxTQUFoQkEsYUFBZ0IsUUFFdkI7QUFBQSxNQURKQyxVQUNJLFNBREpBLFVBQ0k7QUFBQSxNQURRQyxVQUNSLFNBRFFBLFVBQ1I7QUFBQSxNQURvQkMsbUJBQ3BCLFNBRG9CQSxtQkFDcEI7QUFBQSxNQUR5Q0MsVUFDekMsU0FEeUNBLFVBQ3pDO0FBQ0osTUFBSTVDLElBQUksR0FBRyxFQUFYOztBQUVBLE1BQUl5QyxVQUFVLENBQUMsQ0FBRCxDQUFWLENBQWN0QyxNQUFkLEtBQXlCdUMsVUFBVSxDQUFDLENBQUQsQ0FBVixDQUFjdkMsTUFBM0MsRUFBbUQ7QUFDakQsUUFBSWYsUUFBUSxHQUFHLEVBQWY7QUFFQXNELElBQUFBLFVBQVUsQ0FBQ3pCLE9BQVgsQ0FBbUIsVUFBQTRCLEdBQUcsRUFBSTtBQUN4QixVQUFNQyxZQUFZLEdBQUdILG1CQUFtQixDQUFDMUMsR0FBcEIsQ0FBd0IsVUFBQWlCLEtBQUs7QUFBQSxlQUFJMkIsR0FBRyxDQUFDM0IsS0FBRCxDQUFQO0FBQUEsT0FBN0IsRUFBNkM2QixJQUE3QyxDQUFrRCxHQUFsRCxDQUFyQjtBQUNBM0QsTUFBQUEsUUFBUSxDQUFDMEQsWUFBRCxDQUFSLEdBQXlCO0FBQUVFLFFBQUFBLE1BQU0sRUFBRUg7QUFBVixPQUF6QjtBQUNELEtBSEQ7QUFJQUosSUFBQUEsVUFBVSxDQUFDeEIsT0FBWCxDQUFtQixVQUFBNEIsR0FBRyxFQUFJO0FBQ3hCLFVBQU1DLFlBQVksR0FBR0gsbUJBQW1CLENBQUMxQyxHQUFwQixDQUF3QixVQUFBaUIsS0FBSztBQUFBLGVBQUkyQixHQUFHLENBQUMzQixLQUFELENBQVA7QUFBQSxPQUE3QixFQUE2QzZCLElBQTdDLENBQWtELEdBQWxELENBQXJCLENBRHdCLENBRXhCOztBQUNBM0QsTUFBQUEsUUFBUSxDQUFDMEQsWUFBRCxDQUFSO0FBQTJCRyxRQUFBQSxNQUFNLEVBQUVKO0FBQW5DLFNBQTJDekQsUUFBUSxDQUFDMEQsWUFBRCxDQUFuRDtBQUNELEtBSkQ7QUFNQTlDLElBQUFBLElBQUksR0FBR3dCLE1BQU0sQ0FBQ0QsTUFBUCxDQUFjbkMsUUFBZCxFQUF3QmEsR0FBeEIsQ0FBNEIsVUFBQTRDLEdBQUcsRUFBSTtBQUN4QyxVQUFJdkMsSUFBSjs7QUFFQSxVQUFJdUMsR0FBRyxDQUFDSSxNQUFSLEVBQWdCO0FBQ2QzQyxRQUFBQSxJQUFJLEdBQUd1QyxHQUFHLENBQUNJLE1BQUosQ0FBV2hELEdBQVgsQ0FBZSxVQUFDaUQsVUFBRCxFQUFhaEMsS0FBYjtBQUFBLDJCQUNqQmdDLFVBRGlCLFNBQ0pOLFVBQVUsQ0FBQ08sSUFEUCxTQUNjTixHQUFHLENBQUNHLE1BQUosR0FDaENILEdBQUcsQ0FBQ0csTUFBSixDQUFXOUIsS0FBWCxFQUNDa0MsT0FERCxDQUNTLFVBRFQsRUFDcUIsRUFEckIsRUFFQ0EsT0FGRCxDQUVTLFVBRlQsRUFFb0IsRUFGcEIsQ0FEZ0MsR0FJOUIsRUFMZ0I7QUFBQSxTQUFmLENBQVA7QUFPRCxPQVJELE1BUU87QUFDTDlDLFFBQUFBLElBQUksR0FBR3VDLEdBQUcsQ0FBQ0csTUFBSixDQUFXL0MsR0FBWCxDQUFlLFVBQUNvRCxVQUFELEVBQWFuQyxLQUFiO0FBQUEsMkJBQ2pCMEIsVUFBVSxDQUFDTyxJQURNLFNBQ0NFLFVBQVUsQ0FBQ0QsT0FBWCxDQUFtQixVQUFuQixFQUErQixFQUEvQixFQUFtQ0EsT0FBbkMsQ0FBMkMsVUFBM0MsRUFBc0QsRUFBdEQsQ0FERDtBQUFBLFNBQWYsQ0FBUDtBQUdEOztBQUNELGFBQU85QyxJQUFQO0FBQ0QsS0FqQk0sQ0FBUDtBQWtCRDs7QUFDRCxTQUFPTixJQUFQO0FBQ0QsQ0F0Q007Ozs7QUF3Q0EsSUFBTXNELHVCQUF1QixHQUFHLFNBQTFCQSx1QkFBMEIsUUFFakM7QUFBQSxNQURKQyxhQUNJLFNBREpBLGFBQ0k7QUFBQSxNQURXdkQsSUFDWCxTQURXQSxJQUNYO0FBQUEsTUFEaUI0QyxVQUNqQixTQURpQkEsVUFDakI7QUFDSixNQUFNWSxxQkFBcUIsR0FBRyxFQUE5QjtBQUVBeEQsRUFBQUEsSUFBSSxDQUFDaUIsT0FBTCxDQUFhLFVBQUE0QixHQUFHLEVBQUk7QUFDbEJVLElBQUFBLGFBQWEsQ0FBQ3RDLE9BQWQsQ0FBc0IsVUFBQW5CLFdBQVcsRUFBSTtBQUNuQyxVQUFNeUIsTUFBTSxHQUFHc0IsR0FBRyxDQUFDL0MsV0FBRCxDQUFILENBQWlCMkQsS0FBakIsQ0FBdUJiLFVBQVUsQ0FBQ08sSUFBbEMsQ0FBZjtBQUVBNUIsTUFBQUEsTUFBTSxDQUFDTixPQUFQLENBQWUsVUFBQWxCLEtBQUssRUFBSTtBQUN0QixZQUFJQSxLQUFKLEVBQVc7QUFDVCxjQUFJLENBQUN5RCxxQkFBcUIsQ0FBQzFELFdBQUQsQ0FBMUIsRUFBeUM7QUFDdkMwRCxZQUFBQSxxQkFBcUIsQ0FBQzFELFdBQUQsQ0FBckIsR0FBcUMsRUFBckM7QUFDRDs7QUFFRCxjQUFJLENBQUMwRCxxQkFBcUIsQ0FBQzFELFdBQUQsQ0FBckIsQ0FBbUN1QyxRQUFuQyxDQUE0Q3RDLEtBQTVDLENBQUwsRUFBeUQ7QUFDdkR5RCxZQUFBQSxxQkFBcUIsQ0FBQzFELFdBQUQsQ0FBckIsQ0FBbUNXLElBQW5DLENBQXdDVixLQUF4QztBQUNEO0FBQ0Y7QUFDRixPQVZEO0FBV0QsS0FkRDtBQWVELEdBaEJEO0FBaUJBLFNBQU95RCxxQkFBUDtBQUNELENBdkJNOzs7O0FBeUJBLElBQU1FLGNBQWMsR0FBRyxTQUFqQkEsY0FBaUIsU0FBMkI7QUFBQSxNQUF4QkMsS0FBd0IsVUFBeEJBLEtBQXdCO0FBQUEsTUFBakJmLFVBQWlCLFVBQWpCQSxVQUFpQjtBQUN2RCxNQUFNekQsSUFBSSxHQUFHeUUsU0FBUyxDQUFDO0FBQUVELElBQUFBLEtBQUssRUFBTEEsS0FBRjtBQUFTRSxJQUFBQSxTQUFTLEVBQUVqQixVQUFVLENBQUNDO0FBQS9CLEdBQUQsQ0FBVCxDQUNWNUMsR0FEVSxDQUNOLFVBQUE0QyxHQUFHO0FBQUEsV0FDTmlCLFVBQVUsQ0FBQztBQUFFakIsTUFBQUEsR0FBRyxFQUFIQSxHQUFGO0FBQU9nQixNQUFBQSxTQUFTLEVBQUVqQixVQUFVLENBQUNPO0FBQTdCLEtBQUQsQ0FESjtBQUFBLEdBREcsQ0FBYjtBQUlBLE1BQU1ZLFNBQVMsR0FBRztBQUNoQmpELElBQUFBLFdBQVcsRUFBRWtELGNBQWMsQ0FBQzdFLElBQUQsQ0FEWDtBQUVoQkEsSUFBQUEsSUFBSSxFQUFFOEUsT0FBTyxDQUFDOUUsSUFBRDtBQUZHLEdBQWxCO0FBSUEsU0FBTzRFLFNBQVA7QUFDRCxDQVZNOzs7O0FBWUEsSUFBTUcsU0FBUyxHQUFHLFNBQVpBLFNBQVksU0FFbkI7QUFBQSxNQURKcEQsV0FDSSxVQURKQSxXQUNJO0FBQUEsTUFEUzNCLElBQ1QsVUFEU0EsSUFDVDtBQUFBLE1BRGV5RCxVQUNmLFVBRGVBLFVBQ2Y7QUFDSixNQUFJdUIsTUFBTSxHQUFHLEVBQWI7O0FBRUEsTUFBSXJELFdBQVcsSUFBSTNCLElBQW5CLEVBQXlCO0FBQ3ZCLFFBQUk0RSxTQUFTLElBQUlqRCxXQUFKLDRCQUFvQjNCLElBQXBCLEVBQWI7O0FBQ0EsU0FBSyxJQUFJa0IsQ0FBQyxHQUFDLENBQVgsRUFBY0EsQ0FBQyxHQUFDMEQsU0FBUyxDQUFDNUQsTUFBMUIsRUFBa0NFLENBQUMsRUFBbkMsRUFBdUM7QUFDckMsVUFBSStELFNBQVMsR0FBRyxFQUFoQjs7QUFDQSxXQUFLLElBQUk1RCxDQUFDLEdBQUMsQ0FBWCxFQUFjQSxDQUFDLEdBQUN1RCxTQUFTLENBQUMxRCxDQUFELENBQVQsQ0FBYUYsTUFBN0IsRUFBcUNLLENBQUMsRUFBdEMsRUFBMEM7QUFDeEM0RCxRQUFBQSxTQUFTLElBQUlMLFNBQVMsQ0FBQzFELENBQUQsQ0FBVCxDQUFhRyxDQUFiLEVBQWdCNkQsVUFBaEIsQ0FBMkIsTUFBM0IsRUFBa0MsTUFBbEMsQ0FBYjs7QUFDQSxZQUFLN0QsQ0FBQyxHQUFJdUQsU0FBUyxDQUFDMUQsQ0FBRCxDQUFULENBQWFGLE1BQWIsR0FBc0IsQ0FBaEMsRUFBcUM7QUFBQ2lFLFVBQUFBLFNBQVMsSUFBSXhCLFVBQVUsQ0FBQ08sSUFBeEI7QUFBNkI7O0FBQUE7QUFDcEU7O0FBQ0RnQixNQUFBQSxNQUFNLElBQUlDLFNBQVY7QUFDQUQsTUFBQUEsTUFBTSxJQUFJdkIsVUFBVSxDQUFDQyxHQUFyQjtBQUNELEtBVnNCLENBV3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDRDs7QUFDRCxTQUFPc0IsTUFBUDtBQUNELENBeEJNOzs7O0FBMEJBLElBQU1ILGNBQWMsR0FBRyxTQUFqQkEsY0FBaUIsQ0FBQzdFLElBQUQ7QUFBQSxTQUFVQSxJQUFJLENBQUMsQ0FBRCxDQUFkO0FBQUEsQ0FBdkI7Ozs7QUFDQSxJQUFNOEUsT0FBTyxHQUFHLFNBQVZBLE9BQVUsQ0FBQzlFLElBQUQ7QUFBQSxTQUFVQSxJQUFJLENBQUNtRixLQUFMLENBQVcsQ0FBWCxDQUFWO0FBQUEsQ0FBaEI7Ozs7QUFFQSxJQUFNVixTQUFTLEdBQUcsU0FBWkEsU0FBWTtBQUFBLE1BQUdELEtBQUgsVUFBR0EsS0FBSDtBQUFBLE1BQVVFLFNBQVYsVUFBVUEsU0FBVjtBQUFBLFNBQTBCRixLQUFLLENBQUNGLEtBQU4sQ0FBWUksU0FBWixFQUF1QmxELE1BQXZCLENBQThCLFVBQUFrQyxHQUFHO0FBQUEsV0FBSUEsR0FBRyxLQUFLLEVBQVo7QUFBQSxHQUFqQyxDQUExQjtBQUFBLENBQWxCOzs7O0FBQ0EsSUFBTWlCLFVBQVUsR0FBRyxTQUFiQSxVQUFhO0FBQUEsTUFBR2pCLEdBQUgsVUFBR0EsR0FBSDtBQUFBLE1BQVFnQixTQUFSLFVBQVFBLFNBQVI7QUFBQSxTQUF3QmhCLEdBQUcsQ0FBQ1ksS0FBSixDQUFVSSxTQUFWLENBQXhCO0FBQUEsQ0FBbkIsQyxDQUVQO0FBRUE7Ozs7O0FBQ0EsSUFBTXpCLFFBQVEsR0FBRyxTQUFYQSxRQUFXLFNBQWdCO0FBQUEsTUFBYmpDLE1BQWEsVUFBYkEsTUFBYTtBQUMvQjtBQUNBLE1BQU1vRSxPQUFPLEdBQUcsQ0FBQyxHQUFELEVBQU0sR0FBTixFQUFXLEdBQVgsRUFBZ0IsR0FBaEIsRUFBcUIsR0FBckIsRUFBMEIsR0FBMUIsRUFBK0IsR0FBL0IsRUFDZCxHQURjLEVBQ1QsR0FEUyxFQUNKLEdBREksRUFDQyxHQURELEVBQ00sR0FETixFQUNXLEdBRFgsRUFDZ0IsR0FEaEIsRUFDcUIsR0FEckIsRUFDMEIsR0FEMUIsRUFDK0IsR0FEL0IsRUFFZCxHQUZjLEVBRVQsR0FGUyxFQUVKLEdBRkksRUFFQyxHQUZELEVBRU0sR0FGTixFQUVXLEdBRlgsRUFFZ0IsR0FGaEIsRUFFcUIsR0FGckIsRUFFMEIsR0FGMUIsQ0FBaEI7QUFJQSxNQUFNQyxNQUFNLEdBQUdDLElBQUksQ0FBQ0MsS0FBTCxDQUFXRCxJQUFJLENBQUNELE1BQUwsS0FBZ0JELE9BQU8sQ0FBQ3BFLE1BQW5DLENBQWY7QUFDQSxNQUFNd0UsTUFBTSxHQUFHRixJQUFJLENBQUNELE1BQUwsRUFBZixDQVArQixDQU9EO0FBRTlCOztBQUNBLE1BQUlyRSxNQUFNLEdBQUcsQ0FBYixFQUFnQjtBQUNkQSxJQUFBQSxNQUFNLEdBQUcsQ0FBVDtBQUNEOztBQUVELE1BQU15RSxFQUFFLEdBQUdMLE9BQU8sQ0FBQ0MsTUFBRCxDQUFQLEdBQWtCRyxNQUFNLENBQUNFLFFBQVAsQ0FBZ0IsRUFBaEIsRUFBb0JDLE1BQXBCLENBQTJCLENBQTNCLEVBQThCM0UsTUFBTSxHQUFDLENBQXJDLENBQTdCLENBZCtCLENBY3VDOztBQUN0RSxTQUFPeUUsRUFBUDtBQUNELENBaEJEOztBQWtCQSxJQUFNdkYsU0FBUyxHQUFHLFNBQVpBLFNBQVksQ0FBQzBGLEtBQUQsRUFBUUMsUUFBUixFQUFrQkMsUUFBbEIsRUFBK0I7QUFDL0MsTUFBSUMsTUFBTSxzQkFBT0gsS0FBUCxDQUFWOztBQUNBLE1BQU1JLE1BQU0sR0FBSUYsUUFBUSxHQUFHLENBQTNCO0FBQ0EsTUFBTUcsT0FBTyxHQUFJSCxRQUFRLEdBQUdGLEtBQUssQ0FBQzVFLE1BQU4sR0FBZSxDQUEzQzs7QUFFQSxNQUFJLENBQUNnRixNQUFELElBQVcsQ0FBQ0MsT0FBaEIsRUFBeUI7QUFDdkIsUUFBSUMsT0FBTyxHQUFHSCxNQUFNLENBQUNGLFFBQUQsQ0FBcEI7O0FBQ0FFLElBQUFBLE1BQU0sQ0FBQ3hGLE1BQVAsQ0FBY3NGLFFBQWQsRUFBd0IsQ0FBeEI7O0FBQ0FFLElBQUFBLE1BQU0sQ0FBQ3hGLE1BQVAsQ0FBY3VGLFFBQWQsRUFBd0IsQ0FBeEIsRUFBMkJJLE9BQTNCO0FBQ0Q7O0FBQ0QsU0FBT0gsTUFBUDtBQUNELENBWEQ7O0FBYU8sSUFBTUksYUFBYSxHQUFHLFNBQWhCQSxhQUFnQixDQUFDQyxhQUFELEVBQWdCL0YsT0FBaEIsRUFBeUJnRyxRQUF6QixFQUFzQztBQUNqRSxNQUFNWixFQUFFLEdBQUdXLGFBQWEsQ0FBQy9GLE9BQUQsQ0FBeEI7QUFDQSxNQUFNaUcsYUFBYSxHQUFHQyxRQUFRLENBQUNDLGNBQVQsQ0FBd0JmLEVBQXhCLENBQXRCO0FBQ0EsTUFBTWdCLHFCQUFxQixHQUFHQyxxQkFBcUIsQ0FBQ0osYUFBRCxFQUFnQixhQUFoQixFQUErQkQsUUFBL0IsQ0FBbkQ7QUFDQSxTQUFPSSxxQkFBUDtBQUNELENBTE07Ozs7QUFPUCxTQUFTQyxxQkFBVCxDQUErQkMsR0FBL0IsRUFBb0NDLFNBQXBDLEVBQStDUCxRQUEvQyxFQUF5RDtBQUN2RCxNQUFNUSxZQUFZLEdBQUd6RixLQUFLLENBQUMwRixJQUFOLENBQVdQLFFBQVEsQ0FBQ1EsZ0JBQVQsQ0FBMEJILFNBQTFCLENBQVgsQ0FBckI7QUFDQSxNQUFNSSxxQkFBcUIsR0FBR0gsWUFBWSxDQUFDSSxPQUFiLENBQXFCTixHQUFyQixDQUE5QjtBQUNBLFNBQU9FLFlBQVksQ0FBQ0cscUJBQXFCLEdBQUdYLFFBQXpCLENBQW5CO0FBQ0Q7O0FBRU0sU0FBU2EsU0FBVCxDQUFtQmhCLE9BQW5CLEVBQTRCO0FBQ2pDLE1BQUlpQixJQUFKLEVBQVVDLEdBQVY7O0FBRUEsTUFBSyxDQUFDbEIsT0FBTixFQUFnQjtBQUNkO0FBQ0QsR0FMZ0MsQ0FPakM7QUFDQTtBQUNBO0FBQ0E7OztBQUNBLE1BQUssQ0FBQ0EsT0FBTyxDQUFDbUIsY0FBUixHQUF5QnJHLE1BQS9CLEVBQXdDO0FBQ3RDLFdBQU87QUFBRXNHLE1BQUFBLEdBQUcsRUFBRSxDQUFQO0FBQVVDLE1BQUFBLElBQUksRUFBRTtBQUFoQixLQUFQO0FBQ0QsR0FiZ0MsQ0FlakM7OztBQUNBSixFQUFBQSxJQUFJLEdBQUdqQixPQUFPLENBQUNzQixxQkFBUixFQUFQO0FBQ0FKLEVBQUFBLEdBQUcsR0FBR2xCLE9BQU8sQ0FBQ3VCLGFBQVIsQ0FBc0JDLFdBQTVCO0FBQ0EsU0FBTztBQUNMSixJQUFBQSxHQUFHLEVBQUVILElBQUksQ0FBQ0csR0FBTCxHQUFXRixHQUFHLENBQUNPLFdBRGY7QUFFTEosSUFBQUEsSUFBSSxFQUFFSixJQUFJLENBQUNJLElBQUwsR0FBWUgsR0FBRyxDQUFDUTtBQUZqQixHQUFQO0FBSUQiLCJzb3VyY2VzQ29udGVudCI6WyJcclxuZXhwb3J0IGNvbnN0IHJvd01vdmVBYm92ZSA9ICh7IHJvd3MsIHJvd0luZGV4IH0pID0+IGFycmF5TW92ZShyb3dzLCByb3dJbmRleCwgcm93SW5kZXggLSAxKTtcclxuZXhwb3J0IGNvbnN0IHJvd01vdmVCZWxvdyA9ICh7IHJvd3MsIHJvd0luZGV4IH0pID0+IGFycmF5TW92ZShyb3dzLCByb3dJbmRleCwgcm93SW5kZXggKyAxKTtcclxuZXhwb3J0IGNvbnN0IHJvd0FkZEFib3ZlID0gKHtcclxuICByb3dzLCByb3dJbmRleCwgcm93RGF0YSxcclxufSkgPT4ge1xyXG4gIGxldCBfcm93cyA9IFsuLi5yb3dzXTtcclxuICBfcm93cy5zcGxpY2Uocm93SW5kZXggLSAxLCAwLCByb3dEYXRhKTtcclxuICByZXR1cm4gX3Jvd3M7XHJcbn07XHJcbmV4cG9ydCBjb25zdCByb3dBZGRCZWxvdyA9ICh7XHJcbiAgcm93cywgcm93SW5kZXgsIHJvd0RhdGEsXHJcbn0pID0+IHtcclxuICBsZXQgX3Jvd3MgPSBbLi4ucm93c107XHJcbiAgX3Jvd3Muc3BsaWNlKHJvd0luZGV4ICsgMSwgMCwgcm93RGF0YSk7XHJcbiAgcmV0dXJuIF9yb3dzO1xyXG59O1xyXG5leHBvcnQgY29uc3Qgcm93RGVsZXRlID0gKHsgcm93cywgcm93SW5kZXggfSkgPT4ge1xyXG4gIGxldCBfcm93cyA9IFsuLi5yb3dzXTtcclxuICBfcm93cy5zcGxpY2Uocm93SW5kZXgsIDEpO1xyXG4gIHJldHVybiBfcm93cztcclxufTtcclxuZXhwb3J0IGNvbnN0IGNlbGxFZGl0ID0gKHtcclxuICByb3dzLCByb3dJbmRleCwgY29sdW1uSW5kZXgsIHZhbHVlLCBkYXRhLFxyXG59KSA9PiB7XHJcbiAgbGV0IF9yb3dzID0gcm93cy5tYXAoY2VsbHMgPT4gWy4uLmNlbGxzXSk7XHJcbiAgLy8gaWYgcm93IGluZGV4IHBvaW50cyBiZXlvbmQgZW5kIG9mIGFycmF5LCBcclxuICAvLyB0aGVuIGFkZCBhcyBtYW55IGVtcHR5IHJvd3MgYXMgbmVlZGVkIHRvIFxyXG4gIC8vIG1ha2UgaXQgYSB2YWxpZCwgZXZlbiBpZiBlbXB0eSByb3dcclxuICBpZiAoIHJvd0luZGV4ID49IHJvd3MubGVuZ3RoIHx8IHJvd3Nbcm93SW5kZXhdID09PSB1bmRlZmluZWQgKSB7XHJcbiAgICAvL2NvbnNvbGUubG9nKFwiVW5kbyBkZWxldGUgcHJvY2VzcyBiZWdpbnNcIilcclxuICAgIC8vY29uc29sZS5sb2coXCJbZGF0YXRhYmxlLmpzXSBjZWxsRWRpdCgpIG51bWJlciBvZiByb3c9XCIsIHJvd3MubGVuZ3RoLCBcIiByb3dJbmRleD1cIiwgcm93SW5kZXgsIFwiIHJvd3Nbcm93SW5kZXhdXCIsIHJvd3Nbcm93SW5kZXhdKTtcclxuICAgIGZvciAobGV0IGk9LTE7IGkgPCAocm93SW5kZXggLSByb3dzLmxlbmd0aCk7IGkrKykge1xyXG4gICAgICBsZXQgX3JvdyA9IG5ldyBBcnJheShyb3dzWzBdLmxlbmd0aCk7XHJcbiAgICAgIC8vIHNldCBlYWNoIGNlbGwgaW4gbmV3IHJvdyB0byBiZSBlbXB0eSBzdHJpbmdcclxuICAgICAgZm9yIChsZXQgaj0wOyBqIDwgX3Jvdy5sZW5ndGg7IGorKykge1xyXG4gICAgICAgIC8vX3Jvd1tqXSA9IFwiXCI7XHJcbiAgICAgIH1cclxuICAgICAgX3Jvd3MucHVzaCggX3JvdyApO1xyXG4gICAgfVxyXG4gICAgLy8gbm93IGRvIGFuIFwidW5kb1wiIGJ5IGZpbGxpbmcgaW4gdmFsdWVzIGZyb20gc291cmNlXHJcbiAgICBmb3IgKGxldCBpPTA7IGkgPCBfcm93c1tyb3dJbmRleF0ubGVuZ3RoOyBpKyspIHtcclxuICAgICAgX3Jvd3Nbcm93SW5kZXhdW2ldID0gZGF0YVtyb3dJbmRleF1baV0udHJpbSgpO1xyXG4gICAgfVxyXG4gICAgLy9jb25zb2xlLmxvZyhcIlVuZG8gZGVsZXRlIHByb2Nlc3MgZW5kc1wiKVxyXG4gIH1cclxuICBcclxuICBfcm93c1tyb3dJbmRleF1bY29sdW1uSW5kZXhdID0gdmFsdWU7XHJcbiAgLy9jb25zb2xlLmxvZyhcIl9yb3dzIGJlZm9yZSBmaWx0ZXI6XCIsIF9yb3dzKTtcclxuICAvLyBuZXh0IHJlbW92ZSBhbnkgZW1wdHkgcm93cyBjcmVhdGVkIGJ5IHRoZSB1bmRvIGRlbGV0ZSBwcm9jZXNzXHJcbiAgX3Jvd3MgPSBfcm93cy5maWx0ZXIoIGFyb3cgPT4gYXJvd1swXSAhPT0gdW5kZWZpbmVkICk7XHJcbiAgLy9jb25zb2xlLmxvZyhcIl9yb3dzIGFmdGVyIGZpbHRlcjpcIiwgX3Jvd3MpO1xyXG5cclxuICByZXR1cm4gX3Jvd3M7XHJcbn07XHJcblxyXG5leHBvcnQgY29uc3Qgcm93R2VuZXJhdGUgPSAoe1xyXG4gIHJvd3MsIGNvbHVtbk5hbWVzLCByb3dJbmRleCxcclxufSkgPT4ge1xyXG4gIGxldCByb3dzSW5kZXggPSB7fTtcclxuICBsZXQgbGVuZ3RoSW5kZXggPSB7fTtcclxuICBjb25zdCByb3dEYXRhID0gcm93c1tyb3dJbmRleF07XHJcblxyXG4gIHJvd3MuZm9yRWFjaChfcm93ID0+IHtcclxuICAgIF9yb3cuZm9yRWFjaCgodmFsdWUsIGluZGV4KSA9PiB7XHJcbiAgICAgIGNvbnN0IGNvbHVtbiA9IGNvbHVtbk5hbWVzW2luZGV4XTtcclxuXHJcbiAgICAgIGlmICghcm93c0luZGV4W2NvbHVtbl0pIHtcclxuICAgICAgICByb3dzSW5kZXhbY29sdW1uXSA9IHt9O1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoIXJvd3NJbmRleFtjb2x1bW5dW3ZhbHVlXSkge1xyXG4gICAgICAgIHJvd3NJbmRleFtjb2x1bW5dW3ZhbHVlXSA9IDA7XHJcbiAgICAgIH1cclxuICAgICAgcm93c0luZGV4W2NvbHVtbl1bdmFsdWVdKys7XHJcbiAgICAgIGNvbnN0IHZhbHVlTGVuZ3RoID0gdmFsdWUubGVuZ3RoO1xyXG5cclxuICAgICAgaWYgKCFsZW5ndGhJbmRleFtjb2x1bW5dKSB7XHJcbiAgICAgICAgbGVuZ3RoSW5kZXhbY29sdW1uXSA9IHt9O1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoIWxlbmd0aEluZGV4W2NvbHVtbl1bdmFsdWVMZW5ndGhdKSB7XHJcbiAgICAgICAgbGVuZ3RoSW5kZXhbY29sdW1uXVt2YWx1ZUxlbmd0aF0gPSAwO1xyXG4gICAgICB9XHJcbiAgICAgIGxlbmd0aEluZGV4W2NvbHVtbl1bdmFsdWVMZW5ndGhdKys7XHJcbiAgICB9KTtcclxuICB9KTtcclxuXHJcbiAgY29uc3Qgcm93Q291bnQgPSByb3dzLmxlbmd0aDtcclxuICBsZXQgbmV3Um93ID0gcm93RGF0YS5tYXAoKHZhbHVlLCBpbmRleCkgPT4ge1xyXG4gICAgY29uc3QgY29sdW1uID0gY29sdW1uTmFtZXNbaW5kZXhdO1xyXG4gICAgY29uc3QgdmFsdWVzID0gT2JqZWN0LmtleXMocm93c0luZGV4W2NvbHVtbl0pLmxlbmd0aDtcclxuICAgIGNvbnN0IHZhbHVlc1JhdGlvID0gdmFsdWVzIC8gcm93Q291bnQ7XHJcbiAgICBjb25zdCBkdXBsaWNhdGVWYWx1ZSA9ICh2YWx1ZXNSYXRpbyA8IDAuNSk7XHJcblxyXG4gICAgY29uc3QgdmFsdWVzTGVuZ3RocyA9IE9iamVjdC5rZXlzKGxlbmd0aEluZGV4W2NvbHVtbl0pO1xyXG4gICAgY29uc3QgdmFsdWVzTGVuZ3Roc0xlbmd0aCA9IHZhbHVlc0xlbmd0aHMubGVuZ3RoO1xyXG4gICAgY29uc3QgbmVlZFJhbmRvbUlkID0gKHZhbHVlc1JhdGlvID4gMC45OSAmJiB2YWx1ZXNMZW5ndGhzTGVuZ3RoIDw9IDIpO1xyXG4gICAgbGV0IG5ld1ZhbHVlID0gJyc7XHJcblxyXG4gICAgaWYgKGR1cGxpY2F0ZVZhbHVlKSB7XHJcbiAgICAgIG5ld1ZhbHVlID0gdmFsdWU7XHJcbiAgICB9IGVsc2UgaWYgKG5lZWRSYW5kb21JZCkge1xyXG4gICAgICBjb25zdCB7IGxlbmd0aCB9ID0gdmFsdWU7XHJcbiAgICAgIGxldCBub3RVbmlxdWUgPSB0cnVlO1xyXG4gICAgICBsZXQgY291bnRlciA9IDA7XHJcbiAgICAgIGNvbnN0IGFsbElkcyA9IE9iamVjdC5rZXlzKHJvd3NJbmRleFtjb2x1bW5dKTtcclxuICAgICAgY29uc3QgVU5JUVVFX0NPVU5URVJfVEhSRVNIT0xEID0gMTAwMDtcclxuICAgICAgd2hpbGUgKCBub3RVbmlxdWUgJiYgY291bnRlciA8IFVOSVFVRV9DT1VOVEVSX1RIUkVTSE9MRCApIHtcclxuICAgICAgICBuZXdWYWx1ZSA9IHJhbmRvbUlkKHsgbGVuZ3RoIH0pO1xyXG4gICAgICAgIG5vdFVuaXF1ZSA9IGFsbElkcy5pbmNsdWRlcyhuZXdWYWx1ZSk7XHJcbiAgICAgICAgY291bnRlcisrO1xyXG4gICAgICB9XHJcbiAgICAgIGlmICggY291bnRlciA+PSBVTklRVUVfQ09VTlRFUl9USFJFU0hPTEQpIHtjb25zb2xlLmxvZyhcIkR1cGxpY2F0ZSBJRHMgZm91bmQgYWZ0ZXIgXCIgKyBVTklRVUVfQ09VTlRFUl9USFJFU0hPTEQgKyBcIiB0cmllc1wiKX1cclxuICAgIH1cclxuICAgIHJldHVybiBuZXdWYWx1ZTtcclxuICB9KTtcclxuICByZXR1cm4gbmV3Um93O1xyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IGNvcnJlbGF0ZURhdGEgPSAoe1xyXG4gIHNvdXJjZVJvd3MsIHRhcmdldFJvd3MsIGNvbXBvc2l0ZUtleUluZGljZXMsIGRlbGltaXRlcnMsXHJcbn0pID0+IHtcclxuICBsZXQgZGF0YSA9IFtdO1xyXG5cclxuICBpZiAoc291cmNlUm93c1swXS5sZW5ndGggPT09IHRhcmdldFJvd3NbMF0ubGVuZ3RoKSB7XHJcbiAgICBsZXQgcm93SW5kZXggPSB7fTtcclxuXHJcbiAgICB0YXJnZXRSb3dzLmZvckVhY2gocm93ID0+IHtcclxuICAgICAgY29uc3QgY29tcG9zaXRlS2V5ID0gY29tcG9zaXRlS2V5SW5kaWNlcy5tYXAoaW5kZXggPT4gcm93W2luZGV4XSkuam9pbignOicpO1xyXG4gICAgICByb3dJbmRleFtjb21wb3NpdGVLZXldID0geyB0YXJnZXQ6IHJvdyB9O1xyXG4gICAgfSk7XHJcbiAgICBzb3VyY2VSb3dzLmZvckVhY2gocm93ID0+IHtcclxuICAgICAgY29uc3QgY29tcG9zaXRlS2V5ID0gY29tcG9zaXRlS2V5SW5kaWNlcy5tYXAoaW5kZXggPT4gcm93W2luZGV4XSkuam9pbignOicpO1xyXG4gICAgICAvLyByb3dJbmRleFtjb21wb3NpdGVLZXldID0gcm93SW5kZXhbY29tcG9zaXRlS2V5XSB8fCB7fTtcclxuICAgICAgcm93SW5kZXhbY29tcG9zaXRlS2V5XSA9IHsgc291cmNlOiByb3csIC4uLnJvd0luZGV4W2NvbXBvc2l0ZUtleV0gfTtcclxuICAgIH0pO1xyXG5cclxuICAgIGRhdGEgPSBPYmplY3QudmFsdWVzKHJvd0luZGV4KS5tYXAocm93ID0+IHtcclxuICAgICAgbGV0IF9yb3c7XHJcblxyXG4gICAgICBpZiAocm93LnNvdXJjZSkge1xyXG4gICAgICAgIF9yb3cgPSByb3cuc291cmNlLm1hcCgoc291cmNlQ2VsbCwgaW5kZXgpID0+XHJcbiAgICAgICAgICBgJHtzb3VyY2VDZWxsfSR7ZGVsaW1pdGVycy5jZWxsfSR7cm93LnRhcmdldCA/IFxyXG4gICAgICAgICAgICByb3cudGFyZ2V0W2luZGV4XVxyXG4gICAgICAgICAgICAucmVwbGFjZSgvXlxcdTIwMEIrLywgJycpXHJcbiAgICAgICAgICAgIC5yZXBsYWNlKC9cXHUyMDBCKyQvLCcnKSBcclxuICAgICAgICAgICAgOiAnJ31gLFxyXG4gICAgICAgICk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgX3JvdyA9IHJvdy50YXJnZXQubWFwKCh0YXJnZXRDZWxsLCBpbmRleCkgPT5cclxuICAgICAgICAgIGAke2RlbGltaXRlcnMuY2VsbH0ke3RhcmdldENlbGwucmVwbGFjZSgvXlxcdTIwMEIrLywgJycpLnJlcGxhY2UoL1xcdTIwMEIrJC8sJycpfWAsXHJcbiAgICAgICAgKTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gX3JvdztcclxuICAgIH0pO1xyXG4gIH1cclxuICByZXR1cm4gZGF0YTtcclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCBnZXRDb2x1bW5zRmlsdGVyT3B0aW9ucyA9ICh7XHJcbiAgY29sdW1uSW5kaWNlcywgZGF0YSwgZGVsaW1pdGVycyxcclxufSkgPT4ge1xyXG4gIGNvbnN0IF9jb2x1bW5zRmlsdGVyT3B0aW9ucyA9IFtdO1xyXG5cclxuICBkYXRhLmZvckVhY2gocm93ID0+IHtcclxuICAgIGNvbHVtbkluZGljZXMuZm9yRWFjaChjb2x1bW5JbmRleCA9PiB7XHJcbiAgICAgIGNvbnN0IHZhbHVlcyA9IHJvd1tjb2x1bW5JbmRleF0uc3BsaXQoZGVsaW1pdGVycy5jZWxsKTtcclxuXHJcbiAgICAgIHZhbHVlcy5mb3JFYWNoKHZhbHVlID0+IHtcclxuICAgICAgICBpZiAodmFsdWUpIHtcclxuICAgICAgICAgIGlmICghX2NvbHVtbnNGaWx0ZXJPcHRpb25zW2NvbHVtbkluZGV4XSkge1xyXG4gICAgICAgICAgICBfY29sdW1uc0ZpbHRlck9wdGlvbnNbY29sdW1uSW5kZXhdID0gW107XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgaWYgKCFfY29sdW1uc0ZpbHRlck9wdGlvbnNbY29sdW1uSW5kZXhdLmluY2x1ZGVzKHZhbHVlKSkge1xyXG4gICAgICAgICAgICBfY29sdW1uc0ZpbHRlck9wdGlvbnNbY29sdW1uSW5kZXhdLnB1c2godmFsdWUpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICB9KTtcclxuICB9KTtcclxuICByZXR1cm4gX2NvbHVtbnNGaWx0ZXJPcHRpb25zO1xyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IHBhcnNlRGF0YVRhYmxlID0gKHsgdGFibGUsIGRlbGltaXRlcnMgfSkgPT4ge1xyXG4gIGNvbnN0IHJvd3MgPSBwYXJzZVJvd3MoeyB0YWJsZSwgZGVsaW1pdGVyOiBkZWxpbWl0ZXJzLnJvdyB9KVxyXG4gICAgLm1hcChyb3cgPT5cclxuICAgICAgcGFyc2VDZWxscyh7IHJvdywgZGVsaW1pdGVyOiBkZWxpbWl0ZXJzLmNlbGwgfSksXHJcbiAgICApO1xyXG4gIGNvbnN0IGRhdGFUYWJsZSA9IHtcclxuICAgIGNvbHVtbk5hbWVzOiBnZXRDb2x1bW5OYW1lcyhyb3dzKSxcclxuICAgIHJvd3M6IGdldFJvd3Mocm93cyksXHJcbiAgfTtcclxuICByZXR1cm4gZGF0YVRhYmxlO1xyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IHN0cmluZ2lmeSA9ICh7XHJcbiAgY29sdW1uTmFtZXMsIHJvd3MsIGRlbGltaXRlcnMsXHJcbn0pID0+IHtcclxuICBsZXQgc3RyaW5nID0gJyc7XHJcblxyXG4gIGlmIChjb2x1bW5OYW1lcyAmJiByb3dzKSB7XHJcbiAgICBsZXQgZGF0YVRhYmxlID0gW2NvbHVtbk5hbWVzLCAuLi5yb3dzXTtcclxuICAgIGZvciAobGV0IGk9MDsgaTxkYXRhVGFibGUubGVuZ3RoOyBpKyspIHtcclxuICAgICAgbGV0IHJvd3N0cmluZyA9ICcnO1xyXG4gICAgICBmb3IgKGxldCBqPTA7IGo8ZGF0YVRhYmxlW2ldLmxlbmd0aDsgaisrKSB7XHJcbiAgICAgICAgcm93c3RyaW5nICs9IGRhdGFUYWJsZVtpXVtqXS5yZXBsYWNlQWxsKC9cXG4vZ2ksJzxicj4nKTtcclxuICAgICAgICBpZiAoIGogPCAoZGF0YVRhYmxlW2ldLmxlbmd0aCAtIDEpICkge3Jvd3N0cmluZyArPSBkZWxpbWl0ZXJzLmNlbGx9O1xyXG4gICAgICB9XHJcbiAgICAgIHN0cmluZyArPSByb3dzdHJpbmc7XHJcbiAgICAgIHN0cmluZyArPSBkZWxpbWl0ZXJzLnJvdztcclxuICAgIH1cclxuICAgIC8vIFRoZSBiZWxvdyBpcyBjb21tZW50ZWQgb3V0IGFuZCByZXBsYWNlZCB3aXRoIHRoZSAyZCBmb3IgbG9vcCBhYm92ZS5cclxuICAgIC8vIFRoaXMgaXMgbmVlZGVkIGluIG9yZGVyIHRvIG9ubHkgYXBwbHkgdGhlIG91dHB1dEZpbHRlciB0byBtYWtlIG5ld2xpbmVzIFxyXG4gICAgLy8gaW50byA8YnI+IGVsZW1lbnRzIHdoZW4gbm8gcGFyc2VyIGlzIHByb3ZpZGVkIHRvIHRoZSBjb21wb25lbnQuIFxyXG4gICAgLy8gVGhpcyBtYWtlcyB1cCBmb3IgdGhlIHVuY29uZGl0aW9uYWwgcmVtb3ZhbCBcclxuICAgIC8vIGZyb20gdGhlIGRhdGF0YWJsZSBvdXRwdXRmaWx0ZXIgc3BlY2lmaWVkIGluIENlbGwuanNcclxuICAgIC8vc3RyaW5nID0gZGF0YVRhYmxlLm1hcChjZWxscyA9PiBjZWxscy5qb2luKGRlbGltaXRlcnMuY2VsbCkpLmpvaW4oZGVsaW1pdGVycy5yb3cpO1xyXG4gIH1cclxuICByZXR1cm4gc3RyaW5nO1xyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IGdldENvbHVtbk5hbWVzID0gKHJvd3MpID0+IHJvd3NbMF07XHJcbmV4cG9ydCBjb25zdCBnZXRSb3dzID0gKHJvd3MpID0+IHJvd3Muc2xpY2UoMSk7XHJcblxyXG5leHBvcnQgY29uc3QgcGFyc2VSb3dzID0gKHsgdGFibGUsIGRlbGltaXRlciB9KSA9PiB0YWJsZS5zcGxpdChkZWxpbWl0ZXIpLmZpbHRlcihyb3cgPT4gcm93ICE9PSAnJyk7XHJcbmV4cG9ydCBjb25zdCBwYXJzZUNlbGxzID0gKHsgcm93LCBkZWxpbWl0ZXIgfSkgPT4gcm93LnNwbGl0KGRlbGltaXRlcik7XHJcblxyXG4vLyBQcml2YXRlXHJcblxyXG4vLyBpZHMgbXVzdCBiZWdpbiB3aXRoIGEgbGV0dGVyXHJcbmNvbnN0IHJhbmRvbUlkID0gKHsgbGVuZ3RoIH0pID0+IHtcclxuICAvLyBnZXQgdGhlIGluaXRpYWwgbGV0dGVyIGZpcnN0XHJcbiAgY29uc3QgbGV0dGVycyA9IFtcImFcIiwgXCJiXCIsIFwiY1wiLCBcImRcIiwgXCJlXCIsIFwiZlwiLCBcImdcIixcclxuICAgIFwiaFwiLCBcImlcIiwgXCJqXCIsIFwia1wiLCBcImxcIiwgXCJtXCIsIFwiblwiLCBcIm9cIiwgXCJwXCIsIFwicVwiLFxyXG4gICAgXCJyXCIsIFwic1wiLCBcInRcIiwgXCJ1XCIsIFwidlwiLCBcIndcIiwgXCJ4XCIsIFwieVwiLCBcInpcIlxyXG4gIF07XHJcbiAgY29uc3QgcmFuZG9tID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogbGV0dGVycy5sZW5ndGgpO1xyXG4gIGNvbnN0IG51bWJlciA9IE1hdGgucmFuZG9tKCk7IC8vIDAuOTM5NDQ1Njg1Nzk4MTY1MVxyXG5cclxuICAvLyBudW1iZXIudG9TdHJpbmcoMzYpOyAvLyAnMC54dGlzMDZoNidcclxuICBpZiAobGVuZ3RoID4gOSkge1xyXG4gICAgbGVuZ3RoID0gOTtcclxuICB9XHJcblxyXG4gIGNvbnN0IGlkID0gbGV0dGVyc1tyYW5kb21dICsgbnVtYmVyLnRvU3RyaW5nKDM2KS5zdWJzdHIoMiwgbGVuZ3RoLTEpOyAvLyAneHRpczA2aDYnXHJcbiAgcmV0dXJuIGlkO1xyXG59O1xyXG5cclxuY29uc3QgYXJyYXlNb3ZlID0gKGFycmF5LCBvbGRJbmRleCwgbmV3SW5kZXgpID0+IHtcclxuICBsZXQgX2FycmF5ID0gWy4uLmFycmF5XTtcclxuICBjb25zdCB0b29Mb3cgPSAobmV3SW5kZXggPCAwKTtcclxuICBjb25zdCB0b29IaWdoID0gKG5ld0luZGV4ID4gYXJyYXkubGVuZ3RoIC0gMSk7XHJcblxyXG4gIGlmICghdG9vTG93ICYmICF0b29IaWdoKSB7XHJcbiAgICB2YXIgZWxlbWVudCA9IF9hcnJheVtvbGRJbmRleF07XHJcbiAgICBfYXJyYXkuc3BsaWNlKG9sZEluZGV4LCAxKTtcclxuICAgIF9hcnJheS5zcGxpY2UobmV3SW5kZXgsIDAsIGVsZW1lbnQpO1xyXG4gIH1cclxuICByZXR1cm4gX2FycmF5O1xyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IGdldFJvd0VsZW1lbnQgPSAoZ2VuZXJhdGVSb3dJZCwgcm93RGF0YSwgcG9zaXRpb24pID0+IHtcclxuICBjb25zdCBpZCA9IGdlbmVyYXRlUm93SWQocm93RGF0YSk7XHJcbiAgY29uc3QgY3VycmVudEhlYWRlciA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGlkKTtcclxuICBjb25zdCBwcmV2aW91c1NpYmxpbmdIZWFkZXIgPSBnZXRTaWJsaW5nQnlDbGFzc05hbWUoY3VycmVudEhlYWRlciwgJy5oZWFkZXItcm93JywgcG9zaXRpb24pO1xyXG4gIHJldHVybiBwcmV2aW91c1NpYmxpbmdIZWFkZXI7XHJcbn07XHJcblxyXG5mdW5jdGlvbiBnZXRTaWJsaW5nQnlDbGFzc05hbWUoZGl2LCBjbGFzc05hbWUsIHBvc2l0aW9uKSB7XHJcbiAgY29uc3QgYWxsSW5zdGFuY2VzID0gQXJyYXkuZnJvbShkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKGNsYXNzTmFtZSkpO1xyXG4gIGNvbnN0IGluZGV4T2ZDdXJyZW50RWxlbWVudCA9IGFsbEluc3RhbmNlcy5pbmRleE9mKGRpdik7XHJcbiAgcmV0dXJuIGFsbEluc3RhbmNlc1tpbmRleE9mQ3VycmVudEVsZW1lbnQgKyBwb3NpdGlvbl07XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRPZmZzZXQoZWxlbWVudCkge1xyXG4gIHZhciByZWN0LCB3aW47XHJcblxyXG4gIGlmICggIWVsZW1lbnQgKSB7XHJcbiAgICByZXR1cm47XHJcbiAgfVxyXG5cclxuICAvLyBSZXR1cm4gemVyb3MgZm9yIGRpc2Nvbm5lY3RlZCBhbmQgaGlkZGVuIChkaXNwbGF5OiBub25lKSBlbGVtZW50cyAoZ2gtMjMxMClcclxuICAvLyBTdXBwb3J0OiBJRSA8PTExK1xyXG4gIC8vIFJ1bm5pbmcgZ2V0Qm91bmRpbmdDbGllbnRSZWN0IG9uIGFcclxuICAvLyBkaXNjb25uZWN0ZWQgbm9kZSBpbiBJRSB0aHJvd3MgYW4gZXJyb3JcclxuICBpZiAoICFlbGVtZW50LmdldENsaWVudFJlY3RzKCkubGVuZ3RoICkge1xyXG4gICAgcmV0dXJuIHsgdG9wOiAwLCBsZWZ0OiAwIH07XHJcbiAgfVxyXG5cclxuICAvLyBHZXQgZG9jdW1lbnQtcmVsYXRpdmUgcG9zaXRpb24gYnkgYWRkaW5nIHZpZXdwb3J0IHNjcm9sbCB0byB2aWV3cG9ydC1yZWxhdGl2ZSBnQkNSXHJcbiAgcmVjdCA9IGVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XHJcbiAgd2luID0gZWxlbWVudC5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3O1xyXG4gIHJldHVybiB7XHJcbiAgICB0b3A6IHJlY3QudG9wICsgd2luLnBhZ2VZT2Zmc2V0LFxyXG4gICAgbGVmdDogcmVjdC5sZWZ0ICsgd2luLnBhZ2VYT2Zmc2V0LFxyXG4gIH07XHJcbn0iXX0=