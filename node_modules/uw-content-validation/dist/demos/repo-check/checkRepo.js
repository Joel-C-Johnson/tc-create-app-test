"use strict";var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");var _typeof = require("@babel/runtime/helpers/typeof");Object.defineProperty(exports, "__esModule", { value: true });exports.checkRepo = checkRepo;var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));var _react = _interopRequireDefault(require("react"));
var _defaults = require("../../core/defaults");

var books = _interopRequireWildcard(require("../../core/books/books"));
var _checkFileContents = require("../file-check/checkFileContents");
var _getApi = require("../../core/getApi");

var _utilities = require("../../core/utilities");function _getRequireWildcardCache(nodeInterop) {if (typeof WeakMap !== "function") return null;var cacheBabelInterop = new WeakMap();var cacheNodeInterop = new WeakMap();return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) {return nodeInterop ? cacheNodeInterop : cacheBabelInterop;})(nodeInterop);}function _interopRequireWildcard(obj, nodeInterop) {if (!nodeInterop && obj && obj.__esModule) {return obj;}if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") {return { default: obj };}var cache = _getRequireWildcardCache(nodeInterop);if (cache && cache.has(obj)) {return cache.get(obj);}var newObj = {};var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;for (var key in obj) {if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;if (desc && (desc.get || desc.set)) {Object.defineProperty(newObj, key, desc);} else {newObj[key] = obj[key];}}}newObj.default = obj;if (cache) {cache.set(obj, newObj);}return newObj;}function _createForOfIteratorHelper(o, allowArrayLike) {var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];if (!it) {if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {if (it) o = it;var i = 0;var F = function F() {};return { s: F, n: function n() {if (i >= o.length) return { done: true };return { done: false, value: o[i++] };}, e: function e(_e) {throw _e;}, f: F };}throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");}var normalCompletion = true,didErr = false,err;return { s: function s() {it = it.call(o);}, n: function n() {var step = it.next();normalCompletion = step.done;return step;}, e: function e(_e2) {didErr = true;err = _e2;}, f: function f() {try {if (!normalCompletion && it.return != null) it.return();} finally {if (didErr) throw err;}} };}function _unsupportedIterableToArray(o, minLen) {if (!o) return;if (typeof o === "string") return _arrayLikeToArray(o, minLen);var n = Object.prototype.toString.call(o).slice(8, -1);if (n === "Object" && o.constructor) n = o.constructor.name;if (n === "Map" || n === "Set") return Array.from(o);if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);}function _arrayLikeToArray(arr, len) {if (len == null || len > arr.length) len = arr.length;for (var i = 0, arr2 = new Array(len); i < len; i++) {arr2[i] = arr[i];}return arr2;}function ownKeys(object, enumerableOnly) {var keys = Object.keys(object);if (Object.getOwnPropertySymbols) {var symbols = Object.getOwnPropertySymbols(object);if (enumerableOnly) {symbols = symbols.filter(function (sym) {return Object.getOwnPropertyDescriptor(object, sym).enumerable;});}keys.push.apply(keys, symbols);}return keys;}function _objectSpread(target) {for (var i = 1; i < arguments.length; i++) {var source = arguments[i] != null ? arguments[i] : {};if (i % 2) {ownKeys(Object(source), true).forEach(function (key) {(0, _defineProperty2.default)(target, key, source[key]);});} else if (Object.getOwnPropertyDescriptors) {Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));} else {ownKeys(Object(source)).forEach(function (key) {Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));});}}return target;}


// const REPO_VALIDATOR_VERSION_STRING = '0.4.11';


/**
 *
 * @param {string} username
 * @param {string} repoName
 * @param {string} repoBranch
 * @param {string} givenLocation
 * @param {Function} setResultValue
 * @param {Object} checkingOptions
 */function
checkRepo(_x, _x2, _x3, _x4, _x5, _x6) {return _checkRepo.apply(this, arguments);}function _checkRepo() {_checkRepo = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee2(username, repoName, repoBranch, givenLocation, setResultValue, checkingOptions) {var abortFlag, startTime, _repoName$split, _repoName$split2, languageCode, repoCode, checkRepoResult,














































    addSuccessMessage,




    addNoticePartial,













































    ourCheckRepoFileContents, _ourCheckRepoFileContents, ourLocation, fetchRepositoryZipFile_, zipFetchSucceeded, getFileListFromZip_, pathList, countString, checkedFileCount, checkedFilenames, checkedFilenameExtensions, totalCheckedSize, _iterator, _step, thisFilepath, thisFilename, thisFilenameExtension, bookOrFileCode, ourBookID, bookID, _bookID, getFile_, repoFileContent, details;return _regenerator.default.wrap(function _callee2$(_context2) {while (1) {switch (_context2.prev = _context2.next) {case 0:_ourCheckRepoFileContents = function _ourCheckRepoFileCont2() {_ourCheckRepoFileContents = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee(bookOrFileCode, cfBookID, filename, fileContent, fileLocation, checkingOptions) {var adjustedLanguageCode, cfcResultObject, _iterator2, _step2, cfcNoticeEntry, newNoticeObject;return _regenerator.default.wrap(function _callee$(_context) {while (1) {switch (_context.prev = _context.next) {case 0:
                        // We assume that checking for compulsory fields is done elsewhere
                        // functionLog(`checkRepo ourCheckRepoFileContents(bk/fC='${bookOrFileCode}', bk='${cfBookID}', fn='${filename}', ${fileContent.length}, ${fileLocation}, ${JSON.stringify(checkingOptions)})…`);

                        // Updates the global list of notices
                        //parameterAssert(bookOrFileCode !== undefined, "ourCheckRepoFileContents: 'bookOrFileCode' parameter should be defined");
                        //parameterAssert(typeof bookOrFileCode === 'string', `ourCheckRepoFileContents: 'bookOrFileCode' parameter should be a string not a '${typeof bookOrFileCode}'`);
                        //parameterAssert(cfBookID !== undefined, "ourCheckRepoFileContents: 'cfBookID' parameter should be defined");
                        //parameterAssert(typeof cfBookID === 'string', `ourCheckRepoFileContents: 'cfBookID' parameter should be a string not a '${typeof cfBookID}'`);
                        if (cfBookID) {
                          //parameterAssert(cfBookID.length === 3, `ourCheckRepoFileContents: 'cfBookID' parameter should be three characters long not ${cfBookID.length}`);
                          //parameterAssert(cfBookID.toUpperCase() === cfBookID, `ourCheckRepoFileContents: 'cfBookID' parameter should be UPPERCASE not '${cfBookID}'`);
                          //parameterAssert(cfBookID === 'OBS' || books.isValidBookID(cfBookID), `ourCheckRepoFileContents: '${cfBookID}' is not a valid USFM book identifier`);
                        }
                        //parameterAssert(filename !== undefined, "ourCheckRepoFileContents: 'filename' parameter should be defined");
                        //parameterAssert(typeof filename === 'string', `ourCheckRepoFileContents: 'filename' parameter should be a string not a '${typeof filename}'`);
                        //parameterAssert(fileContent !== undefined, "ourCheckRepoFileContents: 'fileContent' parameter should be defined");
                        //parameterAssert(typeof fileContent === 'string', `ourCheckRepoFileContents: 'fileContent' parameter should be a string not a '${typeof fileContent}'`);
                        //parameterAssert(fileLocation !== undefined, "ourCheckRepoFileContents: 'fileLocation' parameter should be defined");
                        //parameterAssert(typeof fileLocation === 'string', `ourCheckRepoFileContents: 'fileLocation' parameter should be a string not a '${typeof fileLocation}'`);
                        //parameterAssert(checkingOptions !== undefined, "ourCheckRepoFileContents: 'checkingOptions' parameter should be defined");

                        adjustedLanguageCode = languageCode;
                        if (filename === 'manifest.yaml' || filename === 'LICENSE.md' ||
                        (languageCode === 'el-x-koine' || languageCode === 'hbo') && filename === 'README.md')
                        adjustedLanguageCode = 'en'; // Correct the language for these auxilliary files
                        _context.next = 5;return (0, _checkFileContents.checkFileContents)(username, adjustedLanguageCode, repoCode, repoBranch, filename, fileContent, fileLocation, checkingOptions);case 5:cfcResultObject = _context.sent;
                        // debugLog("checkFileContents() returned", resultObject.successList.length, "success message(s) and", resultObject.noticeList.length, "notice(s)");
                        // for (const successEntry of resultObject.successList)
                        //     userLog("  ", successEntry);

                        // Process noticeList line by line,  appending the bookOrFileCode as an extra field as we go
                        _iterator2 = _createForOfIteratorHelper(cfcResultObject.noticeList);try {for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {cfcNoticeEntry = _step2.value;
                            // We add the bookOrFileCode as an extra value (unless it’s already there from a TA or TW check)
                            if (cfcNoticeEntry.extra)
                            checkRepoResult.noticeList.push(cfcNoticeEntry); // Add this notice directly
                            else {
                                // addNoticePartial({ ...cfcNoticeEntry, bookID: cfBookID, extra: bookOrFileCode.toUpperCase() });
                                newNoticeObject = _objectSpread(_objectSpread({}, cfcNoticeEntry), {}, { bookID: cfBookID });
                                if (bookOrFileCode !== '01' // UGL (from content/G04230/01.md)
                                && (bookOrFileCode[0] !== 'H' || bookOrFileCode.length !== 5)) // UHAL, e.g., H0612 from content/H0612.md
                                  newNoticeObject.extra = bookOrFileCode.toUpperCase();
                                addNoticePartial(newNoticeObject);
                              }}
                          /* Removing the following code as it’s unneeded
                          //  as we don’t enable TA or TW checking per repo anyway
                          // Anyway, not sure that the following code was working yet
                          if (repoName.endsWith('_tn')) {
                            // The following is needed coz we might be checking the linked TA and/or TW articles from TN2 TSV files
                            userLog(`cfcResultObject JSON.stringify({ ...cfcResultObject, noticeList: "deleted" })`);
                            if (cfcResultObject.checkedFileCount && cfcResultObject.checkedFileCount > 0) {
                              checkRepoResult.checkedFileCount += cfcResultObject.checkedFileCount;
                              addSuccessMessage(`Checked ${cfcResultObject.checkedFileCount} linked TA/TW articles`);
                            }
                            if (cfcResultObject.checkedFilesizes && cfcResultObject.checkedFilesizes > 0) checkRepoResult.totalCheckedSize += cfcResultObject.checkedFilesizes;
                            if (cfcResultObject.checkedRepoNames && cfcResultObject.checkedRepoNames.length > 0)
                              for (const checkedRepoName of cfcResultObject.checkedRepoNames)
                                try { if (checkRepoResult.checkedRepoNames.indexOf(checkedRepoName) < 0) checkRepoResult.checkedRepoNames.push(checkedRepoName); }
                                catch { checkRepoResult.checkedRepoNames = [checkedRepoName]; }
                            if (cfcResultObject.checkedFilenameExtensions && cfcResultObject.checkedFilenameExtensions.length > 0)
                              for (const checkedFilenameExtension of cfcResultObject.checkedFilenameExtensions)
                                checkRepoResult.checkedFilenameExtensions.add(checkedFilenameExtension);
                          }
                          */} catch (err) {_iterator2.e(err);} finally {_iterator2.f();}case 8:case "end":return _context.stop();}}}, _callee);}));return _ourCheckRepoFileContents.apply(this, arguments);};ourCheckRepoFileContents = function _ourCheckRepoFileCont(_x7, _x8, _x9, _x10, _x11, _x12) {return _ourCheckRepoFileContents.apply(this, arguments);};addNoticePartial = function _addNoticePartial(noticeObject) {// Adds the notices to the result that we will later return
              // bookID is a three-character UPPERCASE USFM book identifier or 'OBS'.
              // Note that bookID,C,V might all be empty strings (as some repos don’t have BCV)
              // functionLog(`checkRepo addNoticePartial: ${noticeObject.priority}:${noticeObject.message} bookID=${noticeObject.bookID} ${noticeObject.C}:${noticeObject.V} ${noticeObject.filename}:${noticeObject.lineNumber} ${noticeObject.characterIndex > 0 ? ` (at character ${noticeObject.characterIndex})` : ""}${noticeObject.excerpt ? ` ${noticeObject.excerpt}` : ""}${noticeObject.location}`);
              //parameterAssert(noticeObject.priority !== undefined, "cR addNoticePartial: 'priority' parameter should be defined");
              //parameterAssert(typeof noticeObject.priority === 'number', `cR addNoticePartial: 'priority' parameter should be a number not a '${typeof noticeObject.priority}'`);
              //parameterAssert(noticeObject.message !== undefined, "cR addNoticePartial: 'message' parameter should be defined");
              //parameterAssert(typeof noticeObject.message === 'string', `cR addNoticePartial: 'message' parameter should be a string not a '${typeof noticeObject.message}'`);
              // //parameterAssert(bookID !== undefined, "cR addNoticePartial: 'bookID' parameter should be defined");
              if (noticeObject.bookID) {//parameterAssert(typeof noticeObject.bookID === 'string', `cR addNoticePartial: 'bookID' parameter should be a string not a '${typeof noticeObject.bookID}'`);
                //parameterAssert(noticeObject.bookID.length === 3, `cR addNoticePartial: 'bookID' parameter should be three characters long not ${noticeObject.bookID.length}`);
                //parameterAssert(noticeObject.bookID === 'OBS' || books.isOptionalValidBookID(noticeObject.bookID), `cR addNoticePartial: '${noticeObject.bookID}' is not a valid USFM book identifier`);
              } // //parameterAssert(C !== undefined, "cR addNoticePartial: 'C' parameter should be defined");
              if (noticeObject.C) {//parameterAssert(typeof noticeObject.C === 'string', `cR addNoticePartial: 'C' parameter should be a string not a '${typeof noticeObject.C}'`);
              } // //parameterAssert(V !== undefined, "cR addNoticePartial: 'V' parameter should be defined");
              if (noticeObject.V) {//parameterAssert(typeof noticeObject.V === 'string', `cR addNoticePartial: 'V' parameter should be a string not a '${typeof noticeObject.V}'`);
              } // //parameterAssert(characterIndex !== undefined, "cR addNoticePartial: 'characterIndex' parameter should be defined");
              if (noticeObject.characterIndex) {//parameterAssert(typeof noticeObject.characterIndex === 'number', `cR addNoticePartial: 'characterIndex' parameter should be a number not a '${typeof noticeObject.characterIndex}'`);
              } // //parameterAssert(excerpt !== undefined, "cR addNoticePartial: 'excerpt' parameter should be defined");
              if (noticeObject.excerpt) {//parameterAssert(typeof noticeObject.excerpt === 'string', `cR addNoticePartial: 'excerpt' parameter should be a string not a '${typeof noticeObject.excerpt}'`);
              } //parameterAssert(noticeObject.location !== undefined, "cR addNoticePartial: 'location' parameter should be defined");
              //parameterAssert(typeof noticeObject.location === 'string', `cR addNoticePartial: 'location' parameter should be a string not a '${typeof noticeObject.location}'`);
              // //parameterAssert(noticeObject.extra !== undefined, "cR addNoticePartial: 'extra' parameter should be defined");
              //parameterAssert(typeof noticeObject.extra === 'string', `cR addNoticePartial: 'extra' parameter should be a string not a '${typeof noticeObject.extra}'`);
              if (noticeObject.debugChain) noticeObject.debugChain = "checkRepo ".concat(noticeObject.debugChain); // Add in the repoName from the outer scope
              checkRepoResult.noticeList.push(_objectSpread(_objectSpread({}, noticeObject), {}, { username: username, repoCode: repoCode, repoName: repoName }));};addSuccessMessage = function _addSuccessMessage(successString) {// Adds the message to the result that we will later return
              // functionLog(`checkRepo success: ${successString}`);
              checkRepoResult.successList.push(successString);}; /*
            It returns an object containing:
                successList: an array of strings to tell the use exactly what has been checked
                noticeList: an array of 9 (i.e., with extra bookOrFileCode parameter at end) notice components
            */ // functionLog(`checkRepo(un='${username}', rN='${repoName}', rBr='${repoBranch}', ${givenLocation}, (fn), ${JSON.stringify(checkingOptions)})…`);
            //parameterAssert(username !== undefined, "checkRepo: 'username' parameter should be defined");
            //parameterAssert(typeof username === 'string', `checkRepo: 'username' parameter should be a string not a '${typeof username}'`);
            //parameterAssert(repoName !== undefined, "checkRepo: 'repoName' parameter should be defined");
            //parameterAssert(typeof repoName === 'string', `checkRepo: 'repoName' parameter should be a string not a '${typeof repoName}'`);
            //parameterAssert(repoBranch !== undefined, "checkRepo: 'repoBranch' parameter should be defined");
            //parameterAssert(typeof repoBranch === 'string', `checkRepo: 'repoBranch' parameter should be a string not a '${typeof repoBranch}'`);
            //parameterAssert(givenLocation !== undefined, "checkRepo: 'givenRowLocation' parameter should be defined");
            //parameterAssert(typeof givenLocation === 'string', `checkRepo: 'givenRowLocation' parameter should be a string not a '${typeof givenLocation}'`);
            abortFlag = false;startTime = new Date();_repoName$split = repoName.split('_'), _repoName$split2 = (0, _slicedToArray2.default)(_repoName$split, 2), languageCode = _repoName$split2[0], repoCode = _repoName$split2[1];repoCode = repoCode.toUpperCase(); // debugLog(`checkRepo got languageCode='${languageCode}' repoCode='${repoCode}' repoBranch='${repoBranch}'`);
            if (repoCode === 'TN2') {repoCode = 'TN';if (repoBranch === undefined) repoBranch = 'newFormat';} else if (repoCode === 'TQ2') {repoCode = 'TQ';if (repoBranch === undefined) repoBranch = 'newFormat';} else if (repoCode === 'SN2') {repoCode = 'SN';if (repoBranch === undefined) repoBranch = 'newFormat';} else if (repoCode === 'SQ2') {repoCode = 'SQ';if (repoBranch === undefined) repoBranch = 'newFormat';} else if (repoCode.endsWith('LT')) repoCode = 'LT';else if (repoCode.endsWith('ST')) repoCode = 'ST'; // debugLog(`checkRepo now has languageCode='${languageCode}' repoCode='${repoCode}' repoBranch='${repoBranch}'`);
            (0, _utilities.logicAssert)(_defaults.REPO_CODES_LIST.includes(repoCode), "checkRepo: 'repoCode' parameter should not be '".concat(repoCode, "'"));if (repoBranch === undefined) repoBranch = 'master'; // Ideally we should ask what the default branch is
            checkRepoResult = { successList: [], noticeList: [], checkedFileCount: 0, checkedFileSizes: 0, checkedFilenames: [], checkedFilenameExtensions: [], checkedRepoNames: [] };_context2.next = 14;return (0, _getApi.repositoryExistsOnDoor43)({ username: username, repository: repoName });case 14:if (_context2.sent) {_context2.next = 20;break;}setResultValue( /*#__PURE__*/_react.default.createElement("p", { style: { color: 'red' } }, "No such ", /*#__PURE__*/_react.default.createElement("b", null, username, "/", repoName), " repository!"));console.error("checkRepo ".concat(username, "/").concat(repoName, " doesn\u2019t seem to exist"));addNoticePartial({ priority: 986, message: "Repository doesn’t seem to exist", details: "username=".concat(username), location: givenLocation, extra: repoName });_context2.next = 106;break;case 20:_context2.prev = 20;ourLocation = givenLocation;if (ourLocation && ourLocation[0] !== ' ') ourLocation = " ".concat(ourLocation); // if (ourLocation.indexOf(username) < 0)
            // ourLocation = ` in ${username} ${repoName} ${givenLocation}`
            // Update our "waiting" message
            setResultValue( /*#__PURE__*/_react.default.createElement("p", { style: { color: 'magenta' } }, "Fetching zipped files from ", /*#__PURE__*/_react.default.createElement("b", null, username, "/", repoName), " repository\u2026")); // Let’s fetch the zipped repo since it should be much more efficient than individual fetches
            // functionLog(`checkRepo: fetch zip file for ${repoName}…`);
            fetchRepositoryZipFile_ = checkingOptions && checkingOptions.fetchRepositoryZipFile ? checkingOptions.fetchRepositoryZipFile : _getApi.cachedGetRepositoryZipFile;_context2.next = 27;return fetchRepositoryZipFile_({ username: username, repository: repoName, branch: repoBranch, branchOrRelease: repoBranch });case 27:zipFetchSucceeded = _context2.sent;if (zipFetchSucceeded) {_context2.next = 33;break;}console.error("checkRepo: misfetched zip file for repo with ".concat(zipFetchSucceeded));setResultValue( /*#__PURE__*/_react.default.createElement("p", { style: { color: 'red' } }, "Failed to fetching zipped files from ", /*#__PURE__*/_react.default.createElement("b", null, username, "/", repoName), " repository"));addNoticePartial({ priority: 989, message: "Unable to find/load repository", location: ourLocation });return _context2.abrupt("return", checkRepoResult);case 33: // Now we need to fetch the list of files from the repo
            setResultValue( /*#__PURE__*/_react.default.createElement("p", { style: { color: 'magenta' } }, "Preprocessing file list from ", /*#__PURE__*/_react.default.createElement("b", null, username, "/", repoName), " repository\u2026")); // const pathList = await getFileListFromFetchedTreemaps(username, repoName, branch);
            getFileListFromZip_ = checkingOptions && checkingOptions.getFileListFromZip ? checkingOptions.getFileListFromZip : _getApi.getFileListFromZip;_context2.next = 37;return getFileListFromZip_({ username: username, repository: repoName, branchOrRelease: repoBranch });case 37:pathList = _context2.sent; // debugLog(`Got pathlist (${pathList.length}) = ${pathList}`);
            // So now we want to work through checking all the files in this repo
            // Main loop for checkRepo()
            countString = "".concat(pathList.length.toLocaleString(), " file").concat(pathList.length === 1 ? '' : 's');checkedFileCount = 0, checkedFilenames = [], checkedFilenameExtensions = new Set(), totalCheckedSize = 0;_iterator = _createForOfIteratorHelper(pathList);_context2.prev = 41;_iterator.s();case 43:if ((_step = _iterator.n()).done) {_context2.next = 84;break;}thisFilepath = _step.value;if (!abortFlag) {_context2.next = 47;break;}return _context2.abrupt("break", 84);case 47: // Update our "waiting" message
            setResultValue( /*#__PURE__*/_react.default.createElement("p", { style: { color: 'magenta' } }, "Checking ", /*#__PURE__*/_react.default.createElement("b", null, username, "/", repoName), " repo: checked ", checkedFileCount.toLocaleString(), "/", countString, "\u2026"));

            thisFilename = thisFilepath.split('/').pop();
            // debugLog(`thisFilename=${thisFilename}`);
            thisFilenameExtension = thisFilename.split('.').pop();
            // debugLog(`thisFilenameExtension=${thisFilenameExtension}`);

            // Default to the main filename without the extension
            bookOrFileCode = thisFilename.substring(0, thisFilename.length - thisFilenameExtension.length - 1);
            ourBookID = '';
            if (thisFilenameExtension === 'usfm') {
              // const filenameMain = thisFilename.substring(0, thisFilename.length - 5); // drop .usfm
              // debugLog(`Have USFM filenameMain=${bookOrFileCode}`);
              bookID = bookOrFileCode.substring(bookOrFileCode.length - 3).toUpperCase();
              // debugLog(`Have USFM bookcode=${bookID}`);
              //parameterAssert(books.isValidBookID(bookID), `checkRepo: '${bookID}' is not a valid USFM book identifier (for USFM)`);
              bookOrFileCode = bookID;
              ourBookID = bookID;
            } else
            if (thisFilenameExtension === 'tsv') {
              // debugLog(`Have TSV thisFilename(${thisFilename.length})='${thisFilename}'`);
              // debugLog(`Have TSV bookOrFileCode(${bookOrFileCode.length})='${bookOrFileCode}'`);
              _bookID = void 0;
              // bookOrFileCode could be something like 'en_tn_09-1SA.tsv ' or 'tn_2CO' or 'twl_1CH'
              // bookID = (bookOrFileCode.length === 6 || bookOrFileCode.length === 7) ? bookOrFileCode.substring(0, 3) : bookOrFileCode.slice(-3).toUpperCase();
              _bookID = bookOrFileCode.slice(-3).toUpperCase();
              (0, _utilities.logicAssert)(_bookID !== 'twl' && _bookID !== 'TWL', "Should get a valid bookID here, not '".concat(_bookID, "'"));
              // debugLog(`Have TSV bookcode(${bookID.length})='${bookID}'`);
              if (repoCode === 'TWL' || repoCode === 'SN' || repoCode === 'SQ' || repoCode === 'TN2' || repoCode === 'TQ2') {// new repos allow `OBS`
                //parameterAssert(bookID === 'OBS' || books.isValidBookID(bookID), `checkRepo: '${bookID}' is not a valid USFM book identifier (for TSV)`);
              } else {
                  //parameterAssert(bookID !== 'OBS' && books.isValidBookID(bookID), `checkRepo: '${bookID}' is not a valid USFM book identifier (for TSV)`);
                }
              bookOrFileCode = _bookID;
              ourBookID = _bookID;
            } else
            if (repoName.endsWith('_ta') && thisFilepath.indexOf('/') > 0)
            bookOrFileCode = thisFilepath.split('/')[1];else
            if (repoName.endsWith('_tq') && thisFilepath.indexOf('/') > 0)
            bookOrFileCode = thisFilepath.split('/')[0];

            // debugLog("checkRepo: Try to load", username, repoName, thisFilepath, branch);
            getFile_ = checkingOptions && checkingOptions.getFile ? checkingOptions.getFile : _getApi.cachedGetFile;
            repoFileContent = void 0;_context2.prev = 55;_context2.next = 58;return (

              getFile_({ username: username, repository: repoName, path: thisFilepath, branch: repoBranch }));case 58:repoFileContent = _context2.sent;_context2.next = 74;break;case 61:_context2.prev = 61;_context2.t0 = _context2["catch"](55);


            console.error("checkRepo(".concat(username, ", ").concat(repoName, ", ").concat(repoBranch, ", ").concat(givenLocation, ", (fn), ").concat(JSON.stringify(checkingOptions), ")) failed to load"), thisFilepath, repoBranch, "".concat(_context2.t0));
            details = "username=".concat(username);_context2.next = 67;return (
              (0, _getApi.repositoryExistsOnDoor43)({ username: username, repository: repoName }));case 67:if (_context2.sent) {_context2.next = 71;break;}
            checkRepoResult.noticeList.push({ priority: 997, message: "Repository doesn’t exist", details: details, username: username, repoCode: repoCode, repoName: repoName, location: givenLocation, extra: repoCode });_context2.next = 73;break;case 71:

            // eslint-disable-next-line eqeqeq
            if (_context2.t0 != 'TypeError: repoFileContent is null') details += " error=".concat(_context2.t0);
            addNoticePartial({ priority: 996, message: "Unable to load", details: "username=".concat(username, " error=").concat(_context2.t0), bookID: ourBookID, filename: thisFilename, location: "".concat(givenLocation, " ").concat(thisFilepath), extra: repoName });case 73:return _context2.abrupt("return");case 74:if (!



            repoFileContent) {_context2.next = 82;break;}_context2.next = 77;return (

              ourCheckRepoFileContents(bookOrFileCode, ourBookID,
              // OBS has many files with the same name, so we have to give some of the path as well
              // repoName.endsWith('_obs') ? thisFilepath.replace('content/', '') : thisFilename,
              thisFilenameExtension === 'md' ? thisFilepath.replace('content/', '').replace('bible/', '') : thisFilename,
              repoFileContent, ourLocation, checkingOptions));case 77:
            checkedFileCount += 1;
            checkedFilenames.push(thisFilename);
            checkedFilenameExtensions.add(thisFilenameExtension);
            totalCheckedSize += repoFileContent.length;
            // functionLog(`checkRepo checked ${thisFilename}`);
            if (thisFilenameExtension !== 'md') // There's often far, far too many of these
              addSuccessMessage("Checked ".concat(repoName, " ").concat(bookOrFileCode.toUpperCase(), " file: ").concat(thisFilename));case 82:_context2.next = 43;break;case 84:_context2.next = 89;break;case 86:_context2.prev = 86;_context2.t1 = _context2["catch"](41);_iterator.e(_context2.t1);case 89:_context2.prev = 89;_iterator.f();return _context2.finish(89);case 92:



            // Check that we processed a license and a manifest
            if (checkedFilenames.indexOf('LICENSE.md') < 0)
            addNoticePartial({ priority: 946, message: "Missing LICENSE.md", location: ourLocation, extra: "".concat(repoName, " LICENSE") });
            if (checkedFilenames.indexOf('manifest.yaml') < 0)
            addNoticePartial({ priority: 947, message: "Missing manifest.yaml", location: ourLocation, extra: "".concat(repoName, " MANIFEST") });

            // Add some extra fields to our checkRepoResult object
            //  in case we need this information again later
            checkRepoResult.checkedFileCount += checkedFileCount;
            checkRepoResult.checkedFilenames = checkedFilenames;
            checkRepoResult.checkedFilenameExtensions = [].concat((0, _toConsumableArray2.default)(checkRepoResult.checkedFilenameExtensions), (0, _toConsumableArray2.default)(checkedFilenameExtensions)); // convert Set to Array
            checkRepoResult.checkedFilesizes += totalCheckedSize;
            checkRepoResult.checkedRepoNames.unshift("".concat(username, "/").concat(repoName));
            // checkRepoResult.checkedOptions = checkingOptions; // This is done at the caller level

            addSuccessMessage("Checked ".concat(username, " repo: ").concat(repoName));
            // functionLog(`checkRepo() is returning ${checkRepoResult.successList.length.toLocaleString()} success message(s) and ${checkRepoResult.noticeList.length.toLocaleString()} notice(s)`);
            _context2.next = 106;break;case 102:_context2.prev = 102;_context2.t2 = _context2["catch"](20);
            console.error("checkRepo main code block got error: ".concat(_context2.t2.message));
            setResultValue( /*#__PURE__*/_react.default.createElement(_react.default.Fragment, null, /*#__PURE__*/
            _react.default.createElement("p", { style: { color: 'red' } }, "checkRepo main code block got error: ", /*#__PURE__*/_react.default.createElement("b", null, _context2.t2.message), " with ", _context2.t2.trace)));case 106:




            checkRepoResult.elapsedSeconds = (new Date() - startTime) / 1000; // seconds
            // debugLog(`checkRepo() returning ${JSON.stringify(checkRepoResult)}`);
            return _context2.abrupt("return", checkRepoResult);case 108:case "end":return _context2.stop();}}}, _callee2, null, [[20, 102], [41, 86, 89, 92], [55, 61]]);}));return _checkRepo.apply(this, arguments);}
;
// end of checkRepo()
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9kZW1vcy9yZXBvLWNoZWNrL2NoZWNrUmVwby5qcyJdLCJuYW1lcyI6WyJjaGVja1JlcG8iLCJ1c2VybmFtZSIsInJlcG9OYW1lIiwicmVwb0JyYW5jaCIsImdpdmVuTG9jYXRpb24iLCJzZXRSZXN1bHRWYWx1ZSIsImNoZWNraW5nT3B0aW9ucyIsImFkZFN1Y2Nlc3NNZXNzYWdlIiwiYWRkTm90aWNlUGFydGlhbCIsIm91ckNoZWNrUmVwb0ZpbGVDb250ZW50cyIsImJvb2tPckZpbGVDb2RlIiwiY2ZCb29rSUQiLCJmaWxlbmFtZSIsImZpbGVDb250ZW50IiwiZmlsZUxvY2F0aW9uIiwiYWRqdXN0ZWRMYW5ndWFnZUNvZGUiLCJsYW5ndWFnZUNvZGUiLCJyZXBvQ29kZSIsImNmY1Jlc3VsdE9iamVjdCIsIm5vdGljZUxpc3QiLCJjZmNOb3RpY2VFbnRyeSIsImV4dHJhIiwiY2hlY2tSZXBvUmVzdWx0IiwicHVzaCIsIm5ld05vdGljZU9iamVjdCIsImJvb2tJRCIsImxlbmd0aCIsInRvVXBwZXJDYXNlIiwibm90aWNlT2JqZWN0IiwiQyIsIlYiLCJjaGFyYWN0ZXJJbmRleCIsImV4Y2VycHQiLCJkZWJ1Z0NoYWluIiwic3VjY2Vzc1N0cmluZyIsInN1Y2Nlc3NMaXN0IiwiYWJvcnRGbGFnIiwic3RhcnRUaW1lIiwiRGF0ZSIsInNwbGl0IiwidW5kZWZpbmVkIiwiZW5kc1dpdGgiLCJSRVBPX0NPREVTX0xJU1QiLCJpbmNsdWRlcyIsImNoZWNrZWRGaWxlQ291bnQiLCJjaGVja2VkRmlsZVNpemVzIiwiY2hlY2tlZEZpbGVuYW1lcyIsImNoZWNrZWRGaWxlbmFtZUV4dGVuc2lvbnMiLCJjaGVja2VkUmVwb05hbWVzIiwicmVwb3NpdG9yeSIsImNvbG9yIiwiY29uc29sZSIsImVycm9yIiwicHJpb3JpdHkiLCJtZXNzYWdlIiwiZGV0YWlscyIsImxvY2F0aW9uIiwib3VyTG9jYXRpb24iLCJmZXRjaFJlcG9zaXRvcnlaaXBGaWxlXyIsImZldGNoUmVwb3NpdG9yeVppcEZpbGUiLCJjYWNoZWRHZXRSZXBvc2l0b3J5WmlwRmlsZSIsImJyYW5jaCIsImJyYW5jaE9yUmVsZWFzZSIsInppcEZldGNoU3VjY2VlZGVkIiwiZ2V0RmlsZUxpc3RGcm9tWmlwXyIsImdldEZpbGVMaXN0RnJvbVppcCIsInBhdGhMaXN0IiwiY291bnRTdHJpbmciLCJ0b0xvY2FsZVN0cmluZyIsIlNldCIsInRvdGFsQ2hlY2tlZFNpemUiLCJ0aGlzRmlsZXBhdGgiLCJ0aGlzRmlsZW5hbWUiLCJwb3AiLCJ0aGlzRmlsZW5hbWVFeHRlbnNpb24iLCJzdWJzdHJpbmciLCJvdXJCb29rSUQiLCJzbGljZSIsImluZGV4T2YiLCJnZXRGaWxlXyIsImdldEZpbGUiLCJjYWNoZWRHZXRGaWxlIiwicmVwb0ZpbGVDb250ZW50IiwicGF0aCIsIkpTT04iLCJzdHJpbmdpZnkiLCJyZXBsYWNlIiwiYWRkIiwiY2hlY2tlZEZpbGVzaXplcyIsInVuc2hpZnQiLCJ0cmFjZSIsImVsYXBzZWRTZWNvbmRzIl0sIm1hcHBpbmdzIjoiOHNCQUFBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGlEOzs7QUFHQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEc7QUFDc0JBLFMscUxBQWYsa0JBQXlCQyxRQUF6QixFQUFtQ0MsUUFBbkMsRUFBNkNDLFVBQTdDLEVBQXlEQyxhQUF6RCxFQUF3RUMsY0FBeEUsRUFBd0ZDLGVBQXhGOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQStDSUMsSUFBQUEsaUJBL0NKOzs7OztBQW9ESUMsSUFBQUEsZ0JBcERKOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBa0dVQyxJQUFBQSx3QkFsR1Ysc29CQWtHTCxpQkFBd0NDLGNBQXhDLEVBQXdEQyxRQUF4RCxFQUFrRUMsUUFBbEUsRUFBNEVDLFdBQTVFLEVBQXlGQyxZQUF6RixFQUF1R1Is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LGFBQVFJLE9BQVosQ0FBakUsWUFBZ0csYUFBUW9DLEtBQXhHLENBRGEsQ0FBRCxDQUFkLENBdFRDOzs7OztBQTRUTHBFLFlBQUFBLGVBQWUsQ0FBQ3FFLGNBQWhCLEdBQWlDLENBQUMsSUFBSXJELElBQUosS0FBYUQsU0FBZCxJQUEyQixJQUE1RCxDQTVUSyxDQTRUNkQ7QUFDbEU7QUE3VEssOENBOFRFZixlQTlURiw2RztBQStUTjtBQUNEIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IFJFUE9fQ09ERVNfTElTVCB9IGZyb20gJy4uLy4uL2NvcmUvZGVmYXVsdHMnO1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC12YXJzXG5pbXBvcnQgKiBhcyBib29rcyBmcm9tICcuLi8uLi9jb3JlL2Jvb2tzL2Jvb2tzJztcbmltcG9ydCB7IGNoZWNrRmlsZUNvbnRlbnRzIH0gZnJvbSAnLi4vZmlsZS1jaGVjay9jaGVja0ZpbGVDb250ZW50cyc7XG5pbXBvcnQgeyByZXBvc2l0b3J5RXhpc3RzT25Eb29yNDMsIGdldEZpbGVMaXN0RnJvbVppcCwgY2FjaGVkR2V0RmlsZSwgY2FjaGVkR2V0UmVwb3NpdG9yeVppcEZpbGUgfSBmcm9tICcuLi8uLi9jb3JlL2dldEFwaSc7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLXZhcnNcbmltcG9ydCB7IGZ1bmN0aW9uTG9nLCBkZWJ1Z0xvZywgbG9naWNBc3NlcnQsIHBhcmFtZXRlckFzc2VydCB9IGZyb20gJy4uLy4uL2NvcmUvdXRpbGl0aWVzJztcblxuXG4vLyBjb25zdCBSRVBPX1ZBTElEQVRPUl9WRVJTSU9OX1NUUklORyA9ICcwLjQuMTEnO1xuXG5cbi8qKlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB1c2VybmFtZVxuICogQHBhcmFtIHtzdHJpbmd9IHJlcG9OYW1lXG4gKiBAcGFyYW0ge3N0cmluZ30gcmVwb0JyYW5jaFxuICogQHBhcmFtIHtzdHJpbmd9IGdpdmVuTG9jYXRpb25cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHNldFJlc3VsdFZhbHVlXG4gKiBAcGFyYW0ge09iamVjdH0gY2hlY2tpbmdPcHRpb25zXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBjaGVja1JlcG8odXNlcm5hbWUsIHJlcG9OYW1lLCByZXBvQnJhbmNoLCBnaXZlbkxvY2F0aW9uLCBzZXRSZXN1bHRWYWx1ZSwgY2hlY2tpbmdPcHRpb25zKSB7XG4gIC8qXG4gIEl0IHJldHVybnMgYW4gb2JqZWN0IGNvbnRhaW5pbmc6XG4gICAgICBzdWNjZXNzTGlzdDogYW4gYXJyYXkgb2Ygc3RyaW5ncyB0byB0ZWxsIHRoZSB1c2UgZXhhY3RseSB3aGF0IGhhcyBiZWVuIGNoZWNrZWRcbiAgICAgIG5vdGljZUxpc3Q6IGFuIGFycmF5IG9mIDkgKGkuZS4sIHdpdGggZXh0cmEgYm9va09yRmlsZUNvZGUgcGFyYW1ldGVyIGF0IGVuZCkgbm90aWNlIGNvbXBvbmVudHNcbiAgKi9cbiAgLy8gZnVuY3Rpb25Mb2coYGNoZWNrUmVwbyh1bj0nJHt1c2VybmFtZX0nLCByTj0nJHtyZXBvTmFtZX0nLCByQnI9JyR7cmVwb0JyYW5jaH0nLCAke2dpdmVuTG9jYXRpb259LCAoZm4pLCAke0pTT04uc3RyaW5naWZ5KGNoZWNraW5nT3B0aW9ucyl9KeKApmApO1xuICAvL3BhcmFtZXRlckFzc2VydCh1c2VybmFtZSAhPT0gdW5kZWZpbmVkLCBcImNoZWNrUmVwbzogJ3VzZXJuYW1lJyBwYXJhbWV0ZXIgc2hvdWxkIGJlIGRlZmluZWRcIik7XG4gIC8vcGFyYW1ldGVyQXNzZXJ0KHR5cGVvZiB1c2VybmFtZSA9PT0gJ3N0cmluZycsIGBjaGVja1JlcG86ICd1c2VybmFtZScgcGFyYW1ldGVyIHNob3VsZCBiZSBhIHN0cmluZyBub3QgYSAnJHt0eXBlb2YgdXNlcm5hbWV9J2ApO1xuICAvL3BhcmFtZXRlckFzc2VydChyZXBvTmFtZSAhPT0gdW5kZWZpbmVkLCBcImNoZWNrUmVwbzogJ3JlcG9OYW1lJyBwYXJhbWV0ZXIgc2hvdWxkIGJlIGRlZmluZWRcIik7XG4gIC8vcGFyYW1ldGVyQXNzZXJ0KHR5cGVvZiByZXBvTmFtZSA9PT0gJ3N0cmluZycsIGBjaGVja1JlcG86ICdyZXBvTmFtZScgcGFyYW1ldGVyIHNob3VsZCBiZSBhIHN0cmluZyBub3QgYSAnJHt0eXBlb2YgcmVwb05hbWV9J2ApO1xuICAvL3BhcmFtZXRlckFzc2VydChyZXBvQnJhbmNoICE9PSB1bmRlZmluZWQsIFwiY2hlY2tSZXBvOiAncmVwb0JyYW5jaCcgcGFyYW1ldGVyIHNob3VsZCBiZSBkZWZpbmVkXCIpO1xuICAvL3BhcmFtZXRlckFzc2VydCh0eXBlb2YgcmVwb0JyYW5jaCA9PT0gJ3N0cmluZycsIGBjaGVja1JlcG86ICdyZXBvQnJhbmNoJyBwYXJhbWV0ZXIgc2hvdWxkIGJlIGEgc3RyaW5nIG5vdCBhICcke3R5cGVvZiByZXBvQnJhbmNofSdgKTtcbiAgLy9wYXJhbWV0ZXJBc3NlcnQoZ2l2ZW5Mb2NhdGlvbiAhPT0gdW5kZWZpbmVkLCBcImNoZWNrUmVwbzogJ2dpdmVuUm93TG9jYXRpb24nIHBhcmFtZXRlciBzaG91bGQgYmUgZGVmaW5lZFwiKTtcbiAgLy9wYXJhbWV0ZXJBc3NlcnQodHlwZW9mIGdpdmVuTG9jYXRpb24gPT09ICdzdHJpbmcnLCBgY2hlY2tSZXBvOiAnZ2l2ZW5Sb3dMb2NhdGlvbicgcGFyYW1ldGVyIHNob3VsZCBiZSBhIHN0cmluZyBub3QgYSAnJHt0eXBlb2YgZ2l2ZW5Mb2NhdGlvbn0nYCk7XG5cbiAgbGV0IGFib3J0RmxhZyA9IGZhbHNlO1xuICBjb25zdCBzdGFydFRpbWUgPSBuZXcgRGF0ZSgpO1xuXG4gIGxldCBbbGFuZ3VhZ2VDb2RlLCByZXBvQ29kZV0gPSByZXBvTmFtZS5zcGxpdCgnXycpO1xuICByZXBvQ29kZSA9IHJlcG9Db2RlLnRvVXBwZXJDYXNlKCk7XG4gIC8vIGRlYnVnTG9nKGBjaGVja1JlcG8gZ290IGxhbmd1YWdlQ29kZT0nJHtsYW5ndWFnZUNvZGV9JyByZXBvQ29kZT0nJHtyZXBvQ29kZX0nIHJlcG9CcmFuY2g9JyR7cmVwb0JyYW5jaH0nYCk7XG4gIGlmIChyZXBvQ29kZSA9PT0gJ1ROMicpIHtcbiAgICByZXBvQ29kZSA9ICdUTic7XG4gICAgaWYgKHJlcG9CcmFuY2ggPT09IHVuZGVmaW5lZCkgcmVwb0JyYW5jaCA9ICduZXdGb3JtYXQnO1xuICB9IGVsc2UgaWYgKHJlcG9Db2RlID09PSAnVFEyJykge1xuICAgIHJlcG9Db2RlID0gJ1RRJztcbiAgICBpZiAocmVwb0JyYW5jaCA9PT0gdW5kZWZpbmVkKSByZXBvQnJhbmNoID0gJ25ld0Zvcm1hdCc7XG4gIH0gZWxzZSBpZiAocmVwb0NvZGUgPT09ICdTTjInKSB7XG4gICAgcmVwb0NvZGUgPSAnU04nO1xuICAgIGlmIChyZXBvQnJhbmNoID09PSB1bmRlZmluZWQpIHJlcG9CcmFuY2ggPSAnbmV3Rm9ybWF0JztcbiAgfSBlbHNlIGlmIChyZXBvQ29kZSA9PT0gJ1NRMicpIHtcbiAgICByZXBvQ29kZSA9ICdTUSc7XG4gICAgaWYgKHJlcG9CcmFuY2ggPT09IHVuZGVmaW5lZCkgcmVwb0JyYW5jaCA9ICduZXdGb3JtYXQnO1xuICB9IGVsc2UgaWYgKHJlcG9Db2RlLmVuZHNXaXRoKCdMVCcpKSByZXBvQ29kZSA9ICdMVCc7XG4gIGVsc2UgaWYgKHJlcG9Db2RlLmVuZHNXaXRoKCdTVCcpKSByZXBvQ29kZSA9ICdTVCc7XG4gIC8vIGRlYnVnTG9nKGBjaGVja1JlcG8gbm93IGhhcyBsYW5ndWFnZUNvZGU9JyR7bGFuZ3VhZ2VDb2RlfScgcmVwb0NvZGU9JyR7cmVwb0NvZGV9JyByZXBvQnJhbmNoPScke3JlcG9CcmFuY2h9J2ApO1xuICBsb2dpY0Fzc2VydChSRVBPX0NPREVTX0xJU1QuaW5jbHVkZXMocmVwb0NvZGUpLCBgY2hlY2tSZXBvOiAncmVwb0NvZGUnIHBhcmFtZXRlciBzaG91bGQgbm90IGJlICcke3JlcG9Db2RlfSdgKTtcblxuICBpZiAocmVwb0JyYW5jaCA9PT0gdW5kZWZpbmVkKSByZXBvQnJhbmNoID0gJ21hc3Rlcic7IC8vIElkZWFsbHkgd2Ugc2hvdWxkIGFzayB3aGF0IHRoZSBkZWZhdWx0IGJyYW5jaCBpc1xuXG4gIGxldCBjaGVja1JlcG9SZXN1bHQgPSB7XG4gICAgc3VjY2Vzc0xpc3Q6IFtdLCBub3RpY2VMaXN0OiBbXSxcbiAgICBjaGVja2VkRmlsZUNvdW50OiAwLCBjaGVja2VkRmlsZVNpemVzOiAwLFxuICAgIGNoZWNrZWRGaWxlbmFtZXM6IFtdLCBjaGVja2VkRmlsZW5hbWVFeHRlbnNpb25zOiBbXSwgY2hlY2tlZFJlcG9OYW1lczogW10sXG4gIH07XG5cbiAgZnVuY3Rpb24gYWRkU3VjY2Vzc01lc3NhZ2Uoc3VjY2Vzc1N0cmluZykge1xuICAgIC8vIEFkZHMgdGhlIG1lc3NhZ2UgdG8gdGhlIHJlc3VsdCB0aGF0IHdlIHdpbGwgbGF0ZXIgcmV0dXJuXG4gICAgLy8gZnVuY3Rpb25Mb2coYGNoZWNrUmVwbyBzdWNjZXNzOiAke3N1Y2Nlc3NTdHJpbmd9YCk7XG4gICAgY2hlY2tSZXBvUmVzdWx0LnN1Y2Nlc3NMaXN0LnB1c2goc3VjY2Vzc1N0cmluZyk7XG4gIH1cbiAgZnVuY3Rpb24gYWRkTm90aWNlUGFydGlhbChub3RpY2VPYmplY3QpIHtcbiAgICAvLyBBZGRzIHRoZSBub3RpY2VzIHRvIHRoZSByZXN1bHQgdGhhdCB3ZSB3aWxsIGxhdGVyIHJldHVyblxuICAgIC8vIGJvb2tJRCBpcyBhIHRocmVlLWNoYXJhY3RlciBVUFBFUkNBU0UgVVNGTSBib29rIGlkZW50aWZpZXIgb3IgJ09CUycuXG4gICAgLy8gTm90ZSB0aGF0IGJvb2tJRCxDLFYgbWlnaHQgYWxsIGJlIGVtcHR5IHN0cmluZ3MgKGFzIHNvbWUgcmVwb3MgZG9u4oCZdCBoYXZlIEJDVilcbiAgICAvLyBmdW5jdGlvbkxvZyhgY2hlY2tSZXBvIGFkZE5vdGljZVBhcnRpYWw6ICR7bm90aWNlT2JqZWN0LnByaW9yaXR5fToke25vdGljZU9iamVjdC5tZXNzYWdlfSBib29rSUQ9JHtub3RpY2VPYmplY3QuYm9va0lEfSAke25vdGljZU9iamVjdC5DfToke25vdGljZU9iamVjdC5WfSAke25vdGljZU9iamVjdC5maWxlbmFtZX06JHtub3RpY2VPYmplY3QubGluZU51bWJlcn0gJHtub3RpY2VPYmplY3QuY2hhcmFjdGVySW5kZXggPiAwID8gYCAoYXQgY2hhcmFjdGVyICR7bm90aWNlT2JqZWN0LmNoYXJhY3RlckluZGV4fSlgIDogXCJcIn0ke25vdGljZU9iamVjdC5leGNlcnB0ID8gYCAke25vdGljZU9iamVjdC5leGNlcnB0fWAgOiBcIlwifSR7bm90aWNlT2JqZWN0LmxvY2F0aW9ufWApO1xuICAgIC8vcGFyYW1ldGVyQXNzZXJ0KG5vdGljZU9iamVjdC5wcmlvcml0eSAhPT0gdW5kZWZpbmVkLCBcImNSIGFkZE5vdGljZVBhcnRpYWw6ICdwcmlvcml0eScgcGFyYW1ldGVyIHNob3VsZCBiZSBkZWZpbmVkXCIpO1xuICAgIC8vcGFyYW1ldGVyQXNzZXJ0KHR5cGVvZiBub3RpY2VPYmplY3QucHJpb3JpdHkgPT09ICdudW1iZXInLCBgY1IgYWRkTm90aWNlUGFydGlhbDogJ3ByaW9yaXR5JyBwYXJhbWV0ZXIgc2hvdWxkIGJlIGEgbnVtYmVyIG5vdCBhICcke3R5cGVvZiBub3RpY2VPYmplY3QucHJpb3JpdHl9J2ApO1xuICAgIC8vcGFyYW1ldGVyQXNzZXJ0KG5vdGljZU9iamVjdC5tZXNzYWdlICE9PSB1bmRlZmluZWQsIFwiY1IgYWRkTm90aWNlUGFydGlhbDogJ21lc3NhZ2UnIHBhcmFtZXRlciBzaG91bGQgYmUgZGVmaW5lZFwiKTtcbiAgICAvL3BhcmFtZXRlckFzc2VydCh0eXBlb2Ygbm90aWNlT2JqZWN0Lm1lc3NhZ2UgPT09ICdzdHJpbmcnLCBgY1IgYWRkTm90aWNlUGFydGlhbDogJ21lc3NhZ2UnIHBhcmFtZXRlciBzaG91bGQgYmUgYSBzdHJpbmcgbm90IGEgJyR7dHlwZW9mIG5vdGljZU9iamVjdC5tZXNzYWdlfSdgKTtcbiAgICAvLyAvL3BhcmFtZXRlckFzc2VydChib29rSUQgIT09IHVuZGVmaW5lZCwgXCJjUiBhZGROb3RpY2VQYXJ0aWFsOiAnYm9va0lEJyBwYXJhbWV0ZXIgc2hvdWxkIGJlIGRlZmluZWRcIik7XG4gICAgaWYgKG5vdGljZU9iamVjdC5ib29rSUQpIHtcbiAgICAgIC8vcGFyYW1ldGVyQXNzZXJ0KHR5cGVvZiBub3RpY2VPYmplY3QuYm9va0lEID09PSAnc3RyaW5nJywgYGNSIGFkZE5vdGljZVBhcnRpYWw6ICdib29rSUQnIHBhcmFtZXRlciBzaG91bGQgYmUgYSBzdHJpbmcgbm90IGEgJyR7dHlwZW9mIG5vdGljZU9iamVjdC5ib29rSUR9J2ApO1xuICAgICAgLy9wYXJhbWV0ZXJBc3NlcnQobm90aWNlT2JqZWN0LmJvb2tJRC5sZW5ndGggPT09IDMsIGBjUiBhZGROb3RpY2VQYXJ0aWFsOiAnYm9va0lEJyBwYXJhbWV0ZXIgc2hvdWxkIGJlIHRocmVlIGNoYXJhY3RlcnMgbG9uZyBub3QgJHtub3RpY2VPYmplY3QuYm9va0lELmxlbmd0aH1gKTtcbiAgICAgIC8vcGFyYW1ldGVyQXNzZXJ0KG5vdGljZU9iamVjdC5ib29rSUQgPT09ICdPQlMnIHx8IGJvb2tzLmlzT3B0aW9uYWxWYWxpZEJvb2tJRChub3RpY2VPYmplY3QuYm9va0lEKSwgYGNSIGFkZE5vdGljZVBhcnRpYWw6ICcke25vdGljZU9iamVjdC5ib29rSUR9JyBpcyBub3QgYSB2YWxpZCBVU0ZNIGJvb2sgaWRlbnRpZmllcmApO1xuICAgIH1cbiAgICAvLyAvL3BhcmFtZXRlckFzc2VydChDICE9PSB1bmRlZmluZWQsIFwiY1IgYWRkTm90aWNlUGFydGlhbDogJ0MnIHBhcmFtZXRlciBzaG91bGQgYmUgZGVmaW5lZFwiKTtcbiAgICBpZiAobm90aWNlT2JqZWN0LkMpIHsgLy9wYXJhbWV0ZXJBc3NlcnQodHlwZW9mIG5vdGljZU9iamVjdC5DID09PSAnc3RyaW5nJywgYGNSIGFkZE5vdGljZVBhcnRpYWw6ICdDJyBwYXJhbWV0ZXIgc2hvdWxkIGJlIGEgc3RyaW5nIG5vdCBhICcke3R5cGVvZiBub3RpY2VPYmplY3QuQ30nYCk7XG4gICAgfVxuICAgIC8vIC8vcGFyYW1ldGVyQXNzZXJ0KFYgIT09IHVuZGVmaW5lZCwgXCJjUiBhZGROb3RpY2VQYXJ0aWFsOiAnVicgcGFyYW1ldGVyIHNob3VsZCBiZSBkZWZpbmVkXCIpO1xuICAgIGlmIChub3RpY2VPYmplY3QuVikgeyAvL3BhcmFtZXRlckFzc2VydCh0eXBlb2Ygbm90aWNlT2JqZWN0LlYgPT09ICdzdHJpbmcnLCBgY1IgYWRkTm90aWNlUGFydGlhbDogJ1YnIHBhcmFtZXRlciBzaG91bGQgYmUgYSBzdHJpbmcgbm90IGEgJyR7dHlwZW9mIG5vdGljZU9iamVjdC5WfSdgKTtcbiAgICB9XG4gICAgLy8gLy9wYXJhbWV0ZXJBc3NlcnQoY2hhcmFjdGVySW5kZXggIT09IHVuZGVmaW5lZCwgXCJjUiBhZGROb3RpY2VQYXJ0aWFsOiAnY2hhcmFjdGVySW5kZXgnIHBhcmFtZXRlciBzaG91bGQgYmUgZGVmaW5lZFwiKTtcbiAgICBpZiAobm90aWNlT2JqZWN0LmNoYXJhY3RlckluZGV4KSB7IC8vcGFyYW1ldGVyQXNzZXJ0KHR5cGVvZiBub3RpY2VPYmplY3QuY2hhcmFjdGVySW5kZXggPT09ICdudW1iZXInLCBgY1IgYWRkTm90aWNlUGFydGlhbDogJ2NoYXJhY3RlckluZGV4JyBwYXJhbWV0ZXIgc2hvdWxkIGJlIGEgbnVtYmVyIG5vdCBhICcke3R5cGVvZiBub3RpY2VPYmplY3QuY2hhcmFjdGVySW5kZXh9J2ApO1xuICAgIH1cbiAgICAvLyAvL3BhcmFtZXRlckFzc2VydChleGNlcnB0ICE9PSB1bmRlZmluZWQsIFwiY1IgYWRkTm90aWNlUGFydGlhbDogJ2V4Y2VycHQnIHBhcmFtZXRlciBzaG91bGQgYmUgZGVmaW5lZFwiKTtcbiAgICBpZiAobm90aWNlT2JqZWN0LmV4Y2VycHQpIHsgLy9wYXJhbWV0ZXJBc3NlcnQodHlwZW9mIG5vdGljZU9iamVjdC5leGNlcnB0ID09PSAnc3RyaW5nJywgYGNSIGFkZE5vdGljZVBhcnRpYWw6ICdleGNlcnB0JyBwYXJhbWV0ZXIgc2hvdWxkIGJlIGEgc3RyaW5nIG5vdCBhICcke3R5cGVvZiBub3RpY2VPYmplY3QuZXhjZXJwdH0nYCk7XG4gICAgfVxuICAgIC8vcGFyYW1ldGVyQXNzZXJ0KG5vdGljZU9iamVjdC5sb2NhdGlvbiAhPT0gdW5kZWZpbmVkLCBcImNSIGFkZE5vdGljZVBhcnRpYWw6ICdsb2NhdGlvbicgcGFyYW1ldGVyIHNob3VsZCBiZSBkZWZpbmVkXCIpO1xuICAgIC8vcGFyYW1ldGVyQXNzZXJ0KHR5cGVvZiBub3RpY2VPYmplY3QubG9jYXRpb24gPT09ICdzdHJpbmcnLCBgY1IgYWRkTm90aWNlUGFydGlhbDogJ2xvY2F0aW9uJyBwYXJhbWV0ZXIgc2hvdWxkIGJlIGEgc3RyaW5nIG5vdCBhICcke3R5cGVvZiBub3RpY2VPYmplY3QubG9jYXRpb259J2ApO1xuICAgIC8vIC8vcGFyYW1ldGVyQXNzZXJ0KG5vdGljZU9iamVjdC5leHRyYSAhPT0gdW5kZWZpbmVkLCBcImNSIGFkZE5vdGljZVBhcnRpYWw6ICdleHRyYScgcGFyYW1ldGVyIHNob3VsZCBiZSBkZWZpbmVkXCIpO1xuICAgIC8vcGFyYW1ldGVyQXNzZXJ0KHR5cGVvZiBub3RpY2VPYmplY3QuZXh0cmEgPT09ICdzdHJpbmcnLCBgY1IgYWRkTm90aWNlUGFydGlhbDogJ2V4dHJhJyBwYXJhbWV0ZXIgc2hvdWxkIGJlIGEgc3RyaW5nIG5vdCBhICcke3R5cGVvZiBub3RpY2VPYmplY3QuZXh0cmF9J2ApO1xuICAgIGlmIChub3RpY2VPYmplY3QuZGVidWdDaGFpbikgbm90aWNlT2JqZWN0LmRlYnVnQ2hhaW4gPSBgY2hlY2tSZXBvICR7bm90aWNlT2JqZWN0LmRlYnVnQ2hhaW59YDtcbiAgICAvLyBBZGQgaW4gdGhlIHJlcG9OYW1lIGZyb20gdGhlIG91dGVyIHNjb3BlXG4gICAgY2hlY2tSZXBvUmVzdWx0Lm5vdGljZUxpc3QucHVzaCh7IC4uLm5vdGljZU9iamVjdCwgdXNlcm5hbWUsIHJlcG9Db2RlLCByZXBvTmFtZSB9KTtcbiAgfVxuXG5cbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBib29rT3JGaWxlQ29kZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2ZCb29rSURcbiAgICogQHBhcmFtIHtzdHJpbmd9IGZpbGVuYW1lXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBmaWxlQ29udGVudFxuICAgKiBAcGFyYW0ge3N0cmluZ30gZmlsZUxvY2F0aW9uXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBjaGVja2luZ09wdGlvbnNcbiAgICovXG4gIGFzeW5jIGZ1bmN0aW9uIG91ckNoZWNrUmVwb0ZpbGVDb250ZW50cyhib29rT3JGaWxlQ29kZSwgY2ZCb29rSUQsIGZpbGVuYW1lLCBmaWxlQ29udGVudCwgZmlsZUxvY2F0aW9uLCBjaGVja2luZ09wdGlvbnMpIHtcbiAgICAvLyBXZSBhc3N1bWUgdGhhdCBjaGVja2luZyBmb3IgY29tcHVsc29yeSBmaWVsZHMgaXMgZG9uZSBlbHNld2hlcmVcbiAgICAvLyBmdW5jdGlvbkxvZyhgY2hlY2tSZXBvIG91ckNoZWNrUmVwb0ZpbGVDb250ZW50cyhiay9mQz0nJHtib29rT3JGaWxlQ29kZX0nLCBiaz0nJHtjZkJvb2tJRH0nLCBmbj0nJHtmaWxlbmFtZX0nLCAke2ZpbGVDb250ZW50Lmxlbmd0aH0sICR7ZmlsZUxvY2F0aW9ufSwgJHtKU09OLnN0cmluZ2lmeShjaGVja2luZ09wdGlvbnMpfSnigKZgKTtcblxuICAgIC8vIFVwZGF0ZXMgdGhlIGdsb2JhbCBsaXN0IG9mIG5vdGljZXNcbiAgICAvL3BhcmFtZXRlckFzc2VydChib29rT3JGaWxlQ29kZSAhPT0gdW5kZWZpbmVkLCBcIm91ckNoZWNrUmVwb0ZpbGVDb250ZW50czogJ2Jvb2tPckZpbGVDb2RlJyBwYXJhbWV0ZXIgc2hvdWxkIGJlIGRlZmluZWRcIik7XG4gICAgLy9wYXJhbWV0ZXJBc3NlcnQodHlwZW9mIGJvb2tPckZpbGVDb2RlID09PSAnc3RyaW5nJywgYG91ckNoZWNrUmVwb0ZpbGVDb250ZW50czogJ2Jvb2tPckZpbGVDb2RlJyBwYXJhbWV0ZXIgc2hvdWxkIGJlIGEgc3RyaW5nIG5vdCBhICcke3R5cGVvZiBib29rT3JGaWxlQ29kZX0nYCk7XG4gICAgLy9wYXJhbWV0ZXJBc3NlcnQoY2ZCb29rSUQgIT09IHVuZGVmaW5lZCwgXCJvdXJDaGVja1JlcG9GaWxlQ29udGVudHM6ICdjZkJvb2tJRCcgcGFyYW1ldGVyIHNob3VsZCBiZSBkZWZpbmVkXCIpO1xuICAgIC8vcGFyYW1ldGVyQXNzZXJ0KHR5cGVvZiBjZkJvb2tJRCA9PT0gJ3N0cmluZycsIGBvdXJDaGVja1JlcG9GaWxlQ29udGVudHM6ICdjZkJvb2tJRCcgcGFyYW1ldGVyIHNob3VsZCBiZSBhIHN0cmluZyBub3QgYSAnJHt0eXBlb2YgY2ZCb29rSUR9J2ApO1xuICAgIGlmIChjZkJvb2tJRCkge1xuICAgICAgLy9wYXJhbWV0ZXJBc3NlcnQoY2ZCb29rSUQubGVuZ3RoID09PSAzLCBgb3VyQ2hlY2tSZXBvRmlsZUNvbnRlbnRzOiAnY2ZCb29rSUQnIHBhcmFtZXRlciBzaG91bGQgYmUgdGhyZWUgY2hhcmFjdGVycyBsb25nIG5vdCAke2NmQm9va0lELmxlbmd0aH1gKTtcbiAgICAgIC8vcGFyYW1ldGVyQXNzZXJ0KGNmQm9va0lELnRvVXBwZXJDYXNlKCkgPT09IGNmQm9va0lELCBgb3VyQ2hlY2tSZXBvRmlsZUNvbnRlbnRzOiAnY2ZCb29rSUQnIHBhcmFtZXRlciBzaG91bGQgYmUgVVBQRVJDQVNFIG5vdCAnJHtjZkJvb2tJRH0nYCk7XG4gICAgICAvL3BhcmFtZXRlckFzc2VydChjZkJvb2tJRCA9PT0gJ09CUycgfHwgYm9va3MuaXNWYWxpZEJvb2tJRChjZkJvb2tJRCksIGBvdXJDaGVja1JlcG9GaWxlQ29udGVudHM6ICcke2NmQm9va0lEfScgaXMgbm90IGEgdmFsaWQgVVNGTSBib29rIGlkZW50aWZpZXJgKTtcbiAgICB9XG4gICAgLy9wYXJhbWV0ZXJBc3NlcnQoZmlsZW5hbWUgIT09IHVuZGVmaW5lZCwgXCJvdXJDaGVja1JlcG9GaWxlQ29udGVudHM6ICdmaWxlbmFtZScgcGFyYW1ldGVyIHNob3VsZCBiZSBkZWZpbmVkXCIpO1xuICAgIC8vcGFyYW1ldGVyQXNzZXJ0KHR5cGVvZiBmaWxlbmFtZSA9PT0gJ3N0cmluZycsIGBvdXJDaGVja1JlcG9GaWxlQ29udGVudHM6ICdmaWxlbmFtZScgcGFyYW1ldGVyIHNob3VsZCBiZSBhIHN0cmluZyBub3QgYSAnJHt0eXBlb2YgZmlsZW5hbWV9J2ApO1xuICAgIC8vcGFyYW1ldGVyQXNzZXJ0KGZpbGVDb250ZW50ICE9PSB1bmRlZmluZWQsIFwib3VyQ2hlY2tSZXBvRmlsZUNvbnRlbnRzOiAnZmlsZUNvbnRlbnQnIHBhcmFtZXRlciBzaG91bGQgYmUgZGVmaW5lZFwiKTtcbiAgICAvL3BhcmFtZXRlckFzc2VydCh0eXBlb2YgZmlsZUNvbnRlbnQgPT09ICdzdHJpbmcnLCBgb3VyQ2hlY2tSZXBvRmlsZUNvbnRlbnRzOiAnZmlsZUNvbnRlbnQnIHBhcmFtZXRlciBzaG91bGQgYmUgYSBzdHJpbmcgbm90IGEgJyR7dHlwZW9mIGZpbGVDb250ZW50fSdgKTtcbiAgICAvL3BhcmFtZXRlckFzc2VydChmaWxlTG9jYXRpb24gIT09IHVuZGVmaW5lZCwgXCJvdXJDaGVja1JlcG9GaWxlQ29udGVudHM6ICdmaWxlTG9jYXRpb24nIHBhcmFtZXRlciBzaG91bGQgYmUgZGVmaW5lZFwiKTtcbiAgICAvL3BhcmFtZXRlckFzc2VydCh0eXBlb2YgZmlsZUxvY2F0aW9uID09PSAnc3RyaW5nJywgYG91ckNoZWNrUmVwb0ZpbGVDb250ZW50czogJ2ZpbGVMb2NhdGlvbicgcGFyYW1ldGVyIHNob3VsZCBiZSBhIHN0cmluZyBub3QgYSAnJHt0eXBlb2YgZmlsZUxvY2F0aW9ufSdgKTtcbiAgICAvL3BhcmFtZXRlckFzc2VydChjaGVja2luZ09wdGlvbnMgIT09IHVuZGVmaW5lZCwgXCJvdXJDaGVja1JlcG9GaWxlQ29udGVudHM6ICdjaGVja2luZ09wdGlvbnMnIHBhcmFtZXRlciBzaG91bGQgYmUgZGVmaW5lZFwiKTtcblxuICAgIGxldCBhZGp1c3RlZExhbmd1YWdlQ29kZSA9IGxhbmd1YWdlQ29kZTtcbiAgICBpZiAoZmlsZW5hbWUgPT09ICdtYW5pZmVzdC55YW1sJyB8fCBmaWxlbmFtZSA9PT0gJ0xJQ0VOU0UubWQnXG4gICAgICB8fCAoKGxhbmd1YWdlQ29kZSA9PT0gJ2VsLXgta29pbmUnIHx8IGxhbmd1YWdlQ29kZSA9PT0gJ2hibycpICYmIGZpbGVuYW1lID09PSAnUkVBRE1FLm1kJykpXG4gICAgICBhZGp1c3RlZExhbmd1YWdlQ29kZSA9ICdlbic7IC8vIENvcnJlY3QgdGhlIGxhbmd1YWdlIGZvciB0aGVzZSBhdXhpbGxpYXJ5IGZpbGVzXG4gICAgY29uc3QgY2ZjUmVzdWx0T2JqZWN0ID0gYXdhaXQgY2hlY2tGaWxlQ29udGVudHModXNlcm5hbWUsIGFkanVzdGVkTGFuZ3VhZ2VDb2RlLCByZXBvQ29kZSwgcmVwb0JyYW5jaCwgZmlsZW5hbWUsIGZpbGVDb250ZW50LCBmaWxlTG9jYXRpb24sIGNoZWNraW5nT3B0aW9ucyk7XG4gICAgLy8gZGVidWdMb2coXCJjaGVja0ZpbGVDb250ZW50cygpIHJldHVybmVkXCIsIHJlc3VsdE9iamVjdC5zdWNjZXNzTGlzdC5sZW5ndGgsIFwic3VjY2VzcyBtZXNzYWdlKHMpIGFuZFwiLCByZXN1bHRPYmplY3Qubm90aWNlTGlzdC5sZW5ndGgsIFwibm90aWNlKHMpXCIpO1xuICAgIC8vIGZvciAoY29uc3Qgc3VjY2Vzc0VudHJ5IG9mIHJlc3VsdE9iamVjdC5zdWNjZXNzTGlzdClcbiAgICAvLyAgICAgdXNlckxvZyhcIiAgXCIsIHN1Y2Nlc3NFbnRyeSk7XG5cbiAgICAvLyBQcm9jZXNzIG5vdGljZUxpc3QgbGluZSBieSBsaW5lLCAgYXBwZW5kaW5nIHRoZSBib29rT3JGaWxlQ29kZSBhcyBhbiBleHRyYSBmaWVsZCBhcyB3ZSBnb1xuICAgIGZvciAoY29uc3QgY2ZjTm90aWNlRW50cnkgb2YgY2ZjUmVzdWx0T2JqZWN0Lm5vdGljZUxpc3QpXG4gICAgICAvLyBXZSBhZGQgdGhlIGJvb2tPckZpbGVDb2RlIGFzIGFuIGV4dHJhIHZhbHVlICh1bmxlc3MgaXTigJlzIGFscmVhZHkgdGhlcmUgZnJvbSBhIFRBIG9yIFRXIGNoZWNrKVxuICAgICAgaWYgKGNmY05vdGljZUVudHJ5LmV4dHJhKVxuICAgICAgICBjaGVja1JlcG9SZXN1bHQubm90aWNlTGlzdC5wdXNoKGNmY05vdGljZUVudHJ5KTsgLy8gQWRkIHRoaXMgbm90aWNlIGRpcmVjdGx5XG4gICAgICBlbHNlIHtcbiAgICAgICAgLy8gYWRkTm90aWNlUGFydGlhbCh7IC4uLmNmY05vdGljZUVudHJ5LCBib29rSUQ6IGNmQm9va0lELCBleHRyYTogYm9va09yRmlsZUNvZGUudG9VcHBlckNhc2UoKSB9KTtcbiAgICAgICAgY29uc3QgbmV3Tm90aWNlT2JqZWN0ID0geyAuLi5jZmNOb3RpY2VFbnRyeSwgYm9va0lEOiBjZkJvb2tJRCB9O1xuICAgICAgICBpZiAoYm9va09yRmlsZUNvZGUgIT09ICcwMScgLy8gVUdMIChmcm9tIGNvbnRlbnQvRzA0MjMwLzAxLm1kKVxuICAgICAgICAmJiAoYm9va09yRmlsZUNvZGVbMF0hPT0nSCcgfHwgYm9va09yRmlsZUNvZGUubGVuZ3RoIT09NSkpIC8vIFVIQUwsIGUuZy4sIEgwNjEyIGZyb20gY29udGVudC9IMDYxMi5tZFxuICAgICAgICAgIG5ld05vdGljZU9iamVjdC5leHRyYSA9IGJvb2tPckZpbGVDb2RlLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgIGFkZE5vdGljZVBhcnRpYWwobmV3Tm90aWNlT2JqZWN0KTtcbiAgICAgIH1cbiAgICAvKiBSZW1vdmluZyB0aGUgZm9sbG93aW5nIGNvZGUgYXMgaXTigJlzIHVubmVlZGVkXG4gICAgLy8gIGFzIHdlIGRvbuKAmXQgZW5hYmxlIFRBIG9yIFRXIGNoZWNraW5nIHBlciByZXBvIGFueXdheVxuICAgIC8vIEFueXdheSwgbm90IHN1cmUgdGhhdCB0aGUgZm9sbG93aW5nIGNvZGUgd2FzIHdvcmtpbmcgeWV0XG4gICAgaWYgKHJlcG9OYW1lLmVuZHNXaXRoKCdfdG4nKSkge1xuICAgICAgLy8gVGhlIGZvbGxvd2luZyBpcyBuZWVkZWQgY296IHdlIG1pZ2h0IGJlIGNoZWNraW5nIHRoZSBsaW5rZWQgVEEgYW5kL29yIFRXIGFydGljbGVzIGZyb20gVE4yIFRTViBmaWxlc1xuICAgICAgdXNlckxvZyhgY2ZjUmVzdWx0T2JqZWN0IEpTT04uc3RyaW5naWZ5KHsgLi4uY2ZjUmVzdWx0T2JqZWN0LCBub3RpY2VMaXN0OiBcImRlbGV0ZWRcIiB9KWApO1xuICAgICAgaWYgKGNmY1Jlc3VsdE9iamVjdC5jaGVja2VkRmlsZUNvdW50ICYmIGNmY1Jlc3VsdE9iamVjdC5jaGVja2VkRmlsZUNvdW50ID4gMCkge1xuICAgICAgICBjaGVja1JlcG9SZXN1bHQuY2hlY2tlZEZpbGVDb3VudCArPSBjZmNSZXN1bHRPYmplY3QuY2hlY2tlZEZpbGVDb3VudDtcbiAgICAgICAgYWRkU3VjY2Vzc01lc3NhZ2UoYENoZWNrZWQgJHtjZmNSZXN1bHRPYmplY3QuY2hlY2tlZEZpbGVDb3VudH0gbGlua2VkIFRBL1RXIGFydGljbGVzYCk7XG4gICAgICB9XG4gICAgICBpZiAoY2ZjUmVzdWx0T2JqZWN0LmNoZWNrZWRGaWxlc2l6ZXMgJiYgY2ZjUmVzdWx0T2JqZWN0LmNoZWNrZWRGaWxlc2l6ZXMgPiAwKSBjaGVja1JlcG9SZXN1bHQudG90YWxDaGVja2VkU2l6ZSArPSBjZmNSZXN1bHRPYmplY3QuY2hlY2tlZEZpbGVzaXplcztcbiAgICAgIGlmIChjZmNSZXN1bHRPYmplY3QuY2hlY2tlZFJlcG9OYW1lcyAmJiBjZmNSZXN1bHRPYmplY3QuY2hlY2tlZFJlcG9OYW1lcy5sZW5ndGggPiAwKVxuICAgICAgICBmb3IgKGNvbnN0IGNoZWNrZWRSZXBvTmFtZSBvZiBjZmNSZXN1bHRPYmplY3QuY2hlY2tlZFJlcG9OYW1lcylcbiAgICAgICAgICB0cnkgeyBpZiAoY2hlY2tSZXBvUmVzdWx0LmNoZWNrZWRSZXBvTmFtZXMuaW5kZXhPZihjaGVja2VkUmVwb05hbWUpIDwgMCkgY2hlY2tSZXBvUmVzdWx0LmNoZWNrZWRSZXBvTmFtZXMucHVzaChjaGVja2VkUmVwb05hbWUpOyB9XG4gICAgICAgICAgY2F0Y2ggeyBjaGVja1JlcG9SZXN1bHQuY2hlY2tlZFJlcG9OYW1lcyA9IFtjaGVja2VkUmVwb05hbWVdOyB9XG4gICAgICBpZiAoY2ZjUmVzdWx0T2JqZWN0LmNoZWNrZWRGaWxlbmFtZUV4dGVuc2lvbnMgJiYgY2ZjUmVzdWx0T2JqZWN0LmNoZWNrZWRGaWxlbmFtZUV4dGVuc2lvbnMubGVuZ3RoID4gMClcbiAgICAgICAgZm9yIChjb25zdCBjaGVja2VkRmlsZW5hbWVFeHRlbnNpb24gb2YgY2ZjUmVzdWx0T2JqZWN0LmNoZWNrZWRGaWxlbmFtZUV4dGVuc2lvbnMpXG4gICAgICAgICAgY2hlY2tSZXBvUmVzdWx0LmNoZWNrZWRGaWxlbmFtZUV4dGVuc2lvbnMuYWRkKGNoZWNrZWRGaWxlbmFtZUV4dGVuc2lvbik7XG4gICAgfVxuICAgICovXG4gIH1cbiAgLy8gZW5kIG9mIG91ckNoZWNrUmVwb0ZpbGVDb250ZW50cyBmdW5jdGlvblxuXG5cbiAgLy8gTWFpbiBjb2RlIGZvciBjaGVja1JlcG8oKVxuICBpZiAoISBhd2FpdCByZXBvc2l0b3J5RXhpc3RzT25Eb29yNDMoeyB1c2VybmFtZSwgcmVwb3NpdG9yeTogcmVwb05hbWUgfSkpIHtcbiAgICBzZXRSZXN1bHRWYWx1ZSg8cCBzdHlsZT17eyBjb2xvcjogJ3JlZCcgfX0+Tm8gc3VjaCA8Yj57dXNlcm5hbWV9L3tyZXBvTmFtZX08L2I+IHJlcG9zaXRvcnkhPC9wPik7XG4gICAgY29uc29sZS5lcnJvcihgY2hlY2tSZXBvICR7dXNlcm5hbWV9LyR7cmVwb05hbWV9IGRvZXNu4oCZdCBzZWVtIHRvIGV4aXN0YCk7XG4gICAgYWRkTm90aWNlUGFydGlhbCh7IHByaW9yaXR5OiA5ODYsIG1lc3NhZ2U6IFwiUmVwb3NpdG9yeSBkb2VzbuKAmXQgc2VlbSB0byBleGlzdFwiLCBkZXRhaWxzOiBgdXNlcm5hbWU9JHt1c2VybmFtZX1gLCBsb2NhdGlvbjogZ2l2ZW5Mb2NhdGlvbiwgZXh0cmE6IHJlcG9OYW1lIH0pO1xuICB9IGVsc2Uge1xuXG4gICAgLy8gUHV0IGFsbCB0aGlzIGluIGEgdHJ5L2NhdGNoIGJsb2NrIGNveiBvdGhlcndpc2UgaXTigJlzIGRpZmZpY3VsdCB0byBkZWJ1Zy92aWV3IGVycm9yc1xuICAgIHRyeSB7XG4gICAgICBsZXQgb3VyTG9jYXRpb24gPSBnaXZlbkxvY2F0aW9uO1xuICAgICAgaWYgKG91ckxvY2F0aW9uICYmIG91ckxvY2F0aW9uWzBdICE9PSAnICcpIG91ckxvY2F0aW9uID0gYCAke291ckxvY2F0aW9ufWA7XG4gICAgICAvLyBpZiAob3VyTG9jYXRpb24uaW5kZXhPZih1c2VybmFtZSkgPCAwKVxuICAgICAgLy8gb3VyTG9jYXRpb24gPSBgIGluICR7dXNlcm5hbWV9ICR7cmVwb05hbWV9ICR7Z2l2ZW5Mb2NhdGlvbn1gXG5cbiAgICAgIC8vIFVwZGF0ZSBvdXIgXCJ3YWl0aW5nXCIgbWVzc2FnZVxuICAgICAgc2V0UmVzdWx0VmFsdWUoPHAgc3R5bGU9e3sgY29sb3I6ICdtYWdlbnRhJyB9fT5GZXRjaGluZyB6aXBwZWQgZmlsZXMgZnJvbSA8Yj57dXNlcm5hbWV9L3tyZXBvTmFtZX08L2I+IHJlcG9zaXRvcnnigKY8L3A+KTtcblxuICAgICAgLy8gTGV04oCZcyBmZXRjaCB0aGUgemlwcGVkIHJlcG8gc2luY2UgaXQgc2hvdWxkIGJlIG11Y2ggbW9yZSBlZmZpY2llbnQgdGhhbiBpbmRpdmlkdWFsIGZldGNoZXNcbiAgICAgIC8vIGZ1bmN0aW9uTG9nKGBjaGVja1JlcG86IGZldGNoIHppcCBmaWxlIGZvciAke3JlcG9OYW1lfeKApmApO1xuICAgICAgY29uc3QgZmV0Y2hSZXBvc2l0b3J5WmlwRmlsZV8gPSAoY2hlY2tpbmdPcHRpb25zICYmIGNoZWNraW5nT3B0aW9ucy5mZXRjaFJlcG9zaXRvcnlaaXBGaWxlKSA/IGNoZWNraW5nT3B0aW9ucy5mZXRjaFJlcG9zaXRvcnlaaXBGaWxlIDogY2FjaGVkR2V0UmVwb3NpdG9yeVppcEZpbGU7XG4gICAgICBjb25zdCB6aXBGZXRjaFN1Y2NlZWRlZCA9IGF3YWl0IGZldGNoUmVwb3NpdG9yeVppcEZpbGVfKHsgdXNlcm5hbWUsIHJlcG9zaXRvcnk6IHJlcG9OYW1lLCBicmFuY2g6IHJlcG9CcmFuY2gsIGJyYW5jaE9yUmVsZWFzZTogcmVwb0JyYW5jaCB9KTtcbiAgICAgIGlmICghemlwRmV0Y2hTdWNjZWVkZWQpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihgY2hlY2tSZXBvOiBtaXNmZXRjaGVkIHppcCBmaWxlIGZvciByZXBvIHdpdGggJHt6aXBGZXRjaFN1Y2NlZWRlZH1gKTtcbiAgICAgICAgc2V0UmVzdWx0VmFsdWUoPHAgc3R5bGU9e3sgY29sb3I6ICdyZWQnIH19PkZhaWxlZCB0byBmZXRjaGluZyB6aXBwZWQgZmlsZXMgZnJvbSA8Yj57dXNlcm5hbWV9L3tyZXBvTmFtZX08L2I+IHJlcG9zaXRvcnk8L3A+KTtcbiAgICAgICAgYWRkTm90aWNlUGFydGlhbCh7IHByaW9yaXR5OiA5ODksIG1lc3NhZ2U6IFwiVW5hYmxlIHRvIGZpbmQvbG9hZCByZXBvc2l0b3J5XCIsIGxvY2F0aW9uOiBvdXJMb2NhdGlvbiB9KTtcbiAgICAgICAgcmV0dXJuIGNoZWNrUmVwb1Jlc3VsdDtcbiAgICAgIH1cblxuICAgICAgLy8gTm93IHdlIG5lZWQgdG8gZmV0Y2ggdGhlIGxpc3Qgb2YgZmlsZXMgZnJvbSB0aGUgcmVwb1xuICAgICAgc2V0UmVzdWx0VmFsdWUoPHAgc3R5bGU9e3sgY29sb3I6ICdtYWdlbnRhJyB9fT5QcmVwcm9jZXNzaW5nIGZpbGUgbGlzdCBmcm9tIDxiPnt1c2VybmFtZX0ve3JlcG9OYW1lfTwvYj4gcmVwb3NpdG9yeeKApjwvcD4pO1xuICAgICAgLy8gY29uc3QgcGF0aExpc3QgPSBhd2FpdCBnZXRGaWxlTGlzdEZyb21GZXRjaGVkVHJlZW1hcHModXNlcm5hbWUsIHJlcG9OYW1lLCBicmFuY2gpO1xuICAgICAgY29uc3QgZ2V0RmlsZUxpc3RGcm9tWmlwXyA9IGNoZWNraW5nT3B0aW9ucyAmJiBjaGVja2luZ09wdGlvbnMuZ2V0RmlsZUxpc3RGcm9tWmlwID8gY2hlY2tpbmdPcHRpb25zLmdldEZpbGVMaXN0RnJvbVppcCA6IGdldEZpbGVMaXN0RnJvbVppcDtcbiAgICAgIGNvbnN0IHBhdGhMaXN0ID0gYXdhaXQgZ2V0RmlsZUxpc3RGcm9tWmlwXyh7IHVzZXJuYW1lLCByZXBvc2l0b3J5OiByZXBvTmFtZSwgYnJhbmNoT3JSZWxlYXNlOiByZXBvQnJhbmNoIH0pO1xuICAgICAgLy8gZGVidWdMb2coYEdvdCBwYXRobGlzdCAoJHtwYXRoTGlzdC5sZW5ndGh9KSA9ICR7cGF0aExpc3R9YCk7XG5cblxuICAgICAgLy8gU28gbm93IHdlIHdhbnQgdG8gd29yayB0aHJvdWdoIGNoZWNraW5nIGFsbCB0aGUgZmlsZXMgaW4gdGhpcyByZXBvXG4gICAgICAvLyBNYWluIGxvb3AgZm9yIGNoZWNrUmVwbygpXG4gICAgICBjb25zdCBjb3VudFN0cmluZyA9IGAke3BhdGhMaXN0Lmxlbmd0aC50b0xvY2FsZVN0cmluZygpfSBmaWxlJHtwYXRoTGlzdC5sZW5ndGggPT09IDEgPyAnJyA6ICdzJ31gO1xuICAgICAgbGV0IGNoZWNrZWRGaWxlQ291bnQgPSAwLCBjaGVja2VkRmlsZW5hbWVzID0gW10sIGNoZWNrZWRGaWxlbmFtZUV4dGVuc2lvbnMgPSBuZXcgU2V0KCksIHRvdGFsQ2hlY2tlZFNpemUgPSAwO1xuICAgICAgZm9yIChjb25zdCB0aGlzRmlsZXBhdGggb2YgcGF0aExpc3QpIHtcbiAgICAgICAgLy8gZGVidWdMb2coYGNoZWNrUmVwbzogYXQgdG9wIG9mIGxvb3A6IHRoaXNGaWxlcGF0aD0nJHt0aGlzRmlsZXBhdGh9J2ApO1xuICAgICAgICAvLyBpZiAocmVwb0NvZGUgPT09ICdVSEFMJyB8fCByZXBvQ29kZSA9PT0gJ1VHTCcpIHsgLy8gdGVtcCAuLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uWFhYWFhYWFhYWFhYWFhYWFhYWFxuICAgICAgICAvLyAgIGlmICh0aGlzRmlsZXBhdGguc3RhcnRzV2l0aCgnTFhYX01hcHBpbmcvJykpIGNvbnRpbnVlOyAvLyBza2lwXG4gICAgICAgIC8vICAgaWYgKGNoZWNrZWRGaWxlQ291bnQgPiAxMDApIGJyZWFrO1xuICAgICAgICAvLyB9XG4gICAgICAgIGlmIChhYm9ydEZsYWcpIGJyZWFrO1xuXG4gICAgICAgIC8vIFVwZGF0ZSBvdXIgXCJ3YWl0aW5nXCIgbWVzc2FnZVxuICAgICAgICBzZXRSZXN1bHRWYWx1ZSg8cCBzdHlsZT17eyBjb2xvcjogJ21hZ2VudGEnIH19PkNoZWNraW5nIDxiPnt1c2VybmFtZX0ve3JlcG9OYW1lfTwvYj4gcmVwbzogY2hlY2tlZCB7Y2hlY2tlZEZpbGVDb3VudC50b0xvY2FsZVN0cmluZygpfS97Y291bnRTdHJpbmd94oCmPC9wPik7XG5cbiAgICAgICAgY29uc3QgdGhpc0ZpbGVuYW1lID0gdGhpc0ZpbGVwYXRoLnNwbGl0KCcvJykucG9wKCk7XG4gICAgICAgIC8vIGRlYnVnTG9nKGB0aGlzRmlsZW5hbWU9JHt0aGlzRmlsZW5hbWV9YCk7XG4gICAgICAgIGNvbnN0IHRoaXNGaWxlbmFtZUV4dGVuc2lvbiA9IHRoaXNGaWxlbmFtZS5zcGxpdCgnLicpLnBvcCgpO1xuICAgICAgICAvLyBkZWJ1Z0xvZyhgdGhpc0ZpbGVuYW1lRXh0ZW5zaW9uPSR7dGhpc0ZpbGVuYW1lRXh0ZW5zaW9ufWApO1xuXG4gICAgICAgIC8vIERlZmF1bHQgdG8gdGhlIG1haW4gZmlsZW5hbWUgd2l0aG91dCB0aGUgZXh0ZW5zaW9uXG4gICAgICAgIGxldCBib29rT3JGaWxlQ29kZSA9IHRoaXNGaWxlbmFtZS5zdWJzdHJpbmcoMCwgdGhpc0ZpbGVuYW1lLmxlbmd0aCAtIHRoaXNGaWxlbmFtZUV4dGVuc2lvbi5sZW5ndGggLSAxKTtcbiAgICAgICAgbGV0IG91ckJvb2tJRCA9ICcnO1xuICAgICAgICBpZiAodGhpc0ZpbGVuYW1lRXh0ZW5zaW9uID09PSAndXNmbScpIHtcbiAgICAgICAgICAvLyBjb25zdCBmaWxlbmFtZU1haW4gPSB0aGlzRmlsZW5hbWUuc3Vic3RyaW5nKDAsIHRoaXNGaWxlbmFtZS5sZW5ndGggLSA1KTsgLy8gZHJvcCAudXNmbVxuICAgICAgICAgIC8vIGRlYnVnTG9nKGBIYXZlIFVTRk0gZmlsZW5hbWVNYWluPSR7Ym9va09yRmlsZUNvZGV9YCk7XG4gICAgICAgICAgY29uc3QgYm9va0lEID0gYm9va09yRmlsZUNvZGUuc3Vic3RyaW5nKGJvb2tPckZpbGVDb2RlLmxlbmd0aCAtIDMpLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgICAgLy8gZGVidWdMb2coYEhhdmUgVVNGTSBib29rY29kZT0ke2Jvb2tJRH1gKTtcbiAgICAgICAgICAvL3BhcmFtZXRlckFzc2VydChib29rcy5pc1ZhbGlkQm9va0lEKGJvb2tJRCksIGBjaGVja1JlcG86ICcke2Jvb2tJRH0nIGlzIG5vdCBhIHZhbGlkIFVTRk0gYm9vayBpZGVudGlmaWVyIChmb3IgVVNGTSlgKTtcbiAgICAgICAgICBib29rT3JGaWxlQ29kZSA9IGJvb2tJRDtcbiAgICAgICAgICBvdXJCb29rSUQgPSBib29rSUQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpc0ZpbGVuYW1lRXh0ZW5zaW9uID09PSAndHN2Jykge1xuICAgICAgICAgIC8vIGRlYnVnTG9nKGBIYXZlIFRTViB0aGlzRmlsZW5hbWUoJHt0aGlzRmlsZW5hbWUubGVuZ3RofSk9JyR7dGhpc0ZpbGVuYW1lfSdgKTtcbiAgICAgICAgICAvLyBkZWJ1Z0xvZyhgSGF2ZSBUU1YgYm9va09yRmlsZUNvZGUoJHtib29rT3JGaWxlQ29kZS5sZW5ndGh9KT0nJHtib29rT3JGaWxlQ29kZX0nYCk7XG4gICAgICAgICAgbGV0IGJvb2tJRDtcbiAgICAgICAgICAvLyBib29rT3JGaWxlQ29kZSBjb3VsZCBiZSBzb21ldGhpbmcgbGlrZSAnZW5fdG5fMDktMVNBLnRzdiAnIG9yICd0bl8yQ08nIG9yICd0d2xfMUNIJ1xuICAgICAgICAgIC8vIGJvb2tJRCA9IChib29rT3JGaWxlQ29kZS5sZW5ndGggPT09IDYgfHwgYm9va09yRmlsZUNvZGUubGVuZ3RoID09PSA3KSA/IGJvb2tPckZpbGVDb2RlLnN1YnN0cmluZygwLCAzKSA6IGJvb2tPckZpbGVDb2RlLnNsaWNlKC0zKS50b1VwcGVyQ2FzZSgpO1xuICAgICAgICAgIGJvb2tJRCA9IGJvb2tPckZpbGVDb2RlLnNsaWNlKC0zKS50b1VwcGVyQ2FzZSgpO1xuICAgICAgICAgIGxvZ2ljQXNzZXJ0KGJvb2tJRCAhPT0gJ3R3bCcgJiYgYm9va0lEICE9PSAnVFdMJywgYFNob3VsZCBnZXQgYSB2YWxpZCBib29rSUQgaGVyZSwgbm90ICcke2Jvb2tJRH0nYClcbiAgICAgICAgICAvLyBkZWJ1Z0xvZyhgSGF2ZSBUU1YgYm9va2NvZGUoJHtib29rSUQubGVuZ3RofSk9JyR7Ym9va0lEfSdgKTtcbiAgICAgICAgICBpZiAocmVwb0NvZGUgPT09ICdUV0wnIHx8IHJlcG9Db2RlID09PSAnU04nIHx8IHJlcG9Db2RlID09PSAnU1EnIHx8IHJlcG9Db2RlID09PSAnVE4yJyB8fCByZXBvQ29kZSA9PT0gJ1RRMicpIHsvLyBuZXcgcmVwb3MgYWxsb3cgYE9CU2BcbiAgICAgICAgICAgIC8vcGFyYW1ldGVyQXNzZXJ0KGJvb2tJRCA9PT0gJ09CUycgfHwgYm9va3MuaXNWYWxpZEJvb2tJRChib29rSUQpLCBgY2hlY2tSZXBvOiAnJHtib29rSUR9JyBpcyBub3QgYSB2YWxpZCBVU0ZNIGJvb2sgaWRlbnRpZmllciAoZm9yIFRTVilgKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy9wYXJhbWV0ZXJBc3NlcnQoYm9va0lEICE9PSAnT0JTJyAmJiBib29rcy5pc1ZhbGlkQm9va0lEKGJvb2tJRCksIGBjaGVja1JlcG86ICcke2Jvb2tJRH0nIGlzIG5vdCBhIHZhbGlkIFVTRk0gYm9vayBpZGVudGlmaWVyIChmb3IgVFNWKWApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBib29rT3JGaWxlQ29kZSA9IGJvb2tJRDtcbiAgICAgICAgICBvdXJCb29rSUQgPSBib29rSUQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocmVwb05hbWUuZW5kc1dpdGgoJ190YScpICYmIHRoaXNGaWxlcGF0aC5pbmRleE9mKCcvJykgPiAwKVxuICAgICAgICAgIGJvb2tPckZpbGVDb2RlID0gdGhpc0ZpbGVwYXRoLnNwbGl0KCcvJylbMV07XG4gICAgICAgIGVsc2UgaWYgKHJlcG9OYW1lLmVuZHNXaXRoKCdfdHEnKSAmJiB0aGlzRmlsZXBhdGguaW5kZXhPZignLycpID4gMClcbiAgICAgICAgICBib29rT3JGaWxlQ29kZSA9IHRoaXNGaWxlcGF0aC5zcGxpdCgnLycpWzBdO1xuXG4gICAgICAgIC8vIGRlYnVnTG9nKFwiY2hlY2tSZXBvOiBUcnkgdG8gbG9hZFwiLCB1c2VybmFtZSwgcmVwb05hbWUsIHRoaXNGaWxlcGF0aCwgYnJhbmNoKTtcbiAgICAgICAgY29uc3QgZ2V0RmlsZV8gPSAoY2hlY2tpbmdPcHRpb25zICYmIGNoZWNraW5nT3B0aW9ucy5nZXRGaWxlKSA/IGNoZWNraW5nT3B0aW9ucy5nZXRGaWxlIDogY2FjaGVkR2V0RmlsZTtcbiAgICAgICAgbGV0IHJlcG9GaWxlQ29udGVudDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXBvRmlsZUNvbnRlbnQgPSBhd2FpdCBnZXRGaWxlXyh7IHVzZXJuYW1lLCByZXBvc2l0b3J5OiByZXBvTmFtZSwgcGF0aDogdGhpc0ZpbGVwYXRoLCBicmFuY2g6IHJlcG9CcmFuY2ggfSk7XG4gICAgICAgICAgLy8gZGVidWdMb2coXCJGZXRjaGVkIGZpbGVDb250ZW50IGZvclwiLCByZXBvTmFtZSwgdGhpc1BhdGgsIHR5cGVvZiByZXBvRmlsZUNvbnRlbnQsIHJlcG9GaWxlQ29udGVudC5sZW5ndGgpO1xuICAgICAgICB9IGNhdGNoIChjUmdmRXJyb3IpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKGBjaGVja1JlcG8oJHt1c2VybmFtZX0sICR7cmVwb05hbWV9LCAke3JlcG9CcmFuY2h9LCAke2dpdmVuTG9jYXRpb259LCAoZm4pLCAke0pTT04uc3RyaW5naWZ5KGNoZWNraW5nT3B0aW9ucyl9KSkgZmFpbGVkIHRvIGxvYWRgLCB0aGlzRmlsZXBhdGgsIHJlcG9CcmFuY2gsIGAke2NSZ2ZFcnJvcn1gKTtcbiAgICAgICAgICBsZXQgZGV0YWlscyA9IGB1c2VybmFtZT0ke3VzZXJuYW1lfWA7XG4gICAgICAgICAgaWYgKCEgYXdhaXQgcmVwb3NpdG9yeUV4aXN0c09uRG9vcjQzKHsgdXNlcm5hbWUsIHJlcG9zaXRvcnk6IHJlcG9OYW1lIH0pKVxuICAgICAgICAgICAgY2hlY2tSZXBvUmVzdWx0Lm5vdGljZUxpc3QucHVzaCh7IHByaW9yaXR5OiA5OTcsIG1lc3NhZ2U6IFwiUmVwb3NpdG9yeSBkb2VzbuKAmXQgZXhpc3RcIiwgZGV0YWlscywgdXNlcm5hbWUsIHJlcG9Db2RlLCByZXBvTmFtZSwgbG9jYXRpb246IGdpdmVuTG9jYXRpb24sIGV4dHJhOiByZXBvQ29kZSB9KTtcbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcWVxZXFcbiAgICAgICAgICAgIGlmIChjUmdmRXJyb3IgIT0gJ1R5cGVFcnJvcjogcmVwb0ZpbGVDb250ZW50IGlzIG51bGwnKSBkZXRhaWxzICs9IGAgZXJyb3I9JHtjUmdmRXJyb3J9YDtcbiAgICAgICAgICAgIGFkZE5vdGljZVBhcnRpYWwoeyBwcmlvcml0eTogOTk2LCBtZXNzYWdlOiBcIlVuYWJsZSB0byBsb2FkXCIsIGRldGFpbHM6IGB1c2VybmFtZT0ke3VzZXJuYW1lfSBlcnJvcj0ke2NSZ2ZFcnJvcn1gLCBib29rSUQ6IG91ckJvb2tJRCwgZmlsZW5hbWU6IHRoaXNGaWxlbmFtZSwgbG9jYXRpb246IGAke2dpdmVuTG9jYXRpb259ICR7dGhpc0ZpbGVwYXRofWAsIGV4dHJhOiByZXBvTmFtZSB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXBvRmlsZUNvbnRlbnQpIHtcbiAgICAgICAgICAvLyBmdW5jdGlvbkxvZyhgY2hlY2tSZXBvIGZvciAke3JlcG9OYW1lfSBjaGVja2luZyAke3RoaXNGaWxlbmFtZX1gKTtcbiAgICAgICAgICBhd2FpdCBvdXJDaGVja1JlcG9GaWxlQ29udGVudHMoYm9va09yRmlsZUNvZGUsIG91ckJvb2tJRCxcbiAgICAgICAgICAgIC8vIE9CUyBoYXMgbWFueSBmaWxlcyB3aXRoIHRoZSBzYW1lIG5hbWUsIHNvIHdlIGhhdmUgdG8gZ2l2ZSBzb21lIG9mIHRoZSBwYXRoIGFzIHdlbGxcbiAgICAgICAgICAgIC8vIHJlcG9OYW1lLmVuZHNXaXRoKCdfb2JzJykgPyB0aGlzRmlsZXBhdGgucmVwbGFjZSgnY29udGVudC8nLCAnJykgOiB0aGlzRmlsZW5hbWUsXG4gICAgICAgICAgICB0aGlzRmlsZW5hbWVFeHRlbnNpb24gPT09ICdtZCcgPyB0aGlzRmlsZXBhdGgucmVwbGFjZSgnY29udGVudC8nLCAnJykucmVwbGFjZSgnYmlibGUvJywgJycpIDogdGhpc0ZpbGVuYW1lLFxuICAgICAgICAgICAgcmVwb0ZpbGVDb250ZW50LCBvdXJMb2NhdGlvbiwgY2hlY2tpbmdPcHRpb25zKTtcbiAgICAgICAgICBjaGVja2VkRmlsZUNvdW50ICs9IDE7XG4gICAgICAgICAgY2hlY2tlZEZpbGVuYW1lcy5wdXNoKHRoaXNGaWxlbmFtZSk7XG4gICAgICAgICAgY2hlY2tlZEZpbGVuYW1lRXh0ZW5zaW9ucy5hZGQodGhpc0ZpbGVuYW1lRXh0ZW5zaW9uKTtcbiAgICAgICAgICB0b3RhbENoZWNrZWRTaXplICs9IHJlcG9GaWxlQ29udGVudC5sZW5ndGg7XG4gICAgICAgICAgLy8gZnVuY3Rpb25Mb2coYGNoZWNrUmVwbyBjaGVja2VkICR7dGhpc0ZpbGVuYW1lfWApO1xuICAgICAgICAgIGlmICh0aGlzRmlsZW5hbWVFeHRlbnNpb24gIT09ICdtZCcpIC8vIFRoZXJlJ3Mgb2Z0ZW4gZmFyLCBmYXIgdG9vIG1hbnkgb2YgdGhlc2VcbiAgICAgICAgICAgIGFkZFN1Y2Nlc3NNZXNzYWdlKGBDaGVja2VkICR7cmVwb05hbWV9ICR7Ym9va09yRmlsZUNvZGUudG9VcHBlckNhc2UoKX0gZmlsZTogJHt0aGlzRmlsZW5hbWV9YCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gQ2hlY2sgdGhhdCB3ZSBwcm9jZXNzZWQgYSBsaWNlbnNlIGFuZCBhIG1hbmlmZXN0XG4gICAgICBpZiAoY2hlY2tlZEZpbGVuYW1lcy5pbmRleE9mKCdMSUNFTlNFLm1kJykgPCAwKVxuICAgICAgICBhZGROb3RpY2VQYXJ0aWFsKHsgcHJpb3JpdHk6IDk0NiwgbWVzc2FnZTogXCJNaXNzaW5nIExJQ0VOU0UubWRcIiwgbG9jYXRpb246IG91ckxvY2F0aW9uLCBleHRyYTogYCR7cmVwb05hbWV9IExJQ0VOU0VgIH0pO1xuICAgICAgaWYgKGNoZWNrZWRGaWxlbmFtZXMuaW5kZXhPZignbWFuaWZlc3QueWFtbCcpIDwgMClcbiAgICAgICAgYWRkTm90aWNlUGFydGlhbCh7IHByaW9yaXR5OiA5NDcsIG1lc3NhZ2U6IFwiTWlzc2luZyBtYW5pZmVzdC55YW1sXCIsIGxvY2F0aW9uOiBvdXJMb2NhdGlvbiwgZXh0cmE6IGAke3JlcG9OYW1lfSBNQU5JRkVTVGAgfSk7XG5cbiAgICAgIC8vIEFkZCBzb21lIGV4dHJhIGZpZWxkcyB0byBvdXIgY2hlY2tSZXBvUmVzdWx0IG9iamVjdFxuICAgICAgLy8gIGluIGNhc2Ugd2UgbmVlZCB0aGlzIGluZm9ybWF0aW9uIGFnYWluIGxhdGVyXG4gICAgICBjaGVja1JlcG9SZXN1bHQuY2hlY2tlZEZpbGVDb3VudCArPSBjaGVja2VkRmlsZUNvdW50O1xuICAgICAgY2hlY2tSZXBvUmVzdWx0LmNoZWNrZWRGaWxlbmFtZXMgPSBjaGVja2VkRmlsZW5hbWVzO1xuICAgICAgY2hlY2tSZXBvUmVzdWx0LmNoZWNrZWRGaWxlbmFtZUV4dGVuc2lvbnMgPSBbLi4uY2hlY2tSZXBvUmVzdWx0LmNoZWNrZWRGaWxlbmFtZUV4dGVuc2lvbnMsIC4uLmNoZWNrZWRGaWxlbmFtZUV4dGVuc2lvbnNdOyAvLyBjb252ZXJ0IFNldCB0byBBcnJheVxuICAgICAgY2hlY2tSZXBvUmVzdWx0LmNoZWNrZWRGaWxlc2l6ZXMgKz0gdG90YWxDaGVja2VkU2l6ZTtcbiAgICAgIGNoZWNrUmVwb1Jlc3VsdC5jaGVja2VkUmVwb05hbWVzLnVuc2hpZnQoYCR7dXNlcm5hbWV9LyR7cmVwb05hbWV9YCk7XG4gICAgICAvLyBjaGVja1JlcG9SZXN1bHQuY2hlY2tlZE9wdGlvbnMgPSBjaGVja2luZ09wdGlvbnM7IC8vIFRoaXMgaXMgZG9uZSBhdCB0aGUgY2FsbGVyIGxldmVsXG5cbiAgICAgIGFkZFN1Y2Nlc3NNZXNzYWdlKGBDaGVja2VkICR7dXNlcm5hbWV9IHJlcG86ICR7cmVwb05hbWV9YCk7XG4gICAgICAvLyBmdW5jdGlvbkxvZyhgY2hlY2tSZXBvKCkgaXMgcmV0dXJuaW5nICR7Y2hlY2tSZXBvUmVzdWx0LnN1Y2Nlc3NMaXN0Lmxlbmd0aC50b0xvY2FsZVN0cmluZygpfSBzdWNjZXNzIG1lc3NhZ2UocykgYW5kICR7Y2hlY2tSZXBvUmVzdWx0Lm5vdGljZUxpc3QubGVuZ3RoLnRvTG9jYWxlU3RyaW5nKCl9IG5vdGljZShzKWApO1xuICAgIH0gY2F0Y2ggKGNSZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoYGNoZWNrUmVwbyBtYWluIGNvZGUgYmxvY2sgZ290IGVycm9yOiAke2NSZXJyb3IubWVzc2FnZX1gKTtcbiAgICAgIHNldFJlc3VsdFZhbHVlKDw+XG4gICAgICAgIDxwIHN0eWxlPXt7IGNvbG9yOiAncmVkJyB9fT5jaGVja1JlcG8gbWFpbiBjb2RlIGJsb2NrIGdvdCBlcnJvcjogPGI+e2NSZXJyb3IubWVzc2FnZX08L2I+IHdpdGgge2NSZXJyb3IudHJhY2V9PC9wPlxuICAgICAgPC8+KTtcblxuICAgIH1cbiAgfVxuICBjaGVja1JlcG9SZXN1bHQuZWxhcHNlZFNlY29uZHMgPSAobmV3IERhdGUoKSAtIHN0YXJ0VGltZSkgLyAxMDAwOyAvLyBzZWNvbmRzXG4gIC8vIGRlYnVnTG9nKGBjaGVja1JlcG8oKSByZXR1cm5pbmcgJHtKU09OLnN0cmluZ2lmeShjaGVja1JlcG9SZXN1bHQpfWApO1xuICByZXR1cm4gY2hlY2tSZXBvUmVzdWx0O1xufTtcbi8vIGVuZCBvZiBjaGVja1JlcG8oKVxuIl19