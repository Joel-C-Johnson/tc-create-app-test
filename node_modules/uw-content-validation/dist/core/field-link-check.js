"use strict";var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");Object.defineProperty(exports, "__esModule", { value: true });exports.startLiveLinksCheck = startLiveLinksCheck;exports.checkFieldLinks = checkFieldLinks;var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));
var _defaults = require("./defaults");
var _fieldTextCheck = require("./field-text-check");
var _getApi = require("./getApi");

var _utilities = require("./utilities");function _createForOfIteratorHelper(o, allowArrayLike) {var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];if (!it) {if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {if (it) o = it;var i = 0;var F = function F() {};return { s: F, n: function n() {if (i >= o.length) return { done: true };return { done: false, value: o[i++] };}, e: function e(_e) {throw _e;}, f: F };}throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");}var normalCompletion = true,didErr = false,err;return { s: function s() {it = it.call(o);}, n: function n() {var step = it.next();normalCompletion = step.done;return step;}, e: function e(_e2) {didErr = true;err = _e2;}, f: function f() {try {if (!normalCompletion && it.return != null) it.return();} finally {if (didErr) throw err;}} };}function _unsupportedIterableToArray(o, minLen) {if (!o) return;if (typeof o === "string") return _arrayLikeToArray(o, minLen);var n = Object.prototype.toString.call(o).slice(8, -1);if (n === "Object" && o.constructor) n = o.constructor.name;if (n === "Map" || n === "Set") return Array.from(o);if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);}function _arrayLikeToArray(arr, len) {if (len == null || len > arr.length) len = arr.length;for (var i = 0, arr2 = new Array(len); i < len; i++) {arr2[i] = arr[i];}return arr2;}


var LINK_VALIDATOR_VERSION_STRING = '0.3.5';function


startLiveLinksCheck(_x, _x2, _x3) {return _startLiveLinksCheck.apply(this, arguments);}













































/**
 *
 * @param {string} languageCode
 * @param {string} repoCode
 * @param {string} fieldName
 * @param {string} fieldText
 * @param {Object} linkOptions
 * @param {string} optionalFieldLocation
 * @param {Object} checkingOptions
 */function _startLiveLinksCheck() {_startLiveLinksCheck = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee(linksList, existingNoticeList, callbackFunction) {var result, addNoticePartial, _iterator2, _step2, linkEntry, fetchLink, responseData, responseText;return _regenerator.default.wrap(function _callee$(_context) {while (1) {switch (_context.prev = _context.next) {case 0:addNoticePartial = function _addNoticePartial(_ref2) {var priority = _ref2.priority,message = _ref2.message,characterIndex = _ref2.characterIndex,excerpt = _ref2.excerpt,location = _ref2.location;(0, _utilities.userLog)("sLLC Link Notice: (priority=".concat(priority, ") ").concat(message).concat(characterIndex > 0 ? " (at character ".concat(characterIndex, ")") : "").concat(excerpt ? " ".concat(excerpt) : "").concat(location)); //parameterAssert(priority !== undefined, "sLLC addNoticePartial: 'priority' parameter should be defined");
              //parameterAssert(typeof priority === 'number', `sLLC addNoticePartial: 'priority' parameter should be a number not a '${typeof priority}': ${priority}`);
              //parameterAssert(message !== undefined, "sLLC addNoticePartial: 'message' parameter should be defined");
              //parameterAssert(typeof message === 'string', `sLLC addNoticePartial: 'message' parameter should be a string not a '${typeof message}':${message}`);
              // //parameterAssert(characterIndex!==undefined, "sLLC addNoticePartial: 'characterIndex' parameter should be defined");
              if (characterIndex) {//parameterAssert(typeof characterIndex === 'number', `sLLC addNoticePartial: 'characterIndex' parameter should be a number not a '${typeof characterIndex}': ${characterIndex}`);
              } // //parameterAssert(excerpt!==undefined, "sLLC addNoticePartial: 'excerpt' parameter should be defined");
              if (excerpt) {//parameterAssert(typeof excerpt === 'string', `sLLC addNoticePartial: 'excerpt' parameter should be a string not a '${typeof excerpt}': ${excerpt}`);
              } // //parameterAssert(location!==undefined, "sLLC addNoticePartial: 'location' parameter should be defined");
              // //parameterAssert(typeof location==='string', `sLLC addNoticePartial: 'location' parameter should be a string not a '${typeof location}': ${location}`);
              result.noticeList.push({ priority: priority, message: message, characterIndex: characterIndex, excerpt: excerpt, location: location });}; // This (IO bound) function checks the targets of the given links
            //  to ensure that they actually exist
            // NOTE: no caching yet
            (0, _utilities.userLog)("startLiveLinksCheck v".concat(LINK_VALIDATOR_VERSION_STRING, " for ").concat(linksList.length, " link(s)\u2026")); // debugLog(`startLiveLinksCheck was given ${existingNoticeList.length} warnings.`)
            result = { noticeList: existingNoticeList }; // Now try fetching each link in turn
            _iterator2 = _createForOfIteratorHelper(linksList);_context.prev = 4;_iterator2.s();case 6:if ((_step2 = _iterator2.n()).done) {_context.next = 25;break;}linkEntry = _step2.value;(0, _utilities.userLog)("startLiveLinksCheck linkEntry", JSON.stringify(linkEntry));fetchLink = linkEntry[1] ? linkEntry[1] : linkEntry[2]; // Why ??? !!!
            (0, _utilities.userLog)("startLiveLinksCheck attempting to fetch", fetchLink, '…');_context.prev = 11;_context.next = 14;return (0, _getApi.cachedGetFileUsingFullURL)(fetchLink);case 14:responseData = _context.sent;responseText = responseData;(0, _utilities.userLog)("startLiveLinksCheck got response: ", responseText.length);_context.next = 23;break;case 19:_context.prev = 19;_context.t0 = _context["catch"](11);console.error("startLiveLinksCheck had an error fetching '".concat(fetchLink, "': ").concat(_context.t0));addNoticePartial({ priority: 439, message: "Error fetching link", location: " ".concat(fetchLink) });case 23:_context.next = 6;break;case 25:_context.next = 30;break;case 27:_context.prev = 27;_context.t1 = _context["catch"](4);_iterator2.e(_context.t1);case 30:_context.prev = 30;_iterator2.f();return _context.finish(30);case 33:(0, _utilities.userLog)("startLiveLinksCheck calling callback function…");callbackFunction(result);case 35:case "end":return _context.stop();}}}, _callee, null, [[4, 27, 30, 33], [11, 19]]);}));return _startLiveLinksCheck.apply(this, arguments);}function checkFieldLinks(languageCode, repoCode, fieldName, fieldText, linkOptions, optionalFieldLocation, checkingOptions) {// Does basic checks for fields that are links or that contain links
  // NOTE: This function is currently only called from field-link-check.md!!!
  //          TODO: Does it need to be deleted (or finished) ???
  // We assume that checking for compulsory fields is done elsewhere
  // Returns an error list and a warning list
  //  Both lists contain lists of two strings:
  //      1/ the error string
  //      2/ the detailed location string
  //  (Returned in this way for more intelligent processing at a higher level)
  (0, _utilities.userLog)("checkFieldLinks('".concat(languageCode, "', '").concat(repoCode, "', '").concat(fieldName, "', '").concat(fieldText, "', ").concat(JSON.stringify(linkOptions), ", '").concat(optionalFieldLocation, "', ").concat(JSON.stringify(checkingOptions), ")\u2026")); // debugLog( "linkOptions", JSON.stringify(linkOptions));
  // debugLog( "linkOptionsEC", linkOptions.expectedCount);
  //parameterAssert(languageCode !== undefined, "checkFieldLinks: 'languageCode' parameter should be defined");
  //parameterAssert(typeof languageCode === 'string', `checkFieldLinks: 'languageCode' parameter should be a string not a '${typeof languageCode}': ${languageCode}`);
  //parameterAssert(repoCode !== undefined, "checkFieldLinks: 'repoCode' parameter should be defined");
  //parameterAssert(typeof repoCode === 'string', `checkFieldLinks: 'repoCode' parameter should be a string not a '${typeof repoCode}': ${repoCode}`);
  //parameterAssert(REPO_CODES_LIST.includes(repoCode), `checkFieldLinks: 'repoCode' parameter should not be '${repoCode}'`);
  //parameterAssert(fieldName !== undefined, "checkFieldLinks: 'fieldName' parameter should be defined");
  //parameterAssert(typeof fieldName === 'string', `checkFieldLinks: 'fieldName' parameter should be a string not a '${typeof fieldName}': ${fieldName}`);
  //parameterAssert(fieldText !== undefined, "checkFieldLinks: 'fieldText' parameter should be defined");
  //parameterAssert(typeof fieldText === 'string', `checkFieldLinks: 'fieldText' parameter should be a string not a '${typeof fieldText}': ${fieldText}`);
  //parameterAssert(optionalFieldLocation !== undefined, "checkFieldLinks: 'optionalFieldLocation' parameter should be defined");
  //parameterAssert(typeof optionalFieldLocation === 'string', `checkFieldLinks: 'optionalFieldLocation' parameter should be a string not a '${typeof optionalFieldLocation}': ${optionalFieldLocation}`);
  //parameterAssert(optionalFieldLocation.indexOf('true') === -1, `checkFieldLinks: 'optionalFieldLocation' parameter should not be '${optionalFieldLocation}'`);
  var ourLocation = optionalFieldLocation;if (ourLocation && ourLocation[0] !== ' ') ourLocation = " ".concat(ourLocation);var result = { noticeList: [] };function addNoticePartial(_ref) {var priority = _ref.priority,message = _ref.message,characterIndex = _ref.characterIndex,excerpt = _ref.excerpt,location = _ref.location;(0, _utilities.userLog)("cFLs addNoticePartial: (priority=".concat(priority, ") ").concat(message).concat(characterIndex > 0 ? " (at character ".concat(characterIndex, ")") : "").concat(excerpt ? " ".concat(excerpt) : "").concat(location)); //parameterAssert(priority !== undefined, "cFLs addNoticePartial: 'priority' parameter should be defined");
    //parameterAssert(typeof priority === 'number', `cFLs addNoticePartial: 'priority' parameter should be a number not a '${typeof priority}': ${priority}`);
    //parameterAssert(message !== undefined, "cFLs addNoticePartial: 'message' parameter should be defined");
    //parameterAssert(typeof message === 'string', `cFLs addNoticePartial: 'message' parameter should be a string not a '${typeof message}': ${message}`);
    // //parameterAssert(characterIndex!==undefined, "cFLs addNoticePartial: 'characterIndex' parameter should be defined");
    if (characterIndex) {//parameterAssert(typeof characterIndex === 'number', `cFLs addNoticePartial: 'characterIndex' parameter should be a number not a '${typeof characterIndex}': ${characterIndex}`);
    } // //parameterAssert(excerpt!==undefined, "cFLs addNoticePartial: 'excerpt' parameter should be defined");
    if (excerpt) {//parameterAssert(typeof excerpt === 'string', `cFLs addNoticePartial: 'excerpt' parameter should be a string not a '${typeof excerpt}': ${excerpt}`);
    }
    //parameterAssert(location !== undefined, "cFLs addNoticePartial: 'location' parameter should be defined");
    //parameterAssert(typeof location === 'string', `cFLs addNoticePartial: 'location' parameter should be a string not a '${typeof location}': ${location}`);

    result.noticeList.push({ priority: priority, message: message, characterIndex: characterIndex, excerpt: excerpt, location: location });
  }

  // // Create our more detailed location string by prepending the fieldName
  // let ourAtString = ` in '${fieldName}'`;
  // if (optionalFieldLocation) {
  //     if (optionalFieldLocation[0] !== ' ') ourAtString += ' ';
  //     ourAtString += optionalFieldLocation;
  // }


  if (!fieldText) {// Nothing to check
    if (linkOptions.expectedCount > 0)
    addNoticePartial({ priority: 438, message: "Blank field / missing link (expected ".concat(linkOptions.expectedCount, " link").concat(linkOptions.expectedCount === 1 ? "" : "s", ")"), location: ourLocation });
    return result;
  }

  // Ok, we have something in our field
  if (linkOptions.otherTextAllowed)
  result = (0, _fieldTextCheck.checkTextField)(languageCode, repoCode, 'link', fieldName, fieldText, true, optionalFieldLocation, checkingOptions);

  // Parameter nonsense check
  if (linkOptions.allowedCount > 0 && linkOptions.expectedCount > linkOptions.allowedCount)
  addNoticePartial({ priority: 111, message: "Bad options for checkFieldLinks: expectedCount=".concat(linkOptions.expectedCount, " but allowedCount=").concat(linkOptions.allowedCount) });

  // Check for embedded links
  // First, create our regex from the allowed link types
  var linkRegexParts;
  if (linkOptions.linkTypesAllowed) {
    linkRegexParts = [];var _iterator = _createForOfIteratorHelper(
    linkOptions.linkTypesAllowed),_step;try {for (_iterator.s(); !(_step = _iterator.n()).done;) {var linkType = _step.value;
        // debugLog("checkFieldLinks linkType", linkType);
        if (linkType === 'RC')
        linkRegexParts.push('(rc://[^ ]+)');else
        if (linkType === 'md') {
          linkRegexParts.push('\\[\\[(https*://[^ ]+)\\]\\]'); // [[link]]
          linkRegexParts.push(']\\((https*://[^ ]+)\\)'); // [this](link)
        } else
        if (linkType === 'naked')
        linkRegexParts.push('(https*://[^ ]+)');else

        addNoticePartial({ priority: 441, message: "Unknown linkType parameter", excerpt: linkType });
      }} catch (err) {_iterator.e(err);} finally {_iterator.f();}
  } else {// No link types specified
    linkRegexParts = [];
  }
  // debugLog("checkFieldLinks linkRegexParts", JSON.stringify(linkRegexParts));
  var linkRegex = new RegExp(linkRegexParts.join('|'), 'g');
  // debugLog("linkRegex", JSON.stringify(linkRegex));
  // const regexResults = fieldText.matchAll(linkRegex);
  // debugLog("regexResults", regexResults.length, JSON.stringify(regexResults));
  var regexResultsArray = (0, _toConsumableArray2.default)(fieldText.matchAll(linkRegex));
  // debugLog("checkFieldLinks regexResultsArray", regexResultsArray.length, JSON.stringify(regexResultsArray));

  if (regexResultsArray.length < linkOptions.expectedCount)
  addNoticePartial({ priority: 287, message: "Not enough links (expected ".concat(linkOptions.expectedCount, " link").concat(linkOptions.expectedCount === 1 ? "" : "s", ")"), location: " (only found ".concat(regexResultsArray.length, ")").concat(ourLocation) });

  if (linkOptions.checkTargets && linkOptions.callbackFunction && regexResultsArray) {
    startLiveLinksCheck(regexResultsArray, result.noticeList.slice(0), linkOptions.callbackFunction);
    addNoticePartial({ priority: 600, message: "".concat(regexResultsArray.length, " link target").concat(regexResultsArray.length === 1 ? ' is' : 's are', " still being checked\u2026"), location: ourLocation });
    (0, _utilities.userLog)("checkFieldLinks now returning initial result…");
  }

  (0, _utilities.userLog)("  checkFieldLinks v".concat(LINK_VALIDATOR_VERSION_STRING, " returning with ").concat(result.noticeList.length, " notices."));
  return result;
}
// end of checkFieldLinks function
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9jb3JlL2ZpZWxkLWxpbmstY2hlY2suanMiXSwibmFtZXMiOlsiTElOS19WQUxJREFUT1JfVkVSU0lPTl9TVFJJTkciLCJzdGFydExpdmVMaW5rc0NoZWNrIiwibGlua3NMaXN0IiwiZXhpc3RpbmdOb3RpY2VMaXN0IiwiY2FsbGJhY2tGdW5jdGlvbiIsImFkZE5vdGljZVBhcnRpYWwiLCJwcmlvcml0eSIsIm1lc3NhZ2UiLCJjaGFyYWN0ZXJJbmRleCIsImV4Y2VycHQiLCJsb2NhdGlvbiIsInJlc3VsdCIsIm5vdGljZUxpc3QiLCJwdXNoIiwibGVuZ3RoIiwibGlua0VudHJ5IiwiSlNPTiIsInN0cmluZ2lmeSIsImZldGNoTGluayIsInJlc3BvbnNlRGF0YSIsInJlc3BvbnNlVGV4dCIsImNvbnNvbGUiLCJlcnJvciIsImNoZWNrRmllbGRMaW5rcyIsImxhbmd1YWdlQ29kZSIsInJlcG9Db2RlIiwiZmllbGROYW1lIiwiZmllbGRUZXh0IiwibGlua09wdGlvbnMiLCJvcHRpb25hbEZpZWxkTG9jYXRpb24iLCJjaGVja2luZ09wdGlvbnMiLCJvdXJMb2NhdGlvbiIsImV4cGVjdGVkQ291bnQiLCJvdGhlclRleHRBbGxvd2VkIiwiYWxsb3dlZENvdW50IiwibGlua1JlZ2V4UGFydHMiLCJsaW5rVHlwZXNBbGxvd2VkIiwibGlua1R5cGUiLCJsaW5rUmVnZXgiLCJSZWdFeHAiLCJqb2luIiwicmVnZXhSZXN1bHRzQXJyYXkiLCJtYXRjaEFsbCIsImNoZWNrVGFyZ2V0cyIsInNsaWNlIl0sIm1hcHBpbmdzIjoiO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHdDOzs7QUFHQSxJQUFNQSw2QkFBNkIsR0FBRyxPQUF0QyxDOzs7QUFHc0JDLG1COzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBOEN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHLGdJQXZETyxpQkFBbUNDLFNB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LGlCQUFpQixDQUFDM0IsTUFBdkIseUJBQTRDMkIsaUJBQWlCLENBQUMzQixNQUFsQixLQUE2QixDQUE3QixHQUFpQyxLQUFqQyxHQUF5QyxPQUFyRiwrQkFBeEIsRUFBNklKLFFBQVEsRUFBRXFCLFdBQXZKLEVBQUQsQ0FBaEI7QUFDQSw0QkFBUSwrQ0FBUjtBQUNIOztBQUVELHVEQUE4Qi9CLDZCQUE5Qiw2QkFBOEVXLE1BQU0sQ0FBQ0MsVUFBUCxDQUFrQkUsTUFBaEc7QUFDQSxTQUFPSCxNQUFQO0FBQ0g7QUFDRCIsInNvdXJjZXNDb250ZW50IjpbIi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtdmFyc1xuaW1wb3J0IHsgUkVQT19DT0RFU19MSVNUIH0gZnJvbSAnLi9kZWZhdWx0cyc7XG5pbXBvcnQgeyBjaGVja1RleHRGaWVsZCB9IGZyb20gJy4vZmllbGQtdGV4dC1jaGVjaydcbmltcG9ydCB7IGNhY2hlZEdldEZpbGVVc2luZ0Z1bGxVUkwgfSBmcm9tICcuL2dldEFwaSc7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLXZhcnNcbmltcG9ydCB7IHVzZXJMb2csIHBhcmFtZXRlckFzc2VydCB9IGZyb20gJy4vdXRpbGl0aWVzJztcblxuXG5jb25zdCBMSU5LX1ZBTElEQVRPUl9WRVJTSU9OX1NUUklORyA9ICcwLjMuNSc7XG5cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHN0YXJ0TGl2ZUxpbmtzQ2hlY2sobGlua3NMaXN0LCBleGlzdGluZ05vdGljZUxpc3QsIGNhbGxiYWNrRnVuY3Rpb24pIHtcbiAgICAvLyBUaGlzIChJTyBib3VuZCkgZnVuY3Rpb24gY2hlY2tzIHRoZSB0YXJnZXRzIG9mIHRoZSBnaXZlbiBsaW5rc1xuICAgIC8vICB0byBlbnN1cmUgdGhhdCB0aGV5IGFjdHVhbGx5IGV4aXN0XG4gICAgLy8gTk9URTogbm8gY2FjaGluZyB5ZXRcbiAgICB1c2VyTG9nKGBzdGFydExpdmVMaW5rc0NoZWNrIHYke0xJTktfVkFMSURBVE9SX1ZFUlNJT05fU1RSSU5HfSBmb3IgJHtsaW5rc0xpc3QubGVuZ3RofSBsaW5rKHMp4oCmYClcbiAgICAvLyBkZWJ1Z0xvZyhgc3RhcnRMaXZlTGlua3NDaGVjayB3YXMgZ2l2ZW4gJHtleGlzdGluZ05vdGljZUxpc3QubGVuZ3RofSB3YXJuaW5ncy5gKVxuXG4gICAgbGV0IHJlc3VsdCA9IHsgbm90aWNlTGlzdDogZXhpc3RpbmdOb3RpY2VMaXN0IH07XG5cbiAgICBmdW5jdGlvbiBhZGROb3RpY2VQYXJ0aWFsKHsgcHJpb3JpdHksIG1lc3NhZ2UsIGNoYXJhY3RlckluZGV4LCBleGNlcnB0LCBsb2NhdGlvbiB9KSB7XG4gICAgICAgIHVzZXJMb2coYHNMTEMgTGluayBOb3RpY2U6IChwcmlvcml0eT0ke3ByaW9yaXR5fSkgJHttZXNzYWdlfSR7Y2hhcmFjdGVySW5kZXggPiAwID8gYCAoYXQgY2hhcmFjdGVyICR7Y2hhcmFjdGVySW5kZXh9KWAgOiBcIlwifSR7ZXhjZXJwdCA/IGAgJHtleGNlcnB0fWAgOiBcIlwifSR7bG9jYXRpb259YCk7XG4gICAgICAgIC8vcGFyYW1ldGVyQXNzZXJ0KHByaW9yaXR5ICE9PSB1bmRlZmluZWQsIFwic0xMQyBhZGROb3RpY2VQYXJ0aWFsOiAncHJpb3JpdHknIHBhcmFtZXRlciBzaG91bGQgYmUgZGVmaW5lZFwiKTtcbiAgICAgICAgLy9wYXJhbWV0ZXJBc3NlcnQodHlwZW9mIHByaW9yaXR5ID09PSAnbnVtYmVyJywgYHNMTEMgYWRkTm90aWNlUGFydGlhbDogJ3ByaW9yaXR5JyBwYXJhbWV0ZXIgc2hvdWxkIGJlIGEgbnVtYmVyIG5vdCBhICcke3R5cGVvZiBwcmlvcml0eX0nOiAke3ByaW9yaXR5fWApO1xuICAgICAgICAvL3BhcmFtZXRlckFzc2VydChtZXNzYWdlICE9PSB1bmRlZmluZWQsIFwic0xMQyBhZGROb3RpY2VQYXJ0aWFsOiAnbWVzc2FnZScgcGFyYW1ldGVyIHNob3VsZCBiZSBkZWZpbmVkXCIpO1xuICAgICAgICAvL3BhcmFtZXRlckFzc2VydCh0eXBlb2YgbWVzc2FnZSA9PT0gJ3N0cmluZycsIGBzTExDIGFkZE5vdGljZVBhcnRpYWw6ICdtZXNzYWdlJyBwYXJhbWV0ZXIgc2hvdWxkIGJlIGEgc3RyaW5nIG5vdCBhICcke3R5cGVvZiBtZXNzYWdlfSc6JHttZXNzYWdlfWApO1xuICAgICAgICAvLyAvL3BhcmFtZXRlckFzc2VydChjaGFyYWN0ZXJJbmRleCE9PXVuZGVmaW5lZCwgXCJzTExDIGFkZE5vdGljZVBhcnRpYWw6ICdjaGFyYWN0ZXJJbmRleCcgcGFyYW1ldGVyIHNob3VsZCBiZSBkZWZpbmVkXCIpO1xuICAgICAgICBpZiAoY2hhcmFjdGVySW5kZXgpIHsgLy9wYXJhbWV0ZXJBc3NlcnQodHlwZW9mIGNoYXJhY3RlckluZGV4ID09PSAnbnVtYmVyJywgYHNMTEMgYWRkTm90aWNlUGFydGlhbDogJ2NoYXJhY3RlckluZGV4JyBwYXJhbWV0ZXIgc2hvdWxkIGJlIGEgbnVtYmVyIG5vdCBhICcke3R5cGVvZiBjaGFyYWN0ZXJJbmRleH0nOiAke2NoYXJhY3RlckluZGV4fWApO1xuICAgICAgICB9XG4gICAgICAgIC8vIC8vcGFyYW1ldGVyQXNzZXJ0KGV4Y2VycHQhPT11bmRlZmluZWQsIFwic0xMQyBhZGROb3RpY2VQYXJ0aWFsOiAnZXhjZXJwdCcgcGFyYW1ldGVyIHNob3VsZCBiZSBkZWZpbmVkXCIpO1xuICAgICAgICBpZiAoZXhjZXJwdCkgeyAvL3BhcmFtZXRlckFzc2VydCh0eXBlb2YgZXhjZXJwdCA9PT0gJ3N0cmluZycsIGBzTExDIGFkZE5vdGljZVBhcnRpYWw6ICdleGNlcnB0JyBwYXJhbWV0ZXIgc2hvdWxkIGJlIGEgc3RyaW5nIG5vdCBhICcke3R5cGVvZiBleGNlcnB0fSc6ICR7ZXhjZXJwdH1gKTtcbiAgICAgICAgfVxuICAgICAgICAvLyAvL3BhcmFtZXRlckFzc2VydChsb2NhdGlvbiE9PXVuZGVmaW5lZCwgXCJzTExDIGFkZE5vdGljZVBhcnRpYWw6ICdsb2NhdGlvbicgcGFyYW1ldGVyIHNob3VsZCBiZSBkZWZpbmVkXCIpO1xuICAgICAgICAvLyAvL3BhcmFtZXRlckFzc2VydCh0eXBlb2YgbG9jYXRpb249PT0nc3RyaW5nJywgYHNMTEMgYWRkTm90aWNlUGFydGlhbDogJ2xvY2F0aW9uJyBwYXJhbWV0ZXIgc2hvdWxkIGJlIGEgc3RyaW5nIG5vdCBhICcke3R5cGVvZiBsb2NhdGlvbn0nOiAke2xvY2F0aW9ufWApO1xuICAgICAgICByZXN1bHQubm90aWNlTGlzdC5wdXNoKHsgcHJpb3JpdHksIG1lc3NhZ2UsIGNoYXJhY3RlckluZGV4LCBleGNlcnB0LCBsb2NhdGlvbiB9KTtcbiAgICB9XG5cbiAgICAvLyBOb3cgdHJ5IGZldGNoaW5nIGVhY2ggbGluayBpbiB0dXJuXG4gICAgZm9yIChjb25zdCBsaW5rRW50cnkgb2YgbGlua3NMaXN0KSB7XG4gICAgICAgIHVzZXJMb2coXCJzdGFydExpdmVMaW5rc0NoZWNrIGxpbmtFbnRyeVwiLCBKU09OLnN0cmluZ2lmeShsaW5rRW50cnkpKTtcbiAgICAgICAgY29uc3QgZmV0Y2hMaW5rID0gbGlua0VudHJ5WzFdID8gbGlua0VudHJ5WzFdIDogbGlua0VudHJ5WzJdOyAvLyBXaHkgPz8/ICEhIVxuICAgICAgICB1c2VyTG9nKFwic3RhcnRMaXZlTGlua3NDaGVjayBhdHRlbXB0aW5nIHRvIGZldGNoXCIsIGZldGNoTGluaywgJ+KApicpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2VEYXRhID0gYXdhaXQgY2FjaGVkR2V0RmlsZVVzaW5nRnVsbFVSTChmZXRjaExpbmspO1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2VUZXh0ID0gcmVzcG9uc2VEYXRhO1xuICAgICAgICAgICAgdXNlckxvZyhcInN0YXJ0TGl2ZUxpbmtzQ2hlY2sgZ290IHJlc3BvbnNlOiBcIiwgcmVzcG9uc2VUZXh0Lmxlbmd0aCk7XG4gICAgICAgIH0gY2F0Y2ggKGxjRXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYHN0YXJ0TGl2ZUxpbmtzQ2hlY2sgaGFkIGFuIGVycm9yIGZldGNoaW5nICcke2ZldGNoTGlua30nOiAke2xjRXJyb3J9YCk7XG4gICAgICAgICAgICBhZGROb3RpY2VQYXJ0aWFsKHsgcHJpb3JpdHk6IDQzOSwgbWVzc2FnZTogXCJFcnJvciBmZXRjaGluZyBsaW5rXCIsIGxvY2F0aW9uOiBgICR7ZmV0Y2hMaW5rfWAgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB1c2VyTG9nKFwic3RhcnRMaXZlTGlua3NDaGVjayBjYWxsaW5nIGNhbGxiYWNrIGZ1bmN0aW9u4oCmXCIpO1xuICAgIGNhbGxiYWNrRnVuY3Rpb24ocmVzdWx0KTtcbn1cblxuXG4vKipcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gbGFuZ3VhZ2VDb2RlXG4gKiBAcGFyYW0ge3N0cmluZ30gcmVwb0NvZGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBmaWVsZE5hbWVcbiAqIEBwYXJhbSB7c3RyaW5nfSBmaWVsZFRleHRcbiAqIEBwYXJhbSB7T2JqZWN0fSBsaW5rT3B0aW9uc1xuICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbmFsRmllbGRMb2NhdGlvblxuICogQHBhcmFtIHtPYmplY3R9IGNoZWNraW5nT3B0aW9uc1xuICovXG5leHBvcnQgZnVuY3Rpb24gY2hlY2tGaWVsZExpbmtzKGxhbmd1YWdlQ29kZSwgcmVwb0NvZGUsIGZpZWxkTmFtZSwgZmllbGRUZXh0LCBsaW5rT3B0aW9ucywgb3B0aW9uYWxGaWVsZExvY2F0aW9uLCBjaGVja2luZ09wdGlvbnMpIHtcbiAgICAvLyBEb2VzIGJhc2ljIGNoZWNrcyBmb3IgZmllbGRzIHRoYXQgYXJlIGxpbmtzIG9yIHRoYXQgY29udGFpbiBsaW5rc1xuXG4gICAgLy8gTk9URTogVGhpcyBmdW5jdGlvbiBpcyBjdXJyZW50bHkgb25seSBjYWxsZWQgZnJvbSBmaWVsZC1saW5rLWNoZWNrLm1kISEhXG4gICAgLy8gICAgICAgICAgVE9ETzogRG9lcyBpdCBuZWVkIHRvIGJlIGRlbGV0ZWQgKG9yIGZpbmlzaGVkKSA/Pz9cblxuICAgIC8vIFdlIGFzc3VtZSB0aGF0IGNoZWNraW5nIGZvciBjb21wdWxzb3J5IGZpZWxkcyBpcyBkb25lIGVsc2V3aGVyZVxuXG4gICAgLy8gUmV0dXJucyBhbiBlcnJvciBsaXN0IGFuZCBhIHdhcm5pbmcgbGlzdFxuICAgIC8vICBCb3RoIGxpc3RzIGNvbnRhaW4gbGlzdHMgb2YgdHdvIHN0cmluZ3M6XG4gICAgLy8gICAgICAxLyB0aGUgZXJyb3Igc3RyaW5nXG4gICAgLy8gICAgICAyLyB0aGUgZGV0YWlsZWQgbG9jYXRpb24gc3RyaW5nXG4gICAgLy8gIChSZXR1cm5lZCBpbiB0aGlzIHdheSBmb3IgbW9yZSBpbnRlbGxpZ2VudCBwcm9jZXNzaW5nIGF0IGEgaGlnaGVyIGxldmVsKVxuXG4gICAgdXNlckxvZyhgY2hlY2tGaWVsZExpbmtzKCcke2xhbmd1YWdlQ29kZX0nLCAnJHtyZXBvQ29kZX0nLCAnJHtmaWVsZE5hbWV9JywgJyR7ZmllbGRUZXh0fScsICR7SlNPTi5zdHJpbmdpZnkobGlua09wdGlvbnMpfSwgJyR7b3B0aW9uYWxGaWVsZExvY2F0aW9ufScsICR7SlNPTi5zdHJpbmdpZnkoY2hlY2tpbmdPcHRpb25zKX0p4oCmYCk7XG4gICAgLy8gZGVidWdMb2coIFwibGlua09wdGlvbnNcIiwgSlNPTi5zdHJpbmdpZnkobGlua09wdGlvbnMpKTtcbiAgICAvLyBkZWJ1Z0xvZyggXCJsaW5rT3B0aW9uc0VDXCIsIGxpbmtPcHRpb25zLmV4cGVjdGVkQ291bnQpO1xuICAgIC8vcGFyYW1ldGVyQXNzZXJ0KGxhbmd1YWdlQ29kZSAhPT0gdW5kZWZpbmVkLCBcImNoZWNrRmllbGRMaW5rczogJ2xhbmd1YWdlQ29kZScgcGFyYW1ldGVyIHNob3VsZCBiZSBkZWZpbmVkXCIpO1xuICAgIC8vcGFyYW1ldGVyQXNzZXJ0KHR5cGVvZiBsYW5ndWFnZUNvZGUgPT09ICdzdHJpbmcnLCBgY2hlY2tGaWVsZExpbmtzOiAnbGFuZ3VhZ2VDb2RlJyBwYXJhbWV0ZXIgc2hvdWxkIGJlIGEgc3RyaW5nIG5vdCBhICcke3R5cGVvZiBsYW5ndWFnZUNvZGV9JzogJHtsYW5ndWFnZUNvZGV9YCk7XG4gICAgLy9wYXJhbWV0ZXJBc3NlcnQocmVwb0NvZGUgIT09IHVuZGVmaW5lZCwgXCJjaGVja0ZpZWxkTGlua3M6ICdyZXBvQ29kZScgcGFyYW1ldGVyIHNob3VsZCBiZSBkZWZpbmVkXCIpO1xuICAgIC8vcGFyYW1ldGVyQXNzZXJ0KHR5cGVvZiByZXBvQ29kZSA9PT0gJ3N0cmluZycsIGBjaGVja0ZpZWxkTGlua3M6ICdyZXBvQ29kZScgcGFyYW1ldGVyIHNob3VsZCBiZSBhIHN0cmluZyBub3QgYSAnJHt0eXBlb2YgcmVwb0NvZGV9JzogJHtyZXBvQ29kZX1gKTtcbiAgICAvL3BhcmFtZXRlckFzc2VydChSRVBPX0NPREVTX0xJU1QuaW5jbHVkZXMocmVwb0NvZGUpLCBgY2hlY2tGaWVsZExpbmtzOiAncmVwb0NvZGUnIHBhcmFtZXRlciBzaG91bGQgbm90IGJlICcke3JlcG9Db2RlfSdgKTtcbiAgICAvL3BhcmFtZXRlckFzc2VydChmaWVsZE5hbWUgIT09IHVuZGVmaW5lZCwgXCJjaGVja0ZpZWxkTGlua3M6ICdmaWVsZE5hbWUnIHBhcmFtZXRlciBzaG91bGQgYmUgZGVmaW5lZFwiKTtcbiAgICAvL3BhcmFtZXRlckFzc2VydCh0eXBlb2YgZmllbGROYW1lID09PSAnc3RyaW5nJywgYGNoZWNrRmllbGRMaW5rczogJ2ZpZWxkTmFtZScgcGFyYW1ldGVyIHNob3VsZCBiZSBhIHN0cmluZyBub3QgYSAnJHt0eXBlb2YgZmllbGROYW1lfSc6ICR7ZmllbGROYW1lfWApO1xuICAgIC8vcGFyYW1ldGVyQXNzZXJ0KGZpZWxkVGV4dCAhPT0gdW5kZWZpbmVkLCBcImNoZWNrRmllbGRMaW5rczogJ2ZpZWxkVGV4dCcgcGFyYW1ldGVyIHNob3VsZCBiZSBkZWZpbmVkXCIpO1xuICAgIC8vcGFyYW1ldGVyQXNzZXJ0KHR5cGVvZiBmaWVsZFRleHQgPT09ICdzdHJpbmcnLCBgY2hlY2tGaWVsZExpbmtzOiAnZmllbGRUZXh0JyBwYXJhbWV0ZXIgc2hvdWxkIGJlIGEgc3RyaW5nIG5vdCBhICcke3R5cGVvZiBmaWVsZFRleHR9JzogJHtmaWVsZFRleHR9YCk7XG4gICAgLy9wYXJhbWV0ZXJBc3NlcnQob3B0aW9uYWxGaWVsZExvY2F0aW9uICE9PSB1bmRlZmluZWQsIFwiY2hlY2tGaWVsZExpbmtzOiAnb3B0aW9uYWxGaWVsZExvY2F0aW9uJyBwYXJhbWV0ZXIgc2hvdWxkIGJlIGRlZmluZWRcIik7XG4gICAgLy9wYXJhbWV0ZXJBc3NlcnQodHlwZW9mIG9wdGlvbmFsRmllbGRMb2NhdGlvbiA9PT0gJ3N0cmluZycsIGBjaGVja0ZpZWxkTGlua3M6ICdvcHRpb25hbEZpZWxkTG9jYXRpb24nIHBhcmFtZXRlciBzaG91bGQgYmUgYSBzdHJpbmcgbm90IGEgJyR7dHlwZW9mIG9wdGlvbmFsRmllbGRMb2NhdGlvbn0nOiAke29wdGlvbmFsRmllbGRMb2NhdGlvbn1gKTtcbiAgICAvL3BhcmFtZXRlckFzc2VydChvcHRpb25hbEZpZWxkTG9jYXRpb24uaW5kZXhPZigndHJ1ZScpID09PSAtMSwgYGNoZWNrRmllbGRMaW5rczogJ29wdGlvbmFsRmllbGRMb2NhdGlvbicgcGFyYW1ldGVyIHNob3VsZCBub3QgYmUgJyR7b3B0aW9uYWxGaWVsZExvY2F0aW9ufSdgKTtcblxuICAgIGxldCBvdXJMb2NhdGlvbiA9IG9wdGlvbmFsRmllbGRMb2NhdGlvbjtcbiAgICBpZiAob3VyTG9jYXRpb24gJiYgb3VyTG9jYXRpb25bMF0gIT09ICcgJykgb3VyTG9jYXRpb24gPSBgICR7b3VyTG9jYXRpb259YDtcblxuICAgIGxldCByZXN1bHQgPSB7IG5vdGljZUxpc3Q6IFtdIH07XG5cbiAgICBmdW5jdGlvbiBhZGROb3RpY2VQYXJ0aWFsKHsgcHJpb3JpdHksIG1lc3NhZ2UsIGNoYXJhY3RlckluZGV4LCBleGNlcnB0LCBsb2NhdGlvbiB9KSB7XG4gICAgICAgIHVzZXJMb2coYGNGTHMgYWRkTm90aWNlUGFydGlhbDogKHByaW9yaXR5PSR7cHJpb3JpdHl9KSAke21lc3NhZ2V9JHtjaGFyYWN0ZXJJbmRleCA+IDAgPyBgIChhdCBjaGFyYWN0ZXIgJHtjaGFyYWN0ZXJJbmRleH0pYCA6IFwiXCJ9JHtleGNlcnB0ID8gYCAke2V4Y2VycHR9YCA6IFwiXCJ9JHtsb2NhdGlvbn1gKTtcbiAgICAgICAgLy9wYXJhbWV0ZXJBc3NlcnQocHJpb3JpdHkgIT09IHVuZGVmaW5lZCwgXCJjRkxzIGFkZE5vdGljZVBhcnRpYWw6ICdwcmlvcml0eScgcGFyYW1ldGVyIHNob3VsZCBiZSBkZWZpbmVkXCIpO1xuICAgICAgICAvL3BhcmFtZXRlckFzc2VydCh0eXBlb2YgcHJpb3JpdHkgPT09ICdudW1iZXInLCBgY0ZMcyBhZGROb3RpY2VQYXJ0aWFsOiAncHJpb3JpdHknIHBhcmFtZXRlciBzaG91bGQgYmUgYSBudW1iZXIgbm90IGEgJyR7dHlwZW9mIHByaW9yaXR5fSc6ICR7cHJpb3JpdHl9YCk7XG4gICAgICAgIC8vcGFyYW1ldGVyQXNzZXJ0KG1lc3NhZ2UgIT09IHVuZGVmaW5lZCwgXCJjRkxzIGFkZE5vdGljZVBhcnRpYWw6ICdtZXNzYWdlJyBwYXJhbWV0ZXIgc2hvdWxkIGJlIGRlZmluZWRcIik7XG4gICAgICAgIC8vcGFyYW1ldGVyQXNzZXJ0KHR5cGVvZiBtZXNzYWdlID09PSAnc3RyaW5nJywgYGNGTHMgYWRkTm90aWNlUGFydGlhbDogJ21lc3NhZ2UnIHBhcmFtZXRlciBzaG91bGQgYmUgYSBzdHJpbmcgbm90IGEgJyR7dHlwZW9mIG1lc3NhZ2V9JzogJHttZXNzYWdlfWApO1xuICAgICAgICAvLyAvL3BhcmFtZXRlckFzc2VydChjaGFyYWN0ZXJJbmRleCE9PXVuZGVmaW5lZCwgXCJjRkxzIGFkZE5vdGljZVBhcnRpYWw6ICdjaGFyYWN0ZXJJbmRleCcgcGFyYW1ldGVyIHNob3VsZCBiZSBkZWZpbmVkXCIpO1xuICAgICAgICBpZiAoY2hhcmFjdGVySW5kZXgpIHsgLy9wYXJhbWV0ZXJBc3NlcnQodHlwZW9mIGNoYXJhY3RlckluZGV4ID09PSAnbnVtYmVyJywgYGNGTHMgYWRkTm90aWNlUGFydGlhbDogJ2NoYXJhY3RlckluZGV4JyBwYXJhbWV0ZXIgc2hvdWxkIGJlIGEgbnVtYmVyIG5vdCBhICcke3R5cGVvZiBjaGFyYWN0ZXJJbmRleH0nOiAke2NoYXJhY3RlckluZGV4fWApO1xuICAgICAgICB9XG4gICAgICAgIC8vIC8vcGFyYW1ldGVyQXNzZXJ0KGV4Y2VycHQhPT11bmRlZmluZWQsIFwiY0ZMcyBhZGROb3RpY2VQYXJ0aWFsOiAnZXhjZXJwdCcgcGFyYW1ldGVyIHNob3VsZCBiZSBkZWZpbmVkXCIpO1xuICAgICAgICBpZiAoZXhjZXJwdCkgeyAvL3BhcmFtZXRlckFzc2VydCh0eXBlb2YgZXhjZXJwdCA9PT0gJ3N0cmluZycsIGBjRkxzIGFkZE5vdGljZVBhcnRpYWw6ICdleGNlcnB0JyBwYXJhbWV0ZXIgc2hvdWxkIGJlIGEgc3RyaW5nIG5vdCBhICcke3R5cGVvZiBleGNlcnB0fSc6ICR7ZXhjZXJwdH1gKTtcbiAgICAgICAgfVxuICAgICAgICAvL3BhcmFtZXRlckFzc2VydChsb2NhdGlvbiAhPT0gdW5kZWZpbmVkLCBcImNGTHMgYWRkTm90aWNlUGFydGlhbDogJ2xvY2F0aW9uJyBwYXJhbWV0ZXIgc2hvdWxkIGJlIGRlZmluZWRcIik7XG4gICAgICAgIC8vcGFyYW1ldGVyQXNzZXJ0KHR5cGVvZiBsb2NhdGlvbiA9PT0gJ3N0cmluZycsIGBjRkxzIGFkZE5vdGljZVBhcnRpYWw6ICdsb2NhdGlvbicgcGFyYW1ldGVyIHNob3VsZCBiZSBhIHN0cmluZyBub3QgYSAnJHt0eXBlb2YgbG9jYXRpb259JzogJHtsb2NhdGlvbn1gKTtcblxuICAgICAgICByZXN1bHQubm90aWNlTGlzdC5wdXNoKHsgcHJpb3JpdHksIG1lc3NhZ2UsIGNoYXJhY3RlckluZGV4LCBleGNlcnB0LCBsb2NhdGlvbiB9KTtcbiAgICB9XG5cbiAgICAvLyAvLyBDcmVhdGUgb3VyIG1vcmUgZGV0YWlsZWQgbG9jYXRpb24gc3RyaW5nIGJ5IHByZXBlbmRpbmcgdGhlIGZpZWxkTmFtZVxuICAgIC8vIGxldCBvdXJBdFN0cmluZyA9IGAgaW4gJyR7ZmllbGROYW1lfSdgO1xuICAgIC8vIGlmIChvcHRpb25hbEZpZWxkTG9jYXRpb24pIHtcbiAgICAvLyAgICAgaWYgKG9wdGlvbmFsRmllbGRMb2NhdGlvblswXSAhPT0gJyAnKSBvdXJBdFN0cmluZyArPSAnICc7XG4gICAgLy8gICAgIG91ckF0U3RyaW5nICs9IG9wdGlvbmFsRmllbGRMb2NhdGlvbjtcbiAgICAvLyB9XG5cblxuICAgIGlmICghZmllbGRUZXh0KSB7IC8vIE5vdGhpbmcgdG8gY2hlY2tcbiAgICAgICAgaWYgKGxpbmtPcHRpb25zLmV4cGVjdGVkQ291bnQgPiAwKVxuICAgICAgICAgICAgYWRkTm90aWNlUGFydGlhbCh7IHByaW9yaXR5OiA0MzgsIG1lc3NhZ2U6IGBCbGFuayBmaWVsZCAvIG1pc3NpbmcgbGluayAoZXhwZWN0ZWQgJHtsaW5rT3B0aW9ucy5leHBlY3RlZENvdW50fSBsaW5rJHtsaW5rT3B0aW9ucy5leHBlY3RlZENvdW50ID09PSAxID8gXCJcIiA6IFwic1wifSlgLCBsb2NhdGlvbjogb3VyTG9jYXRpb24gfSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLy8gT2ssIHdlIGhhdmUgc29tZXRoaW5nIGluIG91ciBmaWVsZFxuICAgIGlmIChsaW5rT3B0aW9ucy5vdGhlclRleHRBbGxvd2VkKVxuICAgICAgICByZXN1bHQgPSBjaGVja1RleHRGaWVsZChsYW5ndWFnZUNvZGUsIHJlcG9Db2RlLCAnbGluaycsIGZpZWxkTmFtZSwgZmllbGRUZXh0LCB0cnVlLCBvcHRpb25hbEZpZWxkTG9jYXRpb24sIGNoZWNraW5nT3B0aW9ucyk7XG5cbiAgICAvLyBQYXJhbWV0ZXIgbm9uc2Vuc2UgY2hlY2tcbiAgICBpZiAobGlua09wdGlvbnMuYWxsb3dlZENvdW50ID4gMCAmJiBsaW5rT3B0aW9ucy5leHBlY3RlZENvdW50ID4gbGlua09wdGlvbnMuYWxsb3dlZENvdW50KVxuICAgICAgICBhZGROb3RpY2VQYXJ0aWFsKHsgcHJpb3JpdHk6IDExMSwgbWVzc2FnZTogYEJhZCBvcHRpb25zIGZvciBjaGVja0ZpZWxkTGlua3M6IGV4cGVjdGVkQ291bnQ9JHtsaW5rT3B0aW9ucy5leHBlY3RlZENvdW50fSBidXQgYWxsb3dlZENvdW50PSR7bGlua09wdGlvbnMuYWxsb3dlZENvdW50fWAgfSk7XG5cbiAgICAvLyBDaGVjayBmb3IgZW1iZWRkZWQgbGlua3NcbiAgICAvLyBGaXJzdCwgY3JlYXRlIG91ciByZWdleCBmcm9tIHRoZSBhbGxvd2VkIGxpbmsgdHlwZXNcbiAgICBsZXQgbGlua1JlZ2V4UGFydHM7XG4gICAgaWYgKGxpbmtPcHRpb25zLmxpbmtUeXBlc0FsbG93ZWQpIHtcbiAgICAgICAgbGlua1JlZ2V4UGFydHMgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBsaW5rVHlwZSBvZiBsaW5rT3B0aW9ucy5saW5rVHlwZXNBbGxvd2VkKSB7XG4gICAgICAgICAgICAvLyBkZWJ1Z0xvZyhcImNoZWNrRmllbGRMaW5rcyBsaW5rVHlwZVwiLCBsaW5rVHlwZSk7XG4gICAgICAgICAgICBpZiAobGlua1R5cGUgPT09ICdSQycpXG4gICAgICAgICAgICAgICAgbGlua1JlZ2V4UGFydHMucHVzaCgnKHJjOi8vW14gXSspJyk7XG4gICAgICAgICAgICBlbHNlIGlmIChsaW5rVHlwZSA9PT0gJ21kJykge1xuICAgICAgICAgICAgICAgIGxpbmtSZWdleFBhcnRzLnB1c2goJ1xcXFxbXFxcXFsoaHR0cHMqOi8vW14gXSspXFxcXF1cXFxcXScpOyAvLyBbW2xpbmtdXVxuICAgICAgICAgICAgICAgIGxpbmtSZWdleFBhcnRzLnB1c2goJ11cXFxcKChodHRwcyo6Ly9bXiBdKylcXFxcKScpOyAvLyBbdGhpc10obGluaylcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGxpbmtUeXBlID09PSAnbmFrZWQnKVxuICAgICAgICAgICAgICAgIGxpbmtSZWdleFBhcnRzLnB1c2goJyhodHRwcyo6Ly9bXiBdKyknKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBhZGROb3RpY2VQYXJ0aWFsKHsgcHJpb3JpdHk6IDQ0MSwgbWVzc2FnZTogYFVua25vd24gbGlua1R5cGUgcGFyYW1ldGVyYCwgZXhjZXJwdDogbGlua1R5cGUgfSk7XG4gICAgICAgIH1cbiAgICB9IGVsc2UgeyAvLyBObyBsaW5rIHR5cGVzIHNwZWNpZmllZFxuICAgICAgICBsaW5rUmVnZXhQYXJ0cyA9IFtdO1xuICAgIH1cbiAgICAvLyBkZWJ1Z0xvZyhcImNoZWNrRmllbGRMaW5rcyBsaW5rUmVnZXhQYXJ0c1wiLCBKU09OLnN0cmluZ2lmeShsaW5rUmVnZXhQYXJ0cykpO1xuICAgIGNvbnN0IGxpbmtSZWdleCA9IG5ldyBSZWdFeHAobGlua1JlZ2V4UGFydHMuam9pbignfCcpLCAnZycpO1xuICAgIC8vIGRlYnVnTG9nKFwibGlua1JlZ2V4XCIsIEpTT04uc3RyaW5naWZ5KGxpbmtSZWdleCkpO1xuICAgIC8vIGNvbnN0IHJlZ2V4UmVzdWx0cyA9IGZpZWxkVGV4dC5tYXRjaEFsbChsaW5rUmVnZXgpO1xuICAgIC8vIGRlYnVnTG9nKFwicmVnZXhSZXN1bHRzXCIsIHJlZ2V4UmVzdWx0cy5sZW5ndGgsIEpTT04uc3RyaW5naWZ5KHJlZ2V4UmVzdWx0cykpO1xuICAgIGNvbnN0IHJlZ2V4UmVzdWx0c0FycmF5ID0gWy4uLmZpZWxkVGV4dC5tYXRjaEFsbChsaW5rUmVnZXgpXTtcbiAgICAvLyBkZWJ1Z0xvZyhcImNoZWNrRmllbGRMaW5rcyByZWdleFJlc3VsdHNBcnJheVwiLCByZWdleFJlc3VsdHNBcnJheS5sZW5ndGgsIEpTT04uc3RyaW5naWZ5KHJlZ2V4UmVzdWx0c0FycmF5KSk7XG5cbiAgICBpZiAocmVnZXhSZXN1bHRzQXJyYXkubGVuZ3RoIDwgbGlua09wdGlvbnMuZXhwZWN0ZWRDb3VudClcbiAgICAgICAgYWRkTm90aWNlUGFydGlhbCh7IHByaW9yaXR5OiAyODcsIG1lc3NhZ2U6IGBOb3QgZW5vdWdoIGxpbmtzIChleHBlY3RlZCAke2xpbmtPcHRpb25zLmV4cGVjdGVkQ291bnR9IGxpbmske2xpbmtPcHRpb25zLmV4cGVjdGVkQ291bnQgPT09IDEgPyBcIlwiIDogXCJzXCJ9KWAsIGxvY2F0aW9uOiBgIChvbmx5IGZvdW5kICR7cmVnZXhSZXN1bHRzQXJyYXkubGVuZ3RofSkke291ckxvY2F0aW9ufWAgfSk7XG5cbiAgICBpZiAobGlua09wdGlvbnMuY2hlY2tUYXJnZXRzICYmIGxpbmtPcHRpb25zLmNhbGxiYWNrRnVuY3Rpb24gJiYgcmVnZXhSZXN1bHRzQXJyYXkpIHtcbiAgICAgICAgc3RhcnRMaXZlTGlua3NDaGVjayhyZWdleFJlc3VsdHNBcnJheSwgcmVzdWx0Lm5vdGljZUxpc3Quc2xpY2UoMCksIGxpbmtPcHRpb25zLmNhbGxiYWNrRnVuY3Rpb24pO1xuICAgICAgICBhZGROb3RpY2VQYXJ0aWFsKHsgcHJpb3JpdHk6IDYwMCwgbWVzc2FnZTogYCR7cmVnZXhSZXN1bHRzQXJyYXkubGVuZ3RofSBsaW5rIHRhcmdldCR7cmVnZXhSZXN1bHRzQXJyYXkubGVuZ3RoID09PSAxID8gJyBpcycgOiAncyBhcmUnfSBzdGlsbCBiZWluZyBjaGVja2Vk4oCmYCwgbG9jYXRpb246IG91ckxvY2F0aW9uIH0pO1xuICAgICAgICB1c2VyTG9nKFwiY2hlY2tGaWVsZExpbmtzIG5vdyByZXR1cm5pbmcgaW5pdGlhbCByZXN1bHTigKZcIik7XG4gICAgfVxuXG4gICAgdXNlckxvZyhgICBjaGVja0ZpZWxkTGlua3MgdiR7TElOS19WQUxJREFUT1JfVkVSU0lPTl9TVFJJTkd9IHJldHVybmluZyB3aXRoICR7cmVzdWx0Lm5vdGljZUxpc3QubGVuZ3RofSBub3RpY2VzLmApO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG4vLyBlbmQgb2YgY2hlY2tGaWVsZExpbmtzIGZ1bmN0aW9uXG4iXX0=