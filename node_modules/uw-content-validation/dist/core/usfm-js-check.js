"use strict";var _typeof = require("@babel/runtime/helpers/typeof");Object.defineProperty(exports, "__esModule", { value: true });exports.runUsfmJsCheck = runUsfmJsCheck;exports.checkUSFMToJSON = checkUSFMToJSON;var _usfmJs = require("usfm-js");

var books = _interopRequireWildcard(require("../core/books/books"));

var _utilities = require("./utilities");function _getRequireWildcardCache(nodeInterop) {if (typeof WeakMap !== "function") return null;var cacheBabelInterop = new WeakMap();var cacheNodeInterop = new WeakMap();return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) {return nodeInterop ? cacheNodeInterop : cacheBabelInterop;})(nodeInterop);}function _interopRequireWildcard(obj, nodeInterop) {if (!nodeInterop && obj && obj.__esModule) {return obj;}if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") {return { default: obj };}var cache = _getRequireWildcardCache(nodeInterop);if (cache && cache.has(obj)) {return cache.get(obj);}var newObj = {};var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;for (var key in obj) {if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;if (desc && (desc.get || desc.set)) {Object.defineProperty(newObj, key, desc);} else {newObj[key] = obj[key];}}}newObj.default = obj;if (cache) {cache.set(obj, newObj);}return newObj;} // eslint-disable-next-line no-unused-vars
// eslint-disable-next-line no-unused-vars

function runUsfmJsCheck(fileText, convertOptions) {
  // Runs the USFM-JS converter as a check
  //  which can be quite time-consuming on large, complex USFM files
  // debugLog("Running USFM-JS converter check (can take quite a while for a large book)…");

  var jsonResult = (0, _usfmJs.toJSON)(fileText, convertOptions);
  var jsonKeys = Object.keys(jsonResult); // Expect 'headers', 'chapters'
  var numJSONkeys = jsonKeys.length;
  // debugLog(`  Finished USFM-JS converter check with ${numJSONkeys} json key(s)`);
  // debugLog(`  jsonResult: ${JSON.stringify(jsonResult)}`)
  // NOTE: We don’t know how to get the errors out yet

  return { isValidUSFM: numJSONkeys >= 2, returnedJSON: jsonResult }; // Expect 'headers', 'chapters'
}
// end of runUsfmJsCheck function


function checkUSFMToJSON(bookID, filename, givenText, givenLocation, checkingOptions) {
  /*
  This function is only used for the demonstration pages -- not for the core!
   bookID is a three-character UPPERCASE USFM book identifier.
       filename parameter can be an empty string if we don’t have one.
    Returns a result object containing a successList and a noticeList
   */



  // functionLog(`checkUSFMToJSON(${givenText.length.toLocaleString()} chars, '${givenLocation}')…`);
  //parameterAssert(bookID !== undefined, "checkUSFMToJSON: 'bookID' parameter should be defined");
  //parameterAssert(typeof bookID === 'string', `checkUSFMToJSON: 'bookID' parameter should be a string not a '${typeof bookID}': ${bookID}`);
  //parameterAssert(bookID.length === 3, `checkUSFMToJSON: 'bookID' parameter should be three characters long not ${bookID.length}`);
  //parameterAssert(bookID.toUpperCase() === bookID, `checkUSFMToJSON: 'bookID' parameter should be UPPERCASE not '${bookID}'`);
  //parameterAssert(books.isValidBookID(bookID), `checkUSFMToJSON: '${bookID}' is not a valid USFM book identifier`);
  //parameterAssert(filename !== undefined, "checkUSFMToJSON: 'filename' parameter should be defined");
  //parameterAssert(typeof filename === 'string', `checkUSFMToJSON: 'filename' parameter should be a string not a '${typeof filename}': ${filename}`);
  //parameterAssert(givenText !== undefined, "checkUSFMToJSON: 'givenText' parameter should be defined");
  //parameterAssert(typeof givenText === 'string', `checkUSFMToJSON: 'givenText' parameter should be a string not a '${typeof givenText}': ${givenText}`);
  //parameterAssert(givenLocation !== undefined, "checkUSFMToJSON: 'givenRowLocation' parameter should be defined");
  //parameterAssert(typeof givenLocation === 'string', `checkUSFMToJSON: 'givenRowLocation' parameter should be a string not a '${typeof givenLocation}'`);

  var ourLocation = givenLocation;
  if (ourLocation && ourLocation[0] !== ' ') ourLocation = " ".concat(ourLocation);
  // if (filename) ourLocation = ` in ${filename}${ourLocation}`;


  var result = { successList: [], noticeList: [] };

  function addSuccessMessage(successString) {
    // functionLog(`checkUSFMToJSON success: ${successString}`);
    result.successList.push(successString);
  }
  function addNotice6to7(_ref) {var priority = _ref.priority,message = _ref.message,lineNumber = _ref.lineNumber,characterIndex = _ref.characterIndex,excerpt = _ref.excerpt,location = _ref.location;
    /**
    * @description - adds a new notice entry, adding bookID,C,V to the given fields
    * @param {Number} priority - notice priority from 1 (lowest) to 999 (highest)
    * @param {string} message - the text of the notice message
    * @param {Number} characterIndex - where the issue occurs in the line
    * @param {string} excerpt - short excerpt from the line centred on the problem (if available)
    * @param {string} location - description of where the issue is located
    */
    // functionLog(`checkUSFMToJSON notice: (priority=${priority}) ${message}${characterIndex > 0 ? ` (at character ${characterIndex})` : ""}${excerpt ? ` ${excerpt}` : ""}${location}`);
    //parameterAssert(priority !== undefined, "cUSFMjs addNotice6to7: 'priority' parameter should be defined");
    //parameterAssert(typeof priority === 'number', `cUSFMjs addNotice6to7: 'priority' parameter should be a number not a '${typeof priority}': ${priority}`);
    //parameterAssert(message !== undefined, "cUSFMjs addNotice6to7: 'message' parameter should be defined");
    //parameterAssert(typeof message === 'string', `cUSFMjs addNotice6to7: 'message' parameter should be a string not a '${typeof message}': ${message}`);
    // //parameterAssert(characterIndex !== undefined, "cUSFMjs addNotice6to7: 'characterIndex' parameter should be defined");
    if (characterIndex) {//parameterAssert(typeof characterIndex === 'number', `cUSFMjs addNotice6to7: 'characterIndex' parameter should be a number not a '${typeof characterIndex}': ${characterIndex}`);
    }
    // //parameterAssert(excerpt !== undefined, "cUSFMjs addNotice6to7: 'excerpt' parameter should be defined");
    if (excerpt) {//parameterAssert(typeof excerpt === 'string', `cUSFMjs addNotice6to7: 'excerpt' parameter should be a string not a '${typeof excerpt}': ${excerpt}`);
    }
    //parameterAssert(location !== undefined, "cUSFMjs addNotice6to7: 'location' parameter should be defined");
    //parameterAssert(typeof location === 'string', `cUSFMjs addNotice6to7: 'location' parameter should be a string not a '${typeof location}': ${location}`);
    result.noticeList.push({ priority: priority, message: message, bookID: bookID, lineNumber: lineNumber, characterIndex: characterIndex, excerpt: excerpt, location: location });
  }


  // Set your options here -- change values or comment out lines
  var convertOptions = {
    'chunk': false, // true: returns headers/chapters/verses (seems weird???); false: returns headers/chapters only.
    //'content-source': ourLocation, // Seems to be included in every sub-object -- wasted space ???
    'convertToInt': [] };

  var convertCheckResult = runUsfmJsCheck(givenText, convertOptions);
  // NOTE: We haven’t figured out how to get ERRORS out of this parser yet

  if (!convertCheckResult.isValidUSFM)
  addNotice6to7({ priority: 943, message: "USFM3 toJSON Check doesn\u2019t pass", location: ourLocation });

  addSuccessMessage("Checked USFM-JS");
  // debugLog(`  checkUSFMToJSON returning with ${result.successList.length.toLocaleString()} success(es) and ${result.noticeList.length.toLocaleString()} notice(s).`);
  // functionLog(`checkUSFMToJSON result is ${JSON.stringify(result)}`);
  return result;
}
// end of checkUSFMToJSON function
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9jb3JlL3VzZm0tanMtY2hlY2suanMiXSwibmFtZXMiOlsicnVuVXNmbUpzQ2hlY2siLCJmaWxlVGV4dCIsImNvbnZlcnRPcHRpb25zIiwianNvblJlc3VsdCIsImpzb25LZXlzIiwiT2JqZWN0Iiwia2V5cyIsIm51bUpTT05rZXlzIiwibGVuZ3RoIiwiaXNWYWxpZFVTRk0iLCJyZXR1cm5lZEpTT04iLCJjaGVja1VTRk1Ub0pTT04iLCJib29rSUQiLCJmaWxlbmFtZSIsImdpdmVuVGV4dCIsImdpdmVuTG9jYXRpb24iLCJjaGVja2luZ09wdGlvbnMiLCJvdXJMb2NhdGlvbiIsInJlc3VsdCIsInN1Y2Nlc3NMaXN0Iiwibm90aWNlTGlzdCIsImFkZFN1Y2Nlc3NNZXNzYWdlIiwic3VjY2Vzc1N0cmluZyIsInB1c2giLCJhZGROb3RpY2U2dG83IiwicHJpb3JpdHkiLCJtZXNzYWdlIiwibGluZU51bWJlciIsImNoYXJhY3RlckluZGV4IiwiZXhjZXJwdCIsImxvY2F0aW9uIiwiY29udmVydENoZWNrUmVzdWx0Il0sIm1hcHBpbmdzIjoib05BQUE7O0FBRUE7O0FBRUEsd0MsbWxDQUhBO0FBRUE7O0FBSU8sU0FBU0EsY0FBVCxDQUF3QkMsUUFBeEIsRUFBa0NDLGNBQWxDLEVBQWtEO0FBQ3JEO0FBQ0E7QUFDQTs7QUFFQSxNQUFNQyxVQUFVLEdBQUcsb0JBQU9GLFFBQVAsRUFBaUJDLGNBQWpCLENBQW5CO0FBQ0EsTUFBTUUsUUFBUSxHQUFHQyxNQUFNLENBQUNDLElBQVAsQ0FBWUgsVUFBWixDQUFqQixDQU5xRCxDQU1YO0FBQzFDLE1BQU1JLFdBQVcsR0FBR0gsUUFBUSxDQUFDSSxNQUE3QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxTQUFPLEVBQUVDLFdBQVcsRUFBRUYsV0FBVyxJQUFJLENBQTlCLEVBQWlDRyxZQUFZLEVBQUVQLFVBQS9DLEVBQVAsQ0FacUQsQ0FZZTtBQUN2RTtBQUNEOzs7QUFHTyxTQUFTUSxlQUFULENBQXlCQyxNQUF6QixFQUFpQ0MsUUFBakMsRUFBMkNDLFNBQTNDLEVBQXNEQyxhQUF0RCxFQUFxRUMsZUFBckUsRUFBc0Y7QUFDekY7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE1BQUlDLFdBQVcsR0FBR0YsYUFBbEI7QUFDQSxNQUFJRSxXQUFXLElBQUlBLFdBQVcsQ0FBQyxDQUFELENBQVgsS0FBbUIsR0FBdEMsRUFBMkNBLFdBQVcsY0FBT0EsV0FBUCxDQUFYO0FBQzNDOzs7QUFHQSxNQUFNQyxNQUFNLEdBQUcsRUFBRUMsV0FBVyxFQUFFLEVBQWYsRUFBbUJDLFVBQVUsRUFBRSxFQUEvQixFQUFmOztBQUVBLFdBQVNDLGlCQUFULENBQTJCQyxhQUEzQixFQUEwQztBQUN0QztBQUNBSixJQUFBQSxNQUFNLENBQUNDLFdBQVAsQ0FBbUJJLElBQW5CLENBQXdCRCxhQUF4QjtBQUNIO0FBQ0QsV0FBU0UsYUFBVCxPQUE2RixLQUFwRUMsUUFBb0UsUUFBcEVBLFFBQW9FLENBQTFEQyxPQUEwRCxRQUExREEsT0FBMEQsQ0FBakRDLFVBQWlELFFBQWpEQSxVQUFpRCxDQUFyQ0MsY0FBcUMsUUFBckNBLGNBQXFDLENBQXJCQyxPQUFxQixRQUFyQkEsT0FBcUIsQ0FBWkMsUUFBWSxRQUFaQSxRQUFZO0FBQ3pGO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDUTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFJRixjQUFKLEVBQW9CLENBQUU7QUFDckI7QUFDRDtBQUNBLFFBQUlDLE9BQUosRUFBYSxDQUFFO0FBQ2Q7QUFDRDtBQUNBO0FBQ0FYLElBQUFBLE1BQU0sQ0FBQ0UsVUFBUCxDQUFrQkcsSUFBbEIsQ0FBdUIsRUFBRUUsUUFBUSxFQUFSQSxRQUFGLEVBQVlDLE9BQU8sRUFBUEEsT0FBWixFQUFxQmQsTUFBTSxFQUFOQSxNQUFyQixFQUE2QmUsVUFBVSxFQUFWQSxVQUE3QixFQUF5Q0MsY0FBYyxFQUFkQSxjQUF6QyxFQUF5REMsT0FBTyxFQUFQQSxPQUF6RCxFQUFrRUMsUUFBUSxFQUFSQSxRQUFsRSxFQUF2QjtBQUNIOzs7QUFHRDtBQUNBLE1BQU01QixjQUFjLEdBQUc7QUFDbkIsYUFBUyxLQURVLEVBQ0g7QUFDaEI7QUFDQSxvQkFBZ0IsRUFIRyxFQUF2Qjs7QUFLQSxNQUFNNkIsa0JBQWtCLEdBQUcvQixjQUFjLENBQUNjLFNBQUQsRUFBWVosY0FBWixDQUF6QztBQUNBOztBQUVBLE1BQUksQ0FBQzZCLGtCQUFrQixDQUFDdEIsV0FBeEI7QUFDSWUsRUFBQUEsYUFBYSxDQUFDLEVBQUVDLFFBQVEsRUFBRSxHQUFaLEVBQWlCQyxPQUFPLHdDQUF4QixFQUE2REksUUFBUSxFQUFFYixXQUF2RSxFQUFELENBQWI7O0FBRUpJLEVBQUFBLGlCQUFpQixtQkFBakI7QUFDQTtBQUNBO0FBQ0EsU0FBT0gsTUFBUDtBQUNIO0FBQ0QiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyB0b0pTT04gfSBmcm9tICd1c2ZtLWpzJztcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtdmFyc1xuaW1wb3J0ICogYXMgYm9va3MgZnJvbSAnLi4vY29yZS9ib29rcy9ib29rcyc7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLXZhcnNcbmltcG9ydCB7IHBhcmFtZXRlckFzc2VydCB9IGZyb20gJy4vdXRpbGl0aWVzJztcblxuXG5leHBvcnQgZnVuY3Rpb24gcnVuVXNmbUpzQ2hlY2soZmlsZVRleHQsIGNvbnZlcnRPcHRpb25zKSB7XG4gICAgLy8gUnVucyB0aGUgVVNGTS1KUyBjb252ZXJ0ZXIgYXMgYSBjaGVja1xuICAgIC8vICB3aGljaCBjYW4gYmUgcXVpdGUgdGltZS1jb25zdW1pbmcgb24gbGFyZ2UsIGNvbXBsZXggVVNGTSBmaWxlc1xuICAgIC8vIGRlYnVnTG9nKFwiUnVubmluZyBVU0ZNLUpTIGNvbnZlcnRlciBjaGVjayAoY2FuIHRha2UgcXVpdGUgYSB3aGlsZSBmb3IgYSBsYXJnZSBib29rKeKAplwiKTtcblxuICAgIGNvbnN0IGpzb25SZXN1bHQgPSB0b0pTT04oZmlsZVRleHQsIGNvbnZlcnRPcHRpb25zKTtcbiAgICBjb25zdCBqc29uS2V5cyA9IE9iamVjdC5rZXlzKGpzb25SZXN1bHQpOyAvLyBFeHBlY3QgJ2hlYWRlcnMnLCAnY2hhcHRlcnMnXG4gICAgY29uc3QgbnVtSlNPTmtleXMgPSBqc29uS2V5cy5sZW5ndGg7XG4gICAgLy8gZGVidWdMb2coYCAgRmluaXNoZWQgVVNGTS1KUyBjb252ZXJ0ZXIgY2hlY2sgd2l0aCAke251bUpTT05rZXlzfSBqc29uIGtleShzKWApO1xuICAgIC8vIGRlYnVnTG9nKGAgIGpzb25SZXN1bHQ6ICR7SlNPTi5zdHJpbmdpZnkoanNvblJlc3VsdCl9YClcbiAgICAvLyBOT1RFOiBXZSBkb27igJl0IGtub3cgaG93IHRvIGdldCB0aGUgZXJyb3JzIG91dCB5ZXRcblxuICAgIHJldHVybiB7IGlzVmFsaWRVU0ZNOiBudW1KU09Oa2V5cyA+PSAyLCByZXR1cm5lZEpTT046IGpzb25SZXN1bHQgfTsgLy8gRXhwZWN0ICdoZWFkZXJzJywgJ2NoYXB0ZXJzJ1xufVxuLy8gZW5kIG9mIHJ1blVzZm1Kc0NoZWNrIGZ1bmN0aW9uXG5cblxuZXhwb3J0IGZ1bmN0aW9uIGNoZWNrVVNGTVRvSlNPTihib29rSUQsIGZpbGVuYW1lLCBnaXZlblRleHQsIGdpdmVuTG9jYXRpb24sIGNoZWNraW5nT3B0aW9ucykge1xuICAgIC8qXG4gICAgVGhpcyBmdW5jdGlvbiBpcyBvbmx5IHVzZWQgZm9yIHRoZSBkZW1vbnN0cmF0aW9uIHBhZ2VzIC0tIG5vdCBmb3IgdGhlIGNvcmUhXG5cbiAgICBib29rSUQgaXMgYSB0aHJlZS1jaGFyYWN0ZXIgVVBQRVJDQVNFIFVTRk0gYm9vayBpZGVudGlmaWVyLlxuXG4gICAgICAgIGZpbGVuYW1lIHBhcmFtZXRlciBjYW4gYmUgYW4gZW1wdHkgc3RyaW5nIGlmIHdlIGRvbuKAmXQgaGF2ZSBvbmUuXG5cbiAgICAgUmV0dXJucyBhIHJlc3VsdCBvYmplY3QgY29udGFpbmluZyBhIHN1Y2Nlc3NMaXN0IGFuZCBhIG5vdGljZUxpc3RcbiAgICAgKi9cbiAgICAvLyBmdW5jdGlvbkxvZyhgY2hlY2tVU0ZNVG9KU09OKCR7Z2l2ZW5UZXh0Lmxlbmd0aC50b0xvY2FsZVN0cmluZygpfSBjaGFycywgJyR7Z2l2ZW5Mb2NhdGlvbn0nKeKApmApO1xuICAgIC8vcGFyYW1ldGVyQXNzZXJ0KGJvb2tJRCAhPT0gdW5kZWZpbmVkLCBcImNoZWNrVVNGTVRvSlNPTjogJ2Jvb2tJRCcgcGFyYW1ldGVyIHNob3VsZCBiZSBkZWZpbmVkXCIpO1xuICAgIC8vcGFyYW1ldGVyQXNzZXJ0KHR5cGVvZiBib29rSUQgPT09ICdzdHJpbmcnLCBgY2hlY2tVU0ZNVG9KU09OOiAnYm9va0lEJyBwYXJhbWV0ZXIgc2hvdWxkIGJlIGEgc3RyaW5nIG5vdCBhICcke3R5cGVvZiBib29rSUR9JzogJHtib29rSUR9YCk7XG4gICAgLy9wYXJhbWV0ZXJBc3NlcnQoYm9va0lELmxlbmd0aCA9PT0gMywgYGNoZWNrVVNGTVRvSlNPTjogJ2Jvb2tJRCcgcGFyYW1ldGVyIHNob3VsZCBiZSB0aHJlZSBjaGFyYWN0ZXJzIGxvbmcgbm90ICR7Ym9va0lELmxlbmd0aH1gKTtcbiAgICAvL3BhcmFtZXRlckFzc2VydChib29rSUQudG9VcHBlckNhc2UoKSA9PT0gYm9va0lELCBgY2hlY2tVU0ZNVG9KU09OOiAnYm9va0lEJyBwYXJhbWV0ZXIgc2hvdWxkIGJlIFVQUEVSQ0FTRSBub3QgJyR7Ym9va0lEfSdgKTtcbiAgICAvL3BhcmFtZXRlckFzc2VydChib29rcy5pc1ZhbGlkQm9va0lEKGJvb2tJRCksIGBjaGVja1VTRk1Ub0pTT046ICcke2Jvb2tJRH0nIGlzIG5vdCBhIHZhbGlkIFVTRk0gYm9vayBpZGVudGlmaWVyYCk7XG4gICAgLy9wYXJhbWV0ZXJBc3NlcnQoZmlsZW5hbWUgIT09IHVuZGVmaW5lZCwgXCJjaGVja1VTRk1Ub0pTT046ICdmaWxlbmFtZScgcGFyYW1ldGVyIHNob3VsZCBiZSBkZWZpbmVkXCIpO1xuICAgIC8vcGFyYW1ldGVyQXNzZXJ0KHR5cGVvZiBmaWxlbmFtZSA9PT0gJ3N0cmluZycsIGBjaGVja1VTRk1Ub0pTT046ICdmaWxlbmFtZScgcGFyYW1ldGVyIHNob3VsZCBiZSBhIHN0cmluZyBub3QgYSAnJHt0eXBlb2YgZmlsZW5hbWV9JzogJHtmaWxlbmFtZX1gKTtcbiAgICAvL3BhcmFtZXRlckFzc2VydChnaXZlblRleHQgIT09IHVuZGVmaW5lZCwgXCJjaGVja1VTRk1Ub0pTT046ICdnaXZlblRleHQnIHBhcmFtZXRlciBzaG91bGQgYmUgZGVmaW5lZFwiKTtcbiAgICAvL3BhcmFtZXRlckFzc2VydCh0eXBlb2YgZ2l2ZW5UZXh0ID09PSAnc3RyaW5nJywgYGNoZWNrVVNGTVRvSlNPTjogJ2dpdmVuVGV4dCcgcGFyYW1ldGVyIHNob3VsZCBiZSBhIHN0cmluZyBub3QgYSAnJHt0eXBlb2YgZ2l2ZW5UZXh0fSc6ICR7Z2l2ZW5UZXh0fWApO1xuICAgIC8vcGFyYW1ldGVyQXNzZXJ0KGdpdmVuTG9jYXRpb24gIT09IHVuZGVmaW5lZCwgXCJjaGVja1VTRk1Ub0pTT046ICdnaXZlblJvd0xvY2F0aW9uJyBwYXJhbWV0ZXIgc2hvdWxkIGJlIGRlZmluZWRcIik7XG4gICAgLy9wYXJhbWV0ZXJBc3NlcnQodHlwZW9mIGdpdmVuTG9jYXRpb24gPT09ICdzdHJpbmcnLCBgY2hlY2tVU0ZNVG9KU09OOiAnZ2l2ZW5Sb3dMb2NhdGlvbicgcGFyYW1ldGVyIHNob3VsZCBiZSBhIHN0cmluZyBub3QgYSAnJHt0eXBlb2YgZ2l2ZW5Mb2NhdGlvbn0nYCk7XG5cbiAgICBsZXQgb3VyTG9jYXRpb24gPSBnaXZlbkxvY2F0aW9uO1xuICAgIGlmIChvdXJMb2NhdGlvbiAmJiBvdXJMb2NhdGlvblswXSAhPT0gJyAnKSBvdXJMb2NhdGlvbiA9IGAgJHtvdXJMb2NhdGlvbn1gO1xuICAgIC8vIGlmIChmaWxlbmFtZSkgb3VyTG9jYXRpb24gPSBgIGluICR7ZmlsZW5hbWV9JHtvdXJMb2NhdGlvbn1gO1xuXG5cbiAgICBjb25zdCByZXN1bHQgPSB7IHN1Y2Nlc3NMaXN0OiBbXSwgbm90aWNlTGlzdDogW10gfTtcblxuICAgIGZ1bmN0aW9uIGFkZFN1Y2Nlc3NNZXNzYWdlKHN1Y2Nlc3NTdHJpbmcpIHtcbiAgICAgICAgLy8gZnVuY3Rpb25Mb2coYGNoZWNrVVNGTVRvSlNPTiBzdWNjZXNzOiAke3N1Y2Nlc3NTdHJpbmd9YCk7XG4gICAgICAgIHJlc3VsdC5zdWNjZXNzTGlzdC5wdXNoKHN1Y2Nlc3NTdHJpbmcpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBhZGROb3RpY2U2dG83KHsgcHJpb3JpdHksIG1lc3NhZ2UsIGxpbmVOdW1iZXIsIGNoYXJhY3RlckluZGV4LCBleGNlcnB0LCBsb2NhdGlvbiB9KSB7XG4gICAgICAgIC8qKlxuICAgICAgICAqIEBkZXNjcmlwdGlvbiAtIGFkZHMgYSBuZXcgbm90aWNlIGVudHJ5LCBhZGRpbmcgYm9va0lELEMsViB0byB0aGUgZ2l2ZW4gZmllbGRzXG4gICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IHByaW9yaXR5IC0gbm90aWNlIHByaW9yaXR5IGZyb20gMSAobG93ZXN0KSB0byA5OTkgKGhpZ2hlc3QpXG4gICAgICAgICogQHBhcmFtIHtzdHJpbmd9IG1lc3NhZ2UgLSB0aGUgdGV4dCBvZiB0aGUgbm90aWNlIG1lc3NhZ2VcbiAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gY2hhcmFjdGVySW5kZXggLSB3aGVyZSB0aGUgaXNzdWUgb2NjdXJzIGluIHRoZSBsaW5lXG4gICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGV4Y2VycHQgLSBzaG9ydCBleGNlcnB0IGZyb20gdGhlIGxpbmUgY2VudHJlZCBvbiB0aGUgcHJvYmxlbSAoaWYgYXZhaWxhYmxlKVxuICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBsb2NhdGlvbiAtIGRlc2NyaXB0aW9uIG9mIHdoZXJlIHRoZSBpc3N1ZSBpcyBsb2NhdGVkXG4gICAgICAgICovXG4gICAgICAgIC8vIGZ1bmN0aW9uTG9nKGBjaGVja1VTRk1Ub0pTT04gbm90aWNlOiAocHJpb3JpdHk9JHtwcmlvcml0eX0pICR7bWVzc2FnZX0ke2NoYXJhY3RlckluZGV4ID4gMCA/IGAgKGF0IGNoYXJhY3RlciAke2NoYXJhY3RlckluZGV4fSlgIDogXCJcIn0ke2V4Y2VycHQgPyBgICR7ZXhjZXJwdH1gIDogXCJcIn0ke2xvY2F0aW9ufWApO1xuICAgICAgICAvL3BhcmFtZXRlckFzc2VydChwcmlvcml0eSAhPT0gdW5kZWZpbmVkLCBcImNVU0ZNanMgYWRkTm90aWNlNnRvNzogJ3ByaW9yaXR5JyBwYXJhbWV0ZXIgc2hvdWxkIGJlIGRlZmluZWRcIik7XG4gICAgICAgIC8vcGFyYW1ldGVyQXNzZXJ0KHR5cGVvZiBwcmlvcml0eSA9PT0gJ251bWJlcicsIGBjVVNGTWpzIGFkZE5vdGljZTZ0bzc6ICdwcmlvcml0eScgcGFyYW1ldGVyIHNob3VsZCBiZSBhIG51bWJlciBub3QgYSAnJHt0eXBlb2YgcHJpb3JpdHl9JzogJHtwcmlvcml0eX1gKTtcbiAgICAgICAgLy9wYXJhbWV0ZXJBc3NlcnQobWVzc2FnZSAhPT0gdW5kZWZpbmVkLCBcImNVU0ZNanMgYWRkTm90aWNlNnRvNzogJ21lc3NhZ2UnIHBhcmFtZXRlciBzaG91bGQgYmUgZGVmaW5lZFwiKTtcbiAgICAgICAgLy9wYXJhbWV0ZXJBc3NlcnQodHlwZW9mIG1lc3NhZ2UgPT09ICdzdHJpbmcnLCBgY1VTRk1qcyBhZGROb3RpY2U2dG83OiAnbWVzc2FnZScgcGFyYW1ldGVyIHNob3VsZCBiZSBhIHN0cmluZyBub3QgYSAnJHt0eXBlb2YgbWVzc2FnZX0nOiAke21lc3NhZ2V9YCk7XG4gICAgICAgIC8vIC8vcGFyYW1ldGVyQXNzZXJ0KGNoYXJhY3RlckluZGV4ICE9PSB1bmRlZmluZWQsIFwiY1VTRk1qcyBhZGROb3RpY2U2dG83OiAnY2hhcmFjdGVySW5kZXgnIHBhcmFtZXRlciBzaG91bGQgYmUgZGVmaW5lZFwiKTtcbiAgICAgICAgaWYgKGNoYXJhY3RlckluZGV4KSB7IC8vcGFyYW1ldGVyQXNzZXJ0KHR5cGVvZiBjaGFyYWN0ZXJJbmRleCA9PT0gJ251bWJlcicsIGBjVVNGTWpzIGFkZE5vdGljZTZ0bzc6ICdjaGFyYWN0ZXJJbmRleCcgcGFyYW1ldGVyIHNob3VsZCBiZSBhIG51bWJlciBub3QgYSAnJHt0eXBlb2YgY2hhcmFjdGVySW5kZXh9JzogJHtjaGFyYWN0ZXJJbmRleH1gKTtcbiAgICAgICAgfVxuICAgICAgICAvLyAvL3BhcmFtZXRlckFzc2VydChleGNlcnB0ICE9PSB1bmRlZmluZWQsIFwiY1VTRk1qcyBhZGROb3RpY2U2dG83OiAnZXhjZXJwdCcgcGFyYW1ldGVyIHNob3VsZCBiZSBkZWZpbmVkXCIpO1xuICAgICAgICBpZiAoZXhjZXJwdCkgeyAvL3BhcmFtZXRlckFzc2VydCh0eXBlb2YgZXhjZXJwdCA9PT0gJ3N0cmluZycsIGBjVVNGTWpzIGFkZE5vdGljZTZ0bzc6ICdleGNlcnB0JyBwYXJhbWV0ZXIgc2hvdWxkIGJlIGEgc3RyaW5nIG5vdCBhICcke3R5cGVvZiBleGNlcnB0fSc6ICR7ZXhjZXJwdH1gKTtcbiAgICAgICAgfVxuICAgICAgICAvL3BhcmFtZXRlckFzc2VydChsb2NhdGlvbiAhPT0gdW5kZWZpbmVkLCBcImNVU0ZNanMgYWRkTm90aWNlNnRvNzogJ2xvY2F0aW9uJyBwYXJhbWV0ZXIgc2hvdWxkIGJlIGRlZmluZWRcIik7XG4gICAgICAgIC8vcGFyYW1ldGVyQXNzZXJ0KHR5cGVvZiBsb2NhdGlvbiA9PT0gJ3N0cmluZycsIGBjVVNGTWpzIGFkZE5vdGljZTZ0bzc6ICdsb2NhdGlvbicgcGFyYW1ldGVyIHNob3VsZCBiZSBhIHN0cmluZyBub3QgYSAnJHt0eXBlb2YgbG9jYXRpb259JzogJHtsb2NhdGlvbn1gKTtcbiAgICAgICAgcmVzdWx0Lm5vdGljZUxpc3QucHVzaCh7IHByaW9yaXR5LCBtZXNzYWdlLCBib29rSUQsIGxpbmVOdW1iZXIsIGNoYXJhY3RlckluZGV4LCBleGNlcnB0LCBsb2NhdGlvbiB9KTtcbiAgICB9XG5cblxuICAgIC8vIFNldCB5b3VyIG9wdGlvbnMgaGVyZSAtLSBjaGFuZ2UgdmFsdWVzIG9yIGNvbW1lbnQgb3V0IGxpbmVzXG4gICAgY29uc3QgY29udmVydE9wdGlvbnMgPSB7XG4gICAgICAgICdjaHVuayc6IGZhbHNlLCAvLyB0cnVlOiByZXR1cm5zIGhlYWRlcnMvY2hhcHRlcnMvdmVyc2VzIChzZWVtcyB3ZWlyZD8/Pyk7IGZhbHNlOiByZXR1cm5zIGhlYWRlcnMvY2hhcHRlcnMgb25seS5cbiAgICAgICAgLy8nY29udGVudC1zb3VyY2UnOiBvdXJMb2NhdGlvbiwgLy8gU2VlbXMgdG8gYmUgaW5jbHVkZWQgaW4gZXZlcnkgc3ViLW9iamVjdCAtLSB3YXN0ZWQgc3BhY2UgPz8/XG4gICAgICAgICdjb252ZXJ0VG9JbnQnOiBbXVxuICAgIH07XG4gICAgY29uc3QgY29udmVydENoZWNrUmVzdWx0ID0gcnVuVXNmbUpzQ2hlY2soZ2l2ZW5UZXh0LCBjb252ZXJ0T3B0aW9ucyk7XG4gICAgLy8gTk9URTogV2UgaGF2ZW7igJl0IGZpZ3VyZWQgb3V0IGhvdyB0byBnZXQgRVJST1JTIG91dCBvZiB0aGlzIHBhcnNlciB5ZXRcblxuICAgIGlmICghY29udmVydENoZWNrUmVzdWx0LmlzVmFsaWRVU0ZNKVxuICAgICAgICBhZGROb3RpY2U2dG83KHsgcHJpb3JpdHk6IDk0MywgbWVzc2FnZTogYFVTRk0zIHRvSlNPTiBDaGVjayBkb2VzbuKAmXQgcGFzc2AsIGxvY2F0aW9uOiBvdXJMb2NhdGlvbiB9KTtcblxuICAgIGFkZFN1Y2Nlc3NNZXNzYWdlKGBDaGVja2VkIFVTRk0tSlNgKTtcbiAgICAvLyBkZWJ1Z0xvZyhgICBjaGVja1VTRk1Ub0pTT04gcmV0dXJuaW5nIHdpdGggJHtyZXN1bHQuc3VjY2Vzc0xpc3QubGVuZ3RoLnRvTG9jYWxlU3RyaW5nKCl9IHN1Y2Nlc3MoZXMpIGFuZCAke3Jlc3VsdC5ub3RpY2VMaXN0Lmxlbmd0aC50b0xvY2FsZVN0cmluZygpfSBub3RpY2UocykuYCk7XG4gICAgLy8gZnVuY3Rpb25Mb2coYGNoZWNrVVNGTVRvSlNPTiByZXN1bHQgaXMgJHtKU09OLnN0cmluZ2lmeShyZXN1bHQpfWApO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG4vLyBlbmQgb2YgY2hlY2tVU0ZNVG9KU09OIGZ1bmN0aW9uXG4iXX0=