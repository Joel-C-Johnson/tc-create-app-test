"use strict";var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");Object.defineProperty(exports, "__esModule", { value: true });exports.checkLexiconFileContents = checkLexiconFileContents;var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));var _defaults = require("./defaults");
var _markdownTextCheck = require("./markdown-text-check");
var _fileTextCheck = require("./file-text-check");

var _utilities = require("./utilities");function _createForOfIteratorHelper(o, allowArrayLike) {var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];if (!it) {if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {if (it) o = it;var i = 0;var F = function F() {};return { s: F, n: function n() {if (i >= o.length) return { done: true };return { done: false, value: o[i++] };}, e: function e(_e) {throw _e;}, f: F };}throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");}var normalCompletion = true,didErr = false,err;return { s: function s() {it = it.call(o);}, n: function n() {var step = it.next();normalCompletion = step.done;return step;}, e: function e(_e2) {didErr = true;err = _e2;}, f: function f() {try {if (!normalCompletion && it.return != null) it.return();} finally {if (didErr) throw err;}} };}function _unsupportedIterableToArray(o, minLen) {if (!o) return;if (typeof o === "string") return _arrayLikeToArray(o, minLen);var n = Object.prototype.toString.call(o).slice(8, -1);if (n === "Object" && o.constructor) n = o.constructor.name;if (n === "Map" || n === "Set") return Array.from(o);if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);}function _arrayLikeToArray(arr, len) {if (len == null || len > arr.length) len = arr.length;for (var i = 0, arr2 = new Array(len); i < len; i++) {arr2[i] = arr[i];}return arr2;}function ownKeys(object, enumerableOnly) {var keys = Object.keys(object);if (Object.getOwnPropertySymbols) {var symbols = Object.getOwnPropertySymbols(object);if (enumerableOnly) {symbols = symbols.filter(function (sym) {return Object.getOwnPropertyDescriptor(object, sym).enumerable;});}keys.push.apply(keys, symbols);}return keys;}function _objectSpread(target) {for (var i = 1; i < arguments.length; i++) {var source = arguments[i] != null ? arguments[i] : {};if (i % 2) {ownKeys(Object(source), true).forEach(function (key) {(0, _defineProperty2.default)(target, key, source[key]);});} else if (Object.getOwnPropertyDescriptors) {Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));} else {ownKeys(Object(source)).forEach(function (key) {Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));});}}return target;}


var LEXICON_MARKDOWN_FILE_VALIDATOR_VERSION_STRING = '0.4.4';


/**
 *
 * @param {string} languageCode
 * @param {string} repoCode -- e.g., 'UHAL', or 'UGL', etc.
 * @param {string} lexiconFilename -- used for identification
 * @param {string} lexiconMarkdownText -- the actual text to be checked
 * @param {string} givenLocation
 * @param {Object} checkingOptions
 */function
checkLexiconFileContents(_x, _x2, _x3, _x4, _x5, _x6) {return _checkLexiconFileContents.apply(this, arguments);}








































































































































































// end of checkLexiconFileContents function
function _checkLexiconFileContents() {_checkLexiconFileContents = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee2(languageCode, repoCode, lexiconFilename, lexiconMarkdownText, givenLocation, checkingOptions) {var ourLocation, excerptLength, result, addSuccessMessage, addNoticePartial, ourCheckMarkdownText, _ourCheckMarkdownText, ourFileTextCheck, lines, hierarchy, currentLevel, _iterator2, _step2, line, adjustedLine, colonIndex, compulsoryFields, _loop, _i, _compulsoryFields;return _regenerator.default.wrap(function _callee2$(_context2) {while (1) {switch (_context2.prev = _context2.next) {case 0:ourFileTextCheck = function _ourFileTextCheck(lexiconMarkdownText, optionalFieldLocation, checkingOptions) {// Does basic checks for small errors like leading/trailing spaces, etc.
              // We assume that checking for compulsory fields is done elsewhere
              // Updates the global list of notices
              // debugLog(`cMdFC ourFileTextCheck(${lexiconMarkdownText}, (${lexiconMarkdownText.length}), ${optionalFieldLocation}, ${JSON.stringify(checkingOptions)})`);
              //parameterAssert(lexiconMarkdownText !== undefined, "cMdFC ourFileTextCheck: 'lexiconMarkdownText' parameter should be defined");
              //parameterAssert(typeof lexiconMarkdownText === 'string', `cMdFC ourFileTextCheck: 'lexiconMarkdownText' parameter should be a string not a '${typeof lexiconMarkdownText}'`);
              //parameterAssert(checkingOptions !== undefined, "cMdFC ourFileTextCheck: 'checkingOptions' parameter should be defined");
              var ctfcResultObject = (0, _fileTextCheck.checkTextfileContents)(languageCode, repoCode, 'markdown', lexiconFilename, lexiconMarkdownText, optionalFieldLocation, checkingOptions); // debugLog(`ctfcResultObject=${JSON.stringify(ctfcResultObject)}`);
              // If we need to put everything through addNoticePartial, e.g., for debugging or filtering
              //  process results line by line
              var _iterator = _createForOfIteratorHelper(ctfcResultObject.noticeList),_step;try {for (_iterator.s(); !(_step = _iterator.n()).done;) {var noticeEntry = _step.value;addNoticePartial(noticeEntry);}} catch (err) {_iterator.e(err);} finally {_iterator.f();}};_ourCheckMarkdownText = function _ourCheckMarkdownText3() {_ourCheckMarkdownText = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee(lexiconMarkdownText, optionalFieldLocation, checkingOptions) {var cmtResultObject, _iterator3, _step3, noticeEntry;return _regenerator.default.wrap(function _callee$(_context) {while (1) {switch (_context.prev = _context.next) {case 0:_context.next = 2;return (0, _markdownTextCheck.checkMarkdownText)(languageCode, repoCode, lexiconFilename, lexiconMarkdownText, optionalFieldLocation, checkingOptions);case 2:cmtResultObject = _context.sent; // debugLog(`cmtResultObject=${JSON.stringify(cmtResultObject)}`);
                        // If we need to put everything through addNoticePartial, e.g., for debugging or filtering
                        //  process results line by line
                        _iterator3 = _createForOfIteratorHelper(cmtResultObject.noticeList);try {for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {noticeEntry = _step3.value;addNoticePartial(noticeEntry);}} catch (err) {_iterator3.e(err);} finally {_iterator3.f();}case 5:case "end":return _context.stop();}}}, _callee);}));return _ourCheckMarkdownText.apply(this, arguments);};ourCheckMarkdownText = function _ourCheckMarkdownText2(_x7, _x8, _x9) {return _ourCheckMarkdownText.apply(this, arguments);};addNoticePartial = function _addNoticePartial(noticeObject) {// functionLog(`checkLexiconFileContents addNoticePartial: (priority=${noticeObject.priority}) ${noticeObject.message}${noticeObject.characterIndex > 0 ? ` (at character ${noticeObject.characterIndex})` : ""}${noticeObject.excerpt ? " " + noticeObject.excerpt : ""}${noticeObject.location}`);
              //parameterAssert(noticeObject.priority !== undefined, "cMdT addNoticePartial: 'priority' parameter should be defined");
              //parameterAssert(typeof noticeObject.priority === 'number', `cMdT addNoticePartial: 'priority' parameter should be a number not a '${typeof noticeObject.priority}': ${noticeObject.priority}`);
              //parameterAssert(noticeObject.message !== undefined, "cMdT addNoticePartial: 'message' parameter should be defined");
              //parameterAssert(typeof noticeObject.message === 'string', `cMdT addNoticePartial: 'message' parameter should be a string not a '${typeof noticeObject.message}': ${noticeObject.message}`);
              // //parameterAssert(characterIndex !== undefined, "cMdT addNoticePartial: 'characterIndex' parameter should be defined");
              if (noticeObject.characterIndex) {//parameterAssert(typeof noticeObject.characterIndex === 'number', `cMdT addNoticePartial: 'characterIndex' parameter should be a number not a '${typeof noticeObject.characterIndex}': ${noticeObject.characterIndex}`);
              } // //parameterAssert(excerpt !== undefined, "cMdT addNoticePartial: 'excerpt' parameter should be defined");
              if (noticeObject.excerpt) {//parameterAssert(typeof noticeObject.excerpt === 'string', `cMdT addNoticePartial: 'excerpt' parameter should be a string not a '${typeof noticeObject.excerpt}': ${noticeObject.excerpt}`);
              } //parameterAssert(noticeObject.location !== undefined, "cMdT addNoticePartial: 'location' parameter should be defined");
              //parameterAssert(typeof noticeObject.location === 'string', `cMdT addNoticePartial: 'location' parameter should be a string not a '${typeof noticeObject.location}': ${noticeObject.location}`);
              if (noticeObject.debugChain) noticeObject.debugChain = "checkLexiconFileContents ".concat(noticeObject.debugChain); // Prepend our name
              result.noticeList.push(_objectSpread(_objectSpread({}, noticeObject), {}, { filename: lexiconFilename }));};addSuccessMessage = function _addSuccessMessage(successString) {// debugLog("checkLexiconFileContents success: " + successString);
              result.successList.push(successString);}; /* This function is optimised for checking the entire markdown file, i.e., all lines.
              Returns a result object containing a successList and a noticeList
             */ // functionLog(`checkLexiconFileContents(lC=${languageCode}, rC=${repoCode}, fn=${lexiconFilename}, ${lexiconMarkdownText.length}, ${givenLocation})â€¦`);
            //parameterAssert(languageCode !== undefined, "checkLexiconFileContents: 'languageCode' parameter should be defined");
            //parameterAssert(typeof languageCode === 'string', `checkLexiconFileContents: 'languageCode' parameter should be a string not a '${typeof languageCode}': ${languageCode}`);
            (0, _utilities.parameterAssert)(repoCode === 'UHAL' || repoCode === 'UGL', "checkLexiconFileContents: 'repoCode' parameter should be 'UHAL' or 'UGL', not '".concat(repoCode, "'")); //parameterAssert(lexiconFilename !== undefined, "checkLexiconFileContents: 'lexiconFilename' parameter should be defined");
            //parameterAssert(typeof lexiconFilename === 'string', `checkLexiconFileContents: 'lexiconFilename' parameter should be a string not a '${typeof lexiconFilename}': ${lexiconFilename}`);
            //parameterAssert(lexiconMarkdownText !== undefined, "checkLexiconFileContents: 'lexiconMarkdownText' parameter should be defined");
            //parameterAssert(typeof lexiconMarkdownText === 'string', `checkLexiconFileContents: 'lexiconMarkdownText' parameter should be a string not a '${typeof lexiconMarkdownText}': ${lexiconMarkdownText}`);
            //parameterAssert(givenLocation !== undefined, "checkLexiconFileContents: 'givenLocation' parameter should be defined");
            //parameterAssert(typeof givenLocation === 'string', `checkLexiconFileContents: 'givenLocation' parameter should be a string not a '${typeof givenLocation}': ${givenLocation}`);
            //parameterAssert(givenLocation.indexOf('true') === -1, `checkLexiconFileContents: 'givenLocation' parameter should not be '${givenLocation}'`);
            if (checkingOptions !== undefined) {//parameterAssert(typeof checkingOptions === 'object', `checkLexiconFileContents: 'checkingOptions' parameter should be an object not a '${typeof checkingOptions}': ${JSON.stringify(checkingOptions)}`);
            }ourLocation = givenLocation;if (ourLocation && ourLocation[0] !== ' ') ourLocation = " ".concat(ourLocation);try {excerptLength = checkingOptions === null || checkingOptions === void 0 ? void 0 : checkingOptions.excerptLength;} catch (mdtcError) {}if (typeof excerptLength !== 'number' || isNaN(excerptLength)) {excerptLength = _defaults.DEFAULT_EXCERPT_LENGTH; // debugLog("Using default excerptLength=" + excerptLength);
            } // else
            // debugLog("Using supplied excerptLength=" + excerptLength, `cf. default=${DEFAULT_EXCERPT_LENGTH}`);
            // const excerptHalfLength = Math.floor(excerptLength / 2); // rounded down
            // const excerptHalfLengthPlus = Math.floor((excerptLength + 1) / 2); // rounded up
            // debugLog("Using excerptHalfLength=" + excerptHalfLength, `excerptHalfLengthPlus=${excerptHalfLengthPlus}`);
            result = { successList: [], noticeList: [] }; // end of ourFileTextCheck function
            // Main code for checkLexiconFileContents function
            lines = lexiconMarkdownText.split('\n'); // debugLog(`  '${location}' has ${lines.length.toLocaleString()} total lines`);
            // Create the hierarchy of the headings
            hierarchy = [];_iterator2 = _createForOfIteratorHelper(lines);try {for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {line = _step2.value;if (line.startsWith('## ')) {currentLevel = line.substring(3);hierarchy.push({ level: currentLevel, sublevels: [] });}if (currentLevel && line.startsWith('* ')) {adjustedLine = line.substring(2);colonIndex = adjustedLine.indexOf(':');if (colonIndex !== -1) adjustedLine = adjustedLine.substring(0, colonIndex); // we don't want the actual data
                  hierarchy[hierarchy.length - 1].sublevels.push(adjustedLine);}} // debugLog(`checkLexiconFileContents hierarchy=${JSON.stringify(hierarchy)}`);
            } catch (err) {_iterator2.e(err);} finally {_iterator2.f();}compulsoryFields = ['## Word data', '## Etymology', '## Senses'];if (repoCode === 'UHAL') {} else if (repoCode === 'UGL') {} // This next part is common for UHAL and UGL
            if (!lines[0].startsWith('# ') || lines[0].length < 4) addNoticePartial({ priority: 630, message: "Expected lexicon lemma on first line", except: lines[0], location: ourLocation });if (!lines[2].startsWith('<!-- Status: ')) addNoticePartial({ priority: 330, message: "Expected lexicon entry status on third line", except: lines[2], location: ourLocation });_loop = function _loop() {var compulsoryField = _compulsoryFields[_i];if (!lines.find(function (field) {return field.startsWith(compulsoryField);})) addNoticePartial({ priority: 620, message: "Expected lexicon lemma on first line", except: lines[0], location: ourLocation });};for (_i = 0, _compulsoryFields = compulsoryFields; _i < _compulsoryFields.length; _i++) {_loop();} // Now do the standard markdown checks
            _context2.next = 24;return ourCheckMarkdownText(lexiconMarkdownText, givenLocation, checkingOptions);case 24:ourFileTextCheck(lexiconMarkdownText, givenLocation, checkingOptions);addSuccessMessage("Checked lexicon file: ".concat(lexiconFilename));if (result.noticeList.length) addSuccessMessage("checkLexiconFileContents v".concat(LEXICON_MARKDOWN_FILE_VALIDATOR_VERSION_STRING, " finished with ").concat(result.noticeList.length ? result.noticeList.length.toLocaleString() : "zero", " notice").concat(result.noticeList.length === 1 ? '' : 's'));else addSuccessMessage("No errors or warnings found by checkLexiconFileContents v".concat(LEXICON_MARKDOWN_FILE_VALIDATOR_VERSION_STRING)); // debugLog(`  checkLexiconFileContents returning with ${result.successList.length.toLocaleString()} success(es), ${result.noticeList.length.toLocaleString()} notice(s).`);
            // userLog(`checkLexiconFileContents result is ${JSON.stringify(result)}`);
            return _context2.abrupt("return", result);case 28:case "end":return _context2.stop();}}}, _callee2);}));return _checkLexiconFileContents.apply(this, arguments);}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9jb3JlL2xleGljb24tZmlsZS1jb250ZW50cy1jaGVjay5qcyJdLCJuYW1lcyI6WyJMRVhJQ09OX01BUktET1dOX0ZJTEVfVkFMSURBVE9SX1ZFUlNJT05fU1RSSU5HIiwiY2hlY2tMZXhpY29uRmlsZUNvbnRlbnRzIiwibGFuZ3VhZ2VDb2RlIiwicmVwb0NvZGUiLCJsZXhpY29uRmlsZW5hbWUiLCJsZXhpY29uTWFya2Rvd25UZXh0IiwiZ2l2ZW5Mb2NhdGlvbiIsImNoZWNraW5nT3B0aW9ucyIsImFkZFN1Y2Nlc3NNZXNzYWdlIiwiYWRkTm90aWNlUGFydGlhbCIsIm91ckNoZWNrTWFya2Rvd25UZXh0Iiwib3VyRmlsZVRleHRDaGVjayIsIm9wdGlvbmFsRmllbGRMb2NhdGlvbiIsImN0ZmNSZXN1bHRPYmplY3QiLCJub3RpY2VMaXN0Iiwibm90aWNlRW50cnkiLCJjbXRSZXN1bHRPYmplY3QiLCJub3RpY2VPYmplY3QiLCJjaGFyYWN0ZXJJbmRleCIsImV4Y2VycHQiLCJkZWJ1Z0NoYWluIiwicmVzdWx0IiwicHVzaCIsImZpbGVuYW1lIiwic3VjY2Vzc1N0cmluZyIsInN1Y2Nlc3NMaXN0IiwidW5kZWZpbmVkIiwib3VyTG9jYXRpb24iLCJleGNlcnB0TGVuZ3RoIiwibWR0Y0Vycm9yIiwiaXNOYU4iLCJERUZBVUxUX0VYQ0VSUFRfTEVOR1RIIiwibGluZXMiLCJzcGxpdCIsImhpZXJhcmNoeSIsImxpbmUiLCJzdGFydHNXaXRoIiwiY3VycmVudExldmVsIiwic3Vic3RyaW5nIiwibGV2ZWwiLCJzdWJsZXZlbHMiLCJhZGp1c3RlZExpbmUiLCJjb2xvbkluZGV4IiwiaW5kZXhPZiIsImxlbmd0aCIsImNvbXB1bHNvcnlGaWVsZHMiLCJwcmlvcml0eSIsIm1lc3NhZ2UiLCJleGNlcHQiLCJsb2NhdGlvbiIsImNvbXB1bHNvcnlGaWVsZCIsImZpbmQiLCJmaWVsZCIsInRvTG9jYWxlU3RyaW5nIl0sIm1hcHBpbmdzIjoiaWZBQUE7QUFD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QVcsVUFBQ0MsS0FBRCxFQUFXLENBQUUsT0FBT0EsS0FBSyxDQUFDaEIsVUFBTixDQUFpQmMsZUFBakIsQ0FBUCxDQUEwQyxDQUFsRSxDQUFMLEVBQ0l6QyxnQkFBZ0IsQ0FBQyxFQUFFcUMsUUFBUSxFQUFFLEdBQVosRUFBaUJDLE9BQU8sd0NBQXhCLEVBQWtFQyxNQUFNLEVBQUVoQixLQUFLLENBQUMsQ0FBRCxDQUEvRSxFQUFvRmlCLFFBQVEsRUFBRXRCLFdBQTlGLEVBQUQsQ0FBaEIsQ0F6SkwsRUF1SkgsaUNBQThCa0IsZ0JBQTlCLGlEQXZKRyxDQTJKSDtBQTNKRyx1Q0E0SkduQyxvQkFBb0IsQ0FBQ0wsbUJBQUQsRUFBc0JDLGFBQXRCLEVBQXFDQyxlQUFyQyxDQTVKdkIsU0E2SkhJLGdCQUFnQixDQUFDTixtQkFBRCxFQUFzQkMsYUFBdEIsRUFBcUNDLGVBQXJDLENBQWhCLENBR0FDLGlCQUFpQixpQ0FBMEJKLGVBQTFCLEVBQWpCLENBQ0EsSUFBSWlCLE1BQU0sQ0FBQ1AsVUFBUCxDQUFrQjhCLE1BQXRCLEVBQ0lwQyxpQkFBaUIscUNBQThCUiw4Q0FBOUIsNEJBQThGcUIsTUFBTSxDQUFDUCxVQUFQLENBQWtCOEIsTUFBbEIsR0FBMkJ2QixNQUFNLENBQUNQLFVBQVAsQ0FBa0I4QixNQUFsQixDQUF5QlMsY0FBekIsRUFBM0IsR0FBdUUsTUFBckssb0JBQXFMaEMsTUFBTSxDQUFDUCxVQUFQLENBQWtCOEIsTUFBbEIsS0FBNkIsQ0FBN0IsR0FBaUMsRUFBakMsR0FBc0MsR0FBM04sRUFBakIsQ0FESixLQUdJcEMsaUJBQWlCLG9FQUE2RFIsOENBQTdELEVBQWpCLENBcEtELENBcUtIO0FBQ0E7QUF0S0csOENBdUtJcUIsTUF2S0osNkQiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBERUZBVUxUX0VYQ0VSUFRfTEVOR1RIIH0gZnJvbSAnLi9kZWZhdWx0cydcbmltcG9ydCB7IGNoZWNrTWFya2Rvd25UZXh0IH0gZnJvbSAnLi9tYXJrZG93bi10ZXh0LWNoZWNrJztcbmltcG9ydCB7IGNoZWNrVGV4dGZpbGVDb250ZW50cyB9IGZyb20gJy4vZmlsZS10ZXh0LWNoZWNrJztcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtdmFyc1xuaW1wb3J0IHsgdXNlckxvZywgZnVuY3Rpb25Mb2csIGRlYnVnTG9nLCBwYXJhbWV0ZXJBc3NlcnQgfSBmcm9tICcuL3V0aWxpdGllcyc7XG5cblxuY29uc3QgTEVYSUNPTl9NQVJLRE9XTl9GSUxFX1ZBTElEQVRPUl9WRVJTSU9OX1NUUklORyA9ICcwLjQuNCc7XG5cblxuLyoqXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGxhbmd1YWdlQ29kZVxuICogQHBhcmFtIHtzdHJpbmd9IHJlcG9Db2RlIC0tIGUuZy4sICdVSEFMJywgb3IgJ1VHTCcsIGV0Yy5cbiAqIEBwYXJhbSB7c3RyaW5nfSBsZXhpY29uRmlsZW5hbWUgLS0gdXNlZCBmb3IgaWRlbnRpZmljYXRpb25cbiAqIEBwYXJhbSB7c3RyaW5nfSBsZXhpY29uTWFya2Rvd25UZXh0IC0tIHRoZSBhY3R1YWwgdGV4dCB0byBiZSBjaGVja2VkXG4gKiBAcGFyYW0ge3N0cmluZ30gZ2l2ZW5Mb2NhdGlvblxuICogQHBhcmFtIHtPYmplY3R9IGNoZWNraW5nT3B0aW9uc1xuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gY2hlY2tMZXhpY29uRmlsZUNvbnRlbnRzKGxhbmd1YWdlQ29kZSwgcmVwb0NvZGUsIGxleGljb25GaWxlbmFtZSwgbGV4aWNvbk1hcmtkb3duVGV4dCwgZ2l2ZW5Mb2NhdGlvbiwgY2hlY2tpbmdPcHRpb25zKSB7XG4gICAgLyogVGhpcyBmdW5jdGlvbiBpcyBvcHRpbWlzZWQgZm9yIGNoZWNraW5nIHRoZSBlbnRpcmUgbWFya2Rvd24gZmlsZSwgaS5lLiwgYWxsIGxpbmVzLlxuXG4gICAgIFJldHVybnMgYSByZXN1bHQgb2JqZWN0IGNvbnRhaW5pbmcgYSBzdWNjZXNzTGlzdCBhbmQgYSBub3RpY2VMaXN0XG4gICAgICovXG4gICAgLy8gZnVuY3Rpb25Mb2coYGNoZWNrTGV4aWNvbkZpbGVDb250ZW50cyhsQz0ke2xhbmd1YWdlQ29kZX0sIHJDPSR7cmVwb0NvZGV9LCBmbj0ke2xleGljb25GaWxlbmFtZX0sICR7bGV4aWNvbk1hcmtkb3duVGV4dC5sZW5ndGh9LCAke2dpdmVuTG9jYXRpb259KeKApmApO1xuICAgIC8vcGFyYW1ldGVyQXNzZXJ0KGxhbmd1YWdlQ29kZSAhPT0gdW5kZWZpbmVkLCBcImNoZWNrTGV4aWNvbkZpbGVDb250ZW50czogJ2xhbmd1YWdlQ29kZScgcGFyYW1ldGVyIHNob3VsZCBiZSBkZWZpbmVkXCIpO1xuICAgIC8vcGFyYW1ldGVyQXNzZXJ0KHR5cGVvZiBsYW5ndWFnZUNvZGUgPT09ICdzdHJpbmcnLCBgY2hlY2tMZXhpY29uRmlsZUNvbnRlbnRzOiAnbGFuZ3VhZ2VDb2RlJyBwYXJhbWV0ZXIgc2hvdWxkIGJlIGEgc3RyaW5nIG5vdCBhICcke3R5cGVvZiBsYW5ndWFnZUNvZGV9JzogJHtsYW5ndWFnZUNvZGV9YCk7XG4gICAgcGFyYW1ldGVyQXNzZXJ0KHJlcG9Db2RlID09PSAnVUhBTCcgfHwgcmVwb0NvZGUgPT09ICdVR0wnLCBgY2hlY2tMZXhpY29uRmlsZUNvbnRlbnRzOiAncmVwb0NvZGUnIHBhcmFtZXRlciBzaG91bGQgYmUgJ1VIQUwnIG9yICdVR0wnLCBub3QgJyR7cmVwb0NvZGV9J2ApO1xuICAgIC8vcGFyYW1ldGVyQXNzZXJ0KGxleGljb25GaWxlbmFtZSAhPT0gdW5kZWZpbmVkLCBcImNoZWNrTGV4aWNvbkZpbGVDb250ZW50czogJ2xleGljb25GaWxlbmFtZScgcGFyYW1ldGVyIHNob3VsZCBiZSBkZWZpbmVkXCIpO1xuICAgIC8vcGFyYW1ldGVyQXNzZXJ0KHR5cGVvZiBsZXhpY29uRmlsZW5hbWUgPT09ICdzdHJpbmcnLCBgY2hlY2tMZXhpY29uRmlsZUNvbnRlbnRzOiAnbGV4aWNvbkZpbGVuYW1lJyBwYXJhbWV0ZXIgc2hvdWxkIGJlIGEgc3RyaW5nIG5vdCBhICcke3R5cGVvZiBsZXhpY29uRmlsZW5hbWV9JzogJHtsZXhpY29uRmlsZW5hbWV9YCk7XG4gICAgLy9wYXJhbWV0ZXJBc3NlcnQobGV4aWNvbk1hcmtkb3duVGV4dCAhPT0gdW5kZWZpbmVkLCBcImNoZWNrTGV4aWNvbkZpbGVDb250ZW50czogJ2xleGljb25NYXJrZG93blRleHQnIHBhcmFtZXRlciBzaG91bGQgYmUgZGVmaW5lZFwiKTtcbiAgICAvL3BhcmFtZXRlckFzc2VydCh0eXBlb2YgbGV4aWNvbk1hcmtkb3duVGV4dCA9PT0gJ3N0cmluZycsIGBjaGVja0xleGljb25GaWxlQ29udGVudHM6ICdsZXhpY29uTWFya2Rvd25UZXh0JyBwYXJhbWV0ZXIgc2hvdWxkIGJlIGEgc3RyaW5nIG5vdCBhICcke3R5cGVvZiBsZXhpY29uTWFya2Rvd25UZXh0fSc6ICR7bGV4aWNvbk1hcmtkb3duVGV4dH1gKTtcbiAgICAvL3BhcmFtZXRlckFzc2VydChnaXZlbkxvY2F0aW9uICE9PSB1bmRlZmluZWQsIFwiY2hlY2tMZXhpY29uRmlsZUNvbnRlbnRzOiAnZ2l2ZW5Mb2NhdGlvbicgcGFyYW1ldGVyIHNob3VsZCBiZSBkZWZpbmVkXCIpO1xuICAgIC8vcGFyYW1ldGVyQXNzZXJ0KHR5cGVvZiBnaXZlbkxvY2F0aW9uID09PSAnc3RyaW5nJywgYGNoZWNrTGV4aWNvbkZpbGVDb250ZW50czogJ2dpdmVuTG9jYXRpb24nIHBhcmFtZXRlciBzaG91bGQgYmUgYSBzdHJpbmcgbm90IGEgJyR7dHlwZW9mIGdpdmVuTG9jYXRpb259JzogJHtnaXZlbkxvY2F0aW9ufWApO1xuICAgIC8vcGFyYW1ldGVyQXNzZXJ0KGdpdmVuTG9jYXRpb24uaW5kZXhPZigndHJ1ZScpID09PSAtMSwgYGNoZWNrTGV4aWNvbkZpbGVDb250ZW50czogJ2dpdmVuTG9jYXRpb24nIHBhcmFtZXRlciBzaG91bGQgbm90IGJlICcke2dpdmVuTG9jYXRpb259J2ApO1xuICAgIGlmIChjaGVja2luZ09wdGlvbnMgIT09IHVuZGVmaW5lZCkgeyAvL3BhcmFtZXRlckFzc2VydCh0eXBlb2YgY2hlY2tpbmdPcHRpb25zID09PSAnb2JqZWN0JywgYGNoZWNrTGV4aWNvbkZpbGVDb250ZW50czogJ2NoZWNraW5nT3B0aW9ucycgcGFyYW1ldGVyIHNob3VsZCBiZSBhbiBvYmplY3Qgbm90IGEgJyR7dHlwZW9mIGNoZWNraW5nT3B0aW9uc30nOiAke0pTT04uc3RyaW5naWZ5KGNoZWNraW5nT3B0aW9ucyl9YCk7XG4gICAgfVxuXG4gICAgbGV0IG91ckxvY2F0aW9uID0gZ2l2ZW5Mb2NhdGlvbjtcbiAgICBpZiAob3VyTG9jYXRpb24gJiYgb3VyTG9jYXRpb25bMF0gIT09ICcgJykgb3VyTG9jYXRpb24gPSBgICR7b3VyTG9jYXRpb259YDtcblxuICAgIGxldCBleGNlcnB0TGVuZ3RoO1xuICAgIHRyeSB7XG4gICAgICAgIGV4Y2VycHRMZW5ndGggPSBjaGVja2luZ09wdGlvbnM/LmV4Y2VycHRMZW5ndGg7XG4gICAgfSBjYXRjaCAobWR0Y0Vycm9yKSB7IH1cbiAgICBpZiAodHlwZW9mIGV4Y2VycHRMZW5ndGggIT09ICdudW1iZXInIHx8IGlzTmFOKGV4Y2VycHRMZW5ndGgpKSB7XG4gICAgICAgIGV4Y2VycHRMZW5ndGggPSBERUZBVUxUX0VYQ0VSUFRfTEVOR1RIO1xuICAgICAgICAvLyBkZWJ1Z0xvZyhcIlVzaW5nIGRlZmF1bHQgZXhjZXJwdExlbmd0aD1cIiArIGV4Y2VycHRMZW5ndGgpO1xuICAgIH1cbiAgICAvLyBlbHNlXG4gICAgLy8gZGVidWdMb2coXCJVc2luZyBzdXBwbGllZCBleGNlcnB0TGVuZ3RoPVwiICsgZXhjZXJwdExlbmd0aCwgYGNmLiBkZWZhdWx0PSR7REVGQVVMVF9FWENFUlBUX0xFTkdUSH1gKTtcbiAgICAvLyBjb25zdCBleGNlcnB0SGFsZkxlbmd0aCA9IE1hdGguZmxvb3IoZXhjZXJwdExlbmd0aCAvIDIpOyAvLyByb3VuZGVkIGRvd25cbiAgICAvLyBjb25zdCBleGNlcnB0SGFsZkxlbmd0aFBsdXMgPSBNYXRoLmZsb29yKChleGNlcnB0TGVuZ3RoICsgMSkgLyAyKTsgLy8gcm91bmRlZCB1cFxuICAgIC8vIGRlYnVnTG9nKFwiVXNpbmcgZXhjZXJwdEhhbGZMZW5ndGg9XCIgKyBleGNlcnB0SGFsZkxlbmd0aCwgYGV4Y2VycHRIYWxmTGVuZ3RoUGx1cz0ke2V4Y2VycHRIYWxmTGVuZ3RoUGx1c31gKTtcblxuICAgIGNvbnN0IHJlc3VsdCA9IHsgc3VjY2Vzc0xpc3Q6IFtdLCBub3RpY2VMaXN0OiBbXSB9O1xuXG4gICAgZnVuY3Rpb24gYWRkU3VjY2Vzc01lc3NhZ2Uoc3VjY2Vzc1N0cmluZykge1xuICAgICAgICAvLyBkZWJ1Z0xvZyhcImNoZWNrTGV4aWNvbkZpbGVDb250ZW50cyBzdWNjZXNzOiBcIiArIHN1Y2Nlc3NTdHJpbmcpO1xuICAgICAgICByZXN1bHQuc3VjY2Vzc0xpc3QucHVzaChzdWNjZXNzU3RyaW5nKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYWRkTm90aWNlUGFydGlhbChub3RpY2VPYmplY3QpIHtcbiAgICAgICAgLy8gZnVuY3Rpb25Mb2coYGNoZWNrTGV4aWNvbkZpbGVDb250ZW50cyBhZGROb3RpY2VQYXJ0aWFsOiAocHJpb3JpdHk9JHtub3RpY2VPYmplY3QucHJpb3JpdHl9KSAke25vdGljZU9iamVjdC5tZXNzYWdlfSR7bm90aWNlT2JqZWN0LmNoYXJhY3RlckluZGV4ID4gMCA/IGAgKGF0IGNoYXJhY3RlciAke25vdGljZU9iamVjdC5jaGFyYWN0ZXJJbmRleH0pYCA6IFwiXCJ9JHtub3RpY2VPYmplY3QuZXhjZXJwdCA/IFwiIFwiICsgbm90aWNlT2JqZWN0LmV4Y2VycHQgOiBcIlwifSR7bm90aWNlT2JqZWN0LmxvY2F0aW9ufWApO1xuICAgICAgICAvL3BhcmFtZXRlckFzc2VydChub3RpY2VPYmplY3QucHJpb3JpdHkgIT09IHVuZGVmaW5lZCwgXCJjTWRUIGFkZE5vdGljZVBhcnRpYWw6ICdwcmlvcml0eScgcGFyYW1ldGVyIHNob3VsZCBiZSBkZWZpbmVkXCIpO1xuICAgICAgICAvL3BhcmFtZXRlckFzc2VydCh0eXBlb2Ygbm90aWNlT2JqZWN0LnByaW9yaXR5ID09PSAnbnVtYmVyJywgYGNNZFQgYWRkTm90aWNlUGFydGlhbDogJ3ByaW9yaXR5JyBwYXJhbWV0ZXIgc2hvdWxkIGJlIGEgbnVtYmVyIG5vdCBhICcke3R5cGVvZiBub3RpY2VPYmplY3QucHJpb3JpdHl9JzogJHtub3RpY2VPYmplY3QucHJpb3JpdHl9YCk7XG4gICAgICAgIC8vcGFyYW1ldGVyQXNzZXJ0KG5vdGljZU9iamVjdC5tZXNzYWdlICE9PSB1bmRlZmluZWQsIFwiY01kVCBhZGROb3RpY2VQYXJ0aWFsOiAnbWVzc2FnZScgcGFyYW1ldGVyIHNob3VsZCBiZSBkZWZpbmVkXCIpO1xuICAgICAgICAvL3BhcmFtZXRlckFzc2VydCh0eXBlb2Ygbm90aWNlT2JqZWN0Lm1lc3NhZ2UgPT09ICdzdHJpbmcnLCBgY01kVCBhZGROb3RpY2VQYXJ0aWFsOiAnbWVzc2FnZScgcGFyYW1ldGVyIHNob3VsZCBiZSBhIHN0cmluZyBub3QgYSAnJHt0eXBlb2Ygbm90aWNlT2JqZWN0Lm1lc3NhZ2V9JzogJHtub3RpY2VPYmplY3QubWVzc2FnZX1gKTtcbiAgICAgICAgLy8gLy9wYXJhbWV0ZXJBc3NlcnQoY2hhcmFjdGVySW5kZXggIT09IHVuZGVmaW5lZCwgXCJjTWRUIGFkZE5vdGljZVBhcnRpYWw6ICdjaGFyYWN0ZXJJbmRleCcgcGFyYW1ldGVyIHNob3VsZCBiZSBkZWZpbmVkXCIpO1xuICAgICAgICBpZiAobm90aWNlT2JqZWN0LmNoYXJhY3RlckluZGV4KSB7IC8vcGFyYW1ldGVyQXNzZXJ0KHR5cGVvZiBub3RpY2VPYmplY3QuY2hhcmFjdGVySW5kZXggPT09ICdudW1iZXInLCBgY01kVCBhZGROb3RpY2VQYXJ0aWFsOiAnY2hhcmFjdGVySW5kZXgnIHBhcmFtZXRlciBzaG91bGQgYmUgYSBudW1iZXIgbm90IGEgJyR7dHlwZW9mIG5vdGljZU9iamVjdC5jaGFyYWN0ZXJJbmRleH0nOiAke25vdGljZU9iamVjdC5jaGFyYWN0ZXJJbmRleH1gKTtcbiAgICAgICAgfVxuICAgICAgICAvLyAvL3BhcmFtZXRlckFzc2VydChleGNlcnB0ICE9PSB1bmRlZmluZWQsIFwiY01kVCBhZGROb3RpY2VQYXJ0aWFsOiAnZXhjZXJwdCcgcGFyYW1ldGVyIHNob3VsZCBiZSBkZWZpbmVkXCIpO1xuICAgICAgICBpZiAobm90aWNlT2JqZWN0LmV4Y2VycHQpIHsgLy9wYXJhbWV0ZXJBc3NlcnQodHlwZW9mIG5vdGljZU9iamVjdC5leGNlcnB0ID09PSAnc3RyaW5nJywgYGNNZFQgYWRkTm90aWNlUGFydGlhbDogJ2V4Y2VycHQnIHBhcmFtZXRlciBzaG91bGQgYmUgYSBzdHJpbmcgbm90IGEgJyR7dHlwZW9mIG5vdGljZU9iamVjdC5leGNlcnB0fSc6ICR7bm90aWNlT2JqZWN0LmV4Y2VycHR9YCk7XG4gICAgICAgIH1cbiAgICAgICAgLy9wYXJhbWV0ZXJBc3NlcnQobm90aWNlT2JqZWN0LmxvY2F0aW9uICE9PSB1bmRlZmluZWQsIFwiY01kVCBhZGROb3RpY2VQYXJ0aWFsOiAnbG9jYXRpb24nIHBhcmFtZXRlciBzaG91bGQgYmUgZGVmaW5lZFwiKTtcbiAgICAgICAgLy9wYXJhbWV0ZXJBc3NlcnQodHlwZW9mIG5vdGljZU9iamVjdC5sb2NhdGlvbiA9PT0gJ3N0cmluZycsIGBjTWRUIGFkZE5vdGljZVBhcnRpYWw6ICdsb2NhdGlvbicgcGFyYW1ldGVyIHNob3VsZCBiZSBhIHN0cmluZyBub3QgYSAnJHt0eXBlb2Ygbm90aWNlT2JqZWN0LmxvY2F0aW9ufSc6ICR7bm90aWNlT2JqZWN0LmxvY2F0aW9ufWApO1xuXG4gICAgICAgIGlmIChub3RpY2VPYmplY3QuZGVidWdDaGFpbikgbm90aWNlT2JqZWN0LmRlYnVnQ2hhaW4gPSBgY2hlY2tMZXhpY29uRmlsZUNvbnRlbnRzICR7bm90aWNlT2JqZWN0LmRlYnVnQ2hhaW59YDsgLy8gUHJlcGVuZCBvdXIgbmFtZVxuICAgICAgICByZXN1bHQubm90aWNlTGlzdC5wdXNoKHsgLi4ubm90aWNlT2JqZWN0LCBmaWxlbmFtZTogbGV4aWNvbkZpbGVuYW1lIH0pO1xuICAgIH1cbiAgICAvLyBlbmQgb2YgYWRkTm90aWNlUGFydGlhbCBmdW5jdGlvblxuXG4gICAgLyoqXG4gICAgKiBAZGVzY3JpcHRpb24gLSBjaGVja3MgdGhlIGdpdmVuIHRleHQgZmllbGQgYW5kIHByb2Nlc3NlcyB0aGUgcmV0dXJuZWQgcmVzdWx0c1xuICAgICogQHBhcmFtIHtzdHJpbmd9IGxleGljb25NYXJrZG93blRleHQgLSB0aGUgYWN0dWFsIHRleHQgb2YgdGhlIGZpbGUgYmVpbmcgY2hlY2tlZFxuICAgICogQHBhcmFtIHtib29sZWFufSBhbGxvd2VkTGlua3MgLSB0cnVlIGlmIGxpbmtzIGFyZSBhbGxvd2VkIGluIHRoZSBmaWVsZCwgb3RoZXJ3aXNlIGZhbHNlXG4gICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9uYWxGaWVsZExvY2F0aW9uIC0gZGVzY3JpcHRpb24gb2Ygd2hlcmUgdGhlIGZpZWxkIGlzIGxvY2F0ZWRcbiAgICAqIEBwYXJhbSB7T2JqZWN0fSBjaGVja2luZ09wdGlvbnMgLSBwYXJhbWV0ZXJzIHRoYXQgbWlnaHQgYWZmZWN0IHRoZSBjaGVja1xuICAgICovXG4gICAgYXN5bmMgZnVuY3Rpb24gb3VyQ2hlY2tNYXJrZG93blRleHQobGV4aWNvbk1hcmtkb3duVGV4dCwgb3B0aW9uYWxGaWVsZExvY2F0aW9uLCBjaGVja2luZ09wdGlvbnMpIHtcbiAgICAgICAgLy8gRG9lcyBiYXNpYyBjaGVja3MgZm9yIHNtYWxsIGVycm9ycyBsaWtlIGxlYWRpbmcvdHJhaWxpbmcgc3BhY2VzLCBldGMuXG5cbiAgICAgICAgLy8gV2UgYXNzdW1lIHRoYXQgY2hlY2tpbmcgZm9yIGNvbXB1bHNvcnkgZmllbGRzIGlzIGRvbmUgZWxzZXdoZXJlXG5cbiAgICAgICAgLy8gVXBkYXRlcyB0aGUgZ2xvYmFsIGxpc3Qgb2Ygbm90aWNlc1xuICAgICAgICAvLyBkZWJ1Z0xvZyhgY01kVCBvdXJDaGVja01hcmtkb3duVGV4dCgke2ZpZWxkTmFtZX0sICgke2ZpZWxkVGV4dC5sZW5ndGh9KSwgJHthbGxvd2VkTGlua3N9LCAke29wdGlvbmFsRmllbGRMb2NhdGlvbn0sIOKApilgKTtcbiAgICAgICAgLy9wYXJhbWV0ZXJBc3NlcnQobGV4aWNvbk1hcmtkb3duVGV4dCAhPT0gdW5kZWZpbmVkLCBcImNNZEZDIG91ckNoZWNrTWFya2Rvd25UZXh0OiAnbGV4aWNvbk1hcmtkb3duVGV4dCcgcGFyYW1ldGVyIHNob3VsZCBiZSBkZWZpbmVkXCIpO1xuICAgICAgICAvL3BhcmFtZXRlckFzc2VydCh0eXBlb2YgbGV4aWNvbk1hcmtkb3duVGV4dCA9PT0gJ3N0cmluZycsIGBjTWRGQyBvdXJDaGVja01hcmtkb3duVGV4dDogJ2xleGljb25NYXJrZG93blRleHQnIHBhcmFtZXRlciBzaG91bGQgYmUgYSBzdHJpbmcgbm90IGEgJyR7dHlwZW9mIGxleGljb25NYXJrZG93blRleHR9J2ApO1xuICAgICAgICAvL3BhcmFtZXRlckFzc2VydChvcHRpb25hbEZpZWxkTG9jYXRpb24gIT09IHVuZGVmaW5lZCwgXCJjTWRGQyBvdXJDaGVja01hcmtkb3duVGV4dDogJ29wdGlvbmFsRmllbGRMb2NhdGlvbicgcGFyYW1ldGVyIHNob3VsZCBiZSBkZWZpbmVkXCIpO1xuICAgICAgICAvL3BhcmFtZXRlckFzc2VydCh0eXBlb2Ygb3B0aW9uYWxGaWVsZExvY2F0aW9uID09PSAnc3RyaW5nJywgYGNNZEZDIG91ckNoZWNrTWFya2Rvd25UZXh0OiAnb3B0aW9uYWxGaWVsZExvY2F0aW9uJyBwYXJhbWV0ZXIgc2hvdWxkIGJlIGEgc3RyaW5nIG5vdCBhICcke3R5cGVvZiBvcHRpb25hbEZpZWxkTG9jYXRpb259J2ApO1xuXG4gICAgICAgIGNvbnN0IGNtdFJlc3VsdE9iamVjdCA9IGF3YWl0IGNoZWNrTWFya2Rvd25UZXh0KGxhbmd1YWdlQ29kZSwgcmVwb0NvZGUsIGxleGljb25GaWxlbmFtZSwgbGV4aWNvbk1hcmtkb3duVGV4dCwgb3B0aW9uYWxGaWVsZExvY2F0aW9uLCBjaGVja2luZ09wdGlvbnMpO1xuICAgICAgICAvLyBkZWJ1Z0xvZyhgY210UmVzdWx0T2JqZWN0PSR7SlNPTi5zdHJpbmdpZnkoY210UmVzdWx0T2JqZWN0KX1gKTtcblxuICAgICAgICAvLyBJZiB3ZSBuZWVkIHRvIHB1dCBldmVyeXRoaW5nIHRocm91Z2ggYWRkTm90aWNlUGFydGlhbCwgZS5nLiwgZm9yIGRlYnVnZ2luZyBvciBmaWx0ZXJpbmdcbiAgICAgICAgLy8gIHByb2Nlc3MgcmVzdWx0cyBsaW5lIGJ5IGxpbmVcbiAgICAgICAgZm9yIChjb25zdCBub3RpY2VFbnRyeSBvZiBjbXRSZXN1bHRPYmplY3Qubm90aWNlTGlzdClcbiAgICAgICAgICAgIGFkZE5vdGljZVBhcnRpYWwobm90aWNlRW50cnkpO1xuICAgIH1cbiAgICAvLyBlbmQgb2Ygb3VyQ2hlY2tNYXJrZG93blRleHQgZnVuY3Rpb25cblxuXG4gICAgLyoqXG4gICAgKiBAZGVzY3JpcHRpb24gLSBjaGVja3MgdGhlIGdpdmVuIHRleHQgZmllbGQgYW5kIHByb2Nlc3NlcyB0aGUgcmV0dXJuZWQgcmVzdWx0c1xuICAgICogQHBhcmFtIHtzdHJpbmd9IGxleGljb25NYXJrZG93blRleHQgLSB0aGUgYWN0dWFsIHRleHQgb2YgdGhlIGZpbGUgYmVpbmcgY2hlY2tlZFxuICAgICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbmFsRmllbGRMb2NhdGlvbiAtIGRlc2NyaXB0aW9uIG9mIHdoZXJlIHRoZSBmaWVsZCBpcyBsb2NhdGVkXG4gICAgKiBAcGFyYW0ge09iamVjdH0gY2hlY2tpbmdPcHRpb25zIC0gcGFyYW1ldGVycyB0aGF0IG1pZ2h0IGFmZmVjdCB0aGUgY2hlY2tcbiAgICAqL1xuICAgIGZ1bmN0aW9uIG91ckZpbGVUZXh0Q2hlY2sobGV4aWNvbk1hcmtkb3duVGV4dCwgb3B0aW9uYWxGaWVsZExvY2F0aW9uLCBjaGVja2luZ09wdGlvbnMpIHtcbiAgICAgICAgLy8gRG9lcyBiYXNpYyBjaGVja3MgZm9yIHNtYWxsIGVycm9ycyBsaWtlIGxlYWRpbmcvdHJhaWxpbmcgc3BhY2VzLCBldGMuXG5cbiAgICAgICAgLy8gV2UgYXNzdW1lIHRoYXQgY2hlY2tpbmcgZm9yIGNvbXB1bHNvcnkgZmllbGRzIGlzIGRvbmUgZWxzZXdoZXJlXG5cbiAgICAgICAgLy8gVXBkYXRlcyB0aGUgZ2xvYmFsIGxpc3Qgb2Ygbm90aWNlc1xuICAgICAgICAvLyBkZWJ1Z0xvZyhgY01kRkMgb3VyRmlsZVRleHRDaGVjaygke2xleGljb25NYXJrZG93blRleHR9LCAoJHtsZXhpY29uTWFya2Rvd25UZXh0Lmxlbmd0aH0pLCAke29wdGlvbmFsRmllbGRMb2NhdGlvbn0sICR7SlNPTi5zdHJpbmdpZnkoY2hlY2tpbmdPcHRpb25zKX0pYCk7XG4gICAgICAgIC8vcGFyYW1ldGVyQXNzZXJ0KGxleGljb25NYXJrZG93blRleHQgIT09IHVuZGVmaW5lZCwgXCJjTWRGQyBvdXJGaWxlVGV4dENoZWNrOiAnbGV4aWNvbk1hcmtkb3duVGV4dCcgcGFyYW1ldGVyIHNob3VsZCBiZSBkZWZpbmVkXCIpO1xuICAgICAgICAvL3BhcmFtZXRlckFzc2VydCh0eXBlb2YgbGV4aWNvbk1hcmtkb3duVGV4dCA9PT0gJ3N0cmluZycsIGBjTWRGQyBvdXJGaWxlVGV4dENoZWNrOiAnbGV4aWNvbk1hcmtkb3duVGV4dCcgcGFyYW1ldGVyIHNob3VsZCBiZSBhIHN0cmluZyBub3QgYSAnJHt0eXBlb2YgbGV4aWNvbk1hcmtkb3duVGV4dH0nYCk7XG4gICAgICAgIC8vcGFyYW1ldGVyQXNzZXJ0KGNoZWNraW5nT3B0aW9ucyAhPT0gdW5kZWZpbmVkLCBcImNNZEZDIG91ckZpbGVUZXh0Q2hlY2s6ICdjaGVja2luZ09wdGlvbnMnIHBhcmFtZXRlciBzaG91bGQgYmUgZGVmaW5lZFwiKTtcblxuICAgICAgICBjb25zdCBjdGZjUmVzdWx0T2JqZWN0ID0gY2hlY2tUZXh0ZmlsZUNvbnRlbnRzKGxhbmd1YWdlQ29kZSwgcmVwb0NvZGUsICdtYXJrZG93bicsIGxleGljb25GaWxlbmFtZSwgbGV4aWNvbk1hcmtkb3duVGV4dCwgb3B0aW9uYWxGaWVsZExvY2F0aW9uLCBjaGVja2luZ09wdGlvbnMpO1xuICAgICAgICAvLyBkZWJ1Z0xvZyhgY3RmY1Jlc3VsdE9iamVjdD0ke0pTT04uc3RyaW5naWZ5KGN0ZmNSZXN1bHRPYmplY3QpfWApO1xuXG4gICAgICAgIC8vIElmIHdlIG5lZWQgdG8gcHV0IGV2ZXJ5dGhpbmcgdGhyb3VnaCBhZGROb3RpY2VQYXJ0aWFsLCBlLmcuLCBmb3IgZGVidWdnaW5nIG9yIGZpbHRlcmluZ1xuICAgICAgICAvLyAgcHJvY2VzcyByZXN1bHRzIGxpbmUgYnkgbGluZVxuICAgICAgICBmb3IgKGNvbnN0IG5vdGljZUVudHJ5IG9mIGN0ZmNSZXN1bHRPYmplY3Qubm90aWNlTGlzdClcbiAgICAgICAgICAgIGFkZE5vdGljZVBhcnRpYWwobm90aWNlRW50cnkpO1xuICAgIH1cbiAgICAvLyBlbmQgb2Ygb3VyRmlsZVRleHRDaGVjayBmdW5jdGlvblxuXG5cbiAgICAvLyBNYWluIGNvZGUgZm9yIGNoZWNrTGV4aWNvbkZpbGVDb250ZW50cyBmdW5jdGlvblxuICAgIGNvbnN0IGxpbmVzID0gbGV4aWNvbk1hcmtkb3duVGV4dC5zcGxpdCgnXFxuJyk7XG4gICAgLy8gZGVidWdMb2coYCAgJyR7bG9jYXRpb259JyBoYXMgJHtsaW5lcy5sZW5ndGgudG9Mb2NhbGVTdHJpbmcoKX0gdG90YWwgbGluZXNgKTtcblxuICAgIC8vIENyZWF0ZSB0aGUgaGllcmFyY2h5IG9mIHRoZSBoZWFkaW5nc1xuICAgIGxldCBoaWVyYXJjaHkgPSBbXSwgY3VycmVudExldmVsO1xuICAgIGZvciAoY29uc3QgbGluZSBvZiBsaW5lcykge1xuICAgICAgICBpZiAobGluZS5zdGFydHNXaXRoKCcjIyAnKSkge1xuICAgICAgICAgICAgY3VycmVudExldmVsID0gbGluZS5zdWJzdHJpbmcoMyk7XG4gICAgICAgICAgICBoaWVyYXJjaHkucHVzaCh7IGxldmVsOiBjdXJyZW50TGV2ZWwsIHN1YmxldmVsczogW10gfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGN1cnJlbnRMZXZlbCAmJiBsaW5lLnN0YXJ0c1dpdGgoJyogJykpIHtcbiAgICAgICAgICAgIGxldCBhZGp1c3RlZExpbmUgPWxpbmUuc3Vic3RyaW5nKDIpO1xuICAgICAgICAgICAgY29uc3QgY29sb25JbmRleCA9IGFkanVzdGVkTGluZS5pbmRleE9mKCc6Jyk7XG4gICAgICAgICAgICBpZiAoY29sb25JbmRleCAhPT0gLTEpIGFkanVzdGVkTGluZSA9IGFkanVzdGVkTGluZS5zdWJzdHJpbmcoMCxjb2xvbkluZGV4KTsgLy8gd2UgZG9uJ3Qgd2FudCB0aGUgYWN0dWFsIGRhdGFcbiAgICAgICAgICAgIGhpZXJhcmNoeVtoaWVyYXJjaHkubGVuZ3RoIC0gMV0uc3VibGV2ZWxzLnB1c2goYWRqdXN0ZWRMaW5lKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBkZWJ1Z0xvZyhgY2hlY2tMZXhpY29uRmlsZUNvbnRlbnRzIGhpZXJhcmNoeT0ke0pTT04uc3RyaW5naWZ5KGhpZXJhcmNoeSl9YCk7XG5cbiAgICBsZXQgY29tcHVsc29yeUZpZWxkcyA9IFsnIyMgV29yZCBkYXRhJywgJyMjIEV0eW1vbG9neScsICcjIyBTZW5zZXMnXTtcbiAgICBpZiAocmVwb0NvZGUgPT09ICdVSEFMJykge1xuICAgIH0gZWxzZSBpZiAocmVwb0NvZGUgPT09ICdVR0wnKSB7XG4gICAgfVxuXG4gICAgLy8gVGhpcyBuZXh0IHBhcnQgaXMgY29tbW9uIGZvciBVSEFMIGFuZCBVR0xcbiAgICBpZiAoIWxpbmVzWzBdLnN0YXJ0c1dpdGgoJyMgJykgfHwgbGluZXNbMF0ubGVuZ3RoIDwgNClcbiAgICAgICAgYWRkTm90aWNlUGFydGlhbCh7IHByaW9yaXR5OiA2MzAsIG1lc3NhZ2U6IGBFeHBlY3RlZCBsZXhpY29uIGxlbW1hIG9uIGZpcnN0IGxpbmVgLCBleGNlcHQ6IGxpbmVzWzBdLCBsb2NhdGlvbjogb3VyTG9jYXRpb24gfSk7XG4gICAgaWYgKCFsaW5lc1syXS5zdGFydHNXaXRoKCc8IS0tIFN0YXR1czogJykpXG4gICAgICAgIGFkZE5vdGljZVBhcnRpYWwoeyBwcmlvcml0eTogMzMwLCBtZXNzYWdlOiBgRXhwZWN0ZWQgbGV4aWNvbiBlbnRyeSBzdGF0dXMgb24gdGhpcmQgbGluZWAsIGV4Y2VwdDogbGluZXNbMl0sIGxvY2F0aW9uOiBvdXJMb2NhdGlvbiB9KTtcblxuICAgIGZvciAoY29uc3QgY29tcHVsc29yeUZpZWxkIG9mIGNvbXB1bHNvcnlGaWVsZHMpXG4gICAgICAgIGlmICghbGluZXMuZmluZCgoZmllbGQpID0+IHsgcmV0dXJuIGZpZWxkLnN0YXJ0c1dpdGgoY29tcHVsc29yeUZpZWxkKSB9KSlcbiAgICAgICAgICAgIGFkZE5vdGljZVBhcnRpYWwoeyBwcmlvcml0eTogNjIwLCBtZXNzYWdlOiBgRXhwZWN0ZWQgbGV4aWNvbiBsZW1tYSBvbiBmaXJzdCBsaW5lYCwgZXhjZXB0OiBsaW5lc1swXSwgbG9jYXRpb246IG91ckxvY2F0aW9uIH0pO1xuXG4gICAgLy8gTm93IGRvIHRoZSBzdGFuZGFyZCBtYXJrZG93biBjaGVja3NcbiAgICBhd2FpdCBvdXJDaGVja01hcmtkb3duVGV4dChsZXhpY29uTWFya2Rvd25UZXh0LCBnaXZlbkxvY2F0aW9uLCBjaGVja2luZ09wdGlvbnMpO1xuICAgIG91ckZpbGVUZXh0Q2hlY2sobGV4aWNvbk1hcmtkb3duVGV4dCwgZ2l2ZW5Mb2NhdGlvbiwgY2hlY2tpbmdPcHRpb25zKTtcblxuXG4gICAgYWRkU3VjY2Vzc01lc3NhZ2UoYENoZWNrZWQgbGV4aWNvbiBmaWxlOiAke2xleGljb25GaWxlbmFtZX1gKTtcbiAgICBpZiAocmVzdWx0Lm5vdGljZUxpc3QubGVuZ3RoKVxuICAgICAgICBhZGRTdWNjZXNzTWVzc2FnZShgY2hlY2tMZXhpY29uRmlsZUNvbnRlbnRzIHYke0xFWElDT05fTUFSS0RPV05fRklMRV9WQUxJREFUT1JfVkVSU0lPTl9TVFJJTkd9IGZpbmlzaGVkIHdpdGggJHtyZXN1bHQubm90aWNlTGlzdC5sZW5ndGggPyByZXN1bHQubm90aWNlTGlzdC5sZW5ndGgudG9Mb2NhbGVTdHJpbmcoKSA6IFwiemVyb1wifSBub3RpY2Uke3Jlc3VsdC5ub3RpY2VMaXN0Lmxlbmd0aCA9PT0gMSA/ICcnIDogJ3MnfWApO1xuICAgIGVsc2VcbiAgICAgICAgYWRkU3VjY2Vzc01lc3NhZ2UoYE5vIGVycm9ycyBvciB3YXJuaW5ncyBmb3VuZCBieSBjaGVja0xleGljb25GaWxlQ29udGVudHMgdiR7TEVYSUNPTl9NQVJLRE9XTl9GSUxFX1ZBTElEQVRPUl9WRVJTSU9OX1NUUklOR31gKVxuICAgIC8vIGRlYnVnTG9nKGAgIGNoZWNrTGV4aWNvbkZpbGVDb250ZW50cyByZXR1cm5pbmcgd2l0aCAke3Jlc3VsdC5zdWNjZXNzTGlzdC5sZW5ndGgudG9Mb2NhbGVTdHJpbmcoKX0gc3VjY2VzcyhlcyksICR7cmVzdWx0Lm5vdGljZUxpc3QubGVuZ3RoLnRvTG9jYWxlU3RyaW5nKCl9IG5vdGljZShzKS5gKTtcbiAgICAvLyB1c2VyTG9nKGBjaGVja0xleGljb25GaWxlQ29udGVudHMgcmVzdWx0IGlzICR7SlNPTi5zdHJpbmdpZnkocmVzdWx0KX1gKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuLy8gZW5kIG9mIGNoZWNrTGV4aWNvbkZpbGVDb250ZW50cyBmdW5jdGlvblxuIl19