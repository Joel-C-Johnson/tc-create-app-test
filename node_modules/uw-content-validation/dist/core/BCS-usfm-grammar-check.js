"use strict";var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");var _typeof = require("@babel/runtime/helpers/typeof");Object.defineProperty(exports, "__esModule", { value: true });exports.runBCSGrammarCheck = runBCSGrammarCheck;exports.checkUSFMGrammar = checkUSFMGrammar;var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));var _usfmGrammar = _interopRequireDefault(require("usfm-grammar"));
var books = _interopRequireWildcard(require("../core/books/books"));
var _defaults = require("./defaults");

var _utilities = require("./utilities");function _getRequireWildcardCache(nodeInterop) {if (typeof WeakMap !== "function") return null;var cacheBabelInterop = new WeakMap();var cacheNodeInterop = new WeakMap();return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) {return nodeInterop ? cacheNodeInterop : cacheBabelInterop;})(nodeInterop);}function _interopRequireWildcard(obj, nodeInterop) {if (!nodeInterop && obj && obj.__esModule) {return obj;}if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") {return { default: obj };}var cache = _getRequireWildcardCache(nodeInterop);if (cache && cache.has(obj)) {return cache.get(obj);}var newObj = {};var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;for (var key in obj) {if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;if (desc && (desc.get || desc.set)) {Object.defineProperty(newObj, key, desc);} else {newObj[key] = obj[key];}}}newObj.default = obj;if (cache) {cache.set(obj, newObj);}return newObj;}function ownKeys(object, enumerableOnly) {var keys = Object.keys(object);if (Object.getOwnPropertySymbols) {var symbols = Object.getOwnPropertySymbols(object);if (enumerableOnly) {symbols = symbols.filter(function (sym) {return Object.getOwnPropertyDescriptor(object, sym).enumerable;});}keys.push.apply(keys, symbols);}return keys;}function _objectSpread(target) {for (var i = 1; i < arguments.length; i++) {var source = arguments[i] != null ? arguments[i] : {};if (i % 2) {ownKeys(Object(source), true).forEach(function (key) {(0, _defineProperty2.default)(target, key, source[key]);});} else if (Object.getOwnPropertyDescriptors) {Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));} else {ownKeys(Object(source)).forEach(function (key) {Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));});}}return target;}function _createForOfIteratorHelper(o, allowArrayLike) {var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];if (!it) {if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {if (it) o = it;var i = 0;var F = function F() {};return { s: F, n: function n() {if (i >= o.length) return { done: true };return { done: false, value: o[i++] };}, e: function e(_e) {throw _e;}, f: F };}throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");}var normalCompletion = true,didErr = false,err;return { s: function s() {it = it.call(o);}, n: function n() {var step = it.next();normalCompletion = step.done;return step;}, e: function e(_e2) {didErr = true;err = _e2;}, f: function f() {try {if (!normalCompletion && it.return != null) it.return();} finally {if (didErr) throw err;}} };}function _unsupportedIterableToArray(o, minLen) {if (!o) return;if (typeof o === "string") return _arrayLikeToArray(o, minLen);var n = Object.prototype.toString.call(o).slice(8, -1);if (n === "Object" && o.constructor) n = o.constructor.name;if (n === "Map" || n === "Set") return Array.from(o);if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);}function _arrayLikeToArray(arr, len) {if (len == null || len > arr.length) len = arr.length;for (var i = 0, arr2 = new Array(len); i < len; i++) {arr2[i] = arr[i];}return arr2;}


// const USFM_GRAMMAR_VALIDATOR_VERSION_STRING = '0.4.5';

var LINE_COLUMN_NUMBERS_REGEX = new RegExp('Line (\\d{1,6}), col (\\d{1,4}):'); // e.g., "Line 1538, col 4: 1537 ..."


/**
 *
 * @param {string} strictnessString -- 'strict' or 'relaxed'
 * @param {string} bookID -- 3-character book ID
 * @param {string} fileText -- the actual USFM text
 * @param {string} filename -- for error messages
 * @param {string} givenLocation -- for error messages
 * @param {Object} checkingOptions -- optional options
 * @returns {Object} including isValidUSFM flag
 */
function runBCSGrammarCheck(strictnessString, bookID, fileText, filename, givenLocation, checkingOptions) {
  // Runs the BCS USFM Grammar checker
  //  which can be quite time-consuming on large, complex USFM files
  // userLog(`Running ${strictnessString} BCS USFM grammar check${givenLocation} (can take quite a while for a large book)…`);
  //parameterAssert(strictnessString === 'strict' || strictnessString === 'relaxed', `Unexpected strictnessString='${strictnessString}'`);

  var excerptLength;
  try {
    excerptLength = checkingOptions === null || checkingOptions === void 0 ? void 0 : checkingOptions.excerptLength;
  } catch (usfmELerror) {}
  if (typeof excerptLength !== 'number' || isNaN(excerptLength)) {
    excerptLength = _defaults.DEFAULT_EXCERPT_LENGTH;
    // debugLog(`Using default excerptLength=${excerptLength}`);
  }
  // else
  // debugLog(`Using supplied excerptLength=${excerptLength} cf. default=${DEFAULT_EXCERPT_LENGTH}`);
  var excerptHalfLength = Math.floor(excerptLength / 2); // rounded down
  var excerptHalfLengthPlus = Math.floor((excerptLength + 1) / 2); // rounded up
  // debugLog(`Using excerptHalfLength=${excerptHalfLength}`, `excerptHalfLengthPlus=${excerptHalfLengthPlus}`);

  // Now create the parser and run the check
  var parserToJSONResultObject, parseWarnings;
  try {
    // debugLog(`${new Date().getTime() / 1000} Setting-up the USFMGrammar checker…`);
    var ourUsfmParser = new _usfmGrammar.default.USFMParser(fileText, strictnessString === 'relaxed' ? _usfmGrammar.default.LEVEL.RELAXED : null);
    // Returns a Boolean indicating whether the input USFM text satisfies the grammar or not.
    // This method is available in both default and relaxed modes.
    // const parserResult = ourUsfmParser.validate();
    // debugLog(`${new Date().getTime() / 1000} Running the BCS USFMGrammar checker (may take several seconds)…`);
    // userLog(`Running the BCS USFMGrammar checker for ${bookID} (may take several seconds)…`);
    parserToJSONResultObject = ourUsfmParser.toJSON();
    // debugLog(`${new Date().getTime() / 1000} Got the BCS USFMGrammar checker toJSON result: ${Object.keys(parserToJSONResultObject)}`);
    // debugLog(`${new Date().getTime() / 1000} Got the BCS USFMGrammar checker toJSON _messages: ${Object.keys(parserToJSONResultObject._messages)}`);
    // debugLog(`${new Date().getTime() / 1000} Got the BCS USFMGrammar checker: ${Object.keys(ourUsfmParser)}`);
    parseWarnings = parserToJSONResultObject._warnings ? parserToJSONResultObject._warnings : ourUsfmParser.warnings;
    // debugLog(`${new Date().getTime() / 1000} Got warnings from the BCS USFMGrammar checker: (${parseWarnings.length}) ${parseWarnings}`);
  } catch (parserError) {// This is how the Parser returns USFM errors, i.e., it stops after the first error
    // debugLog(`${new Date().getTime() / 1000} Got an exception when using the BCS USFMGrammar checker: ${parserError}`);
    var _ourErrorObject = {
      priority: 840, message: "USFMGrammar check failed",
      details: parserError,
      filename: filename,
      location: givenLocation };

    try {// See if we can improve the result with line and column numbers
      // NOTE: The following code is quite fragile
      //  as it depends on the precise format of the error message returned from USFMParser
      var regexResultArray = LINE_COLUMN_NUMBERS_REGEX.exec(parserError);
      var _regexResultArray = (0, _slicedToArray2.default)(regexResultArray, 3),totalLink = _regexResultArray[0],_lineNumberString = _regexResultArray[1],columnNumberString = _regexResultArray[2];
      _ourErrorObject.lineNumber = (0, _utilities.ourParseInt)(_lineNumberString);
      _ourErrorObject.characterIndex = (0, _utilities.ourParseInt)(columnNumberString) - 1;
      var errorLineText = fileText.split('\n')[_ourErrorObject.lineNumber - 1];
      _ourErrorObject.excerpt = (_ourErrorObject.characterIndex > excerptHalfLength ? '…' : '') + errorLineText.substring(_ourErrorObject.characterIndex - excerptHalfLength, _ourErrorObject.characterIndex + excerptHalfLengthPlus) + (_ourErrorObject.characterIndex + excerptHalfLengthPlus < errorLineText.length ? '…' : '');
      // NOTE: Not 100% sure that it's more helpful to the user if we do this next line ???
      _ourErrorObject.details = _ourErrorObject.details.substring(totalLink.length); // Delete the line and column numbers that we found
    } catch (secondError) {
      (0, _utilities.debugLog)("USFMGrammar second error: ".concat(secondError));
    }
    return { isValidUSFM: false, error: _ourErrorObject, warnings: [] };
  }
  var parserMessages;
  parserMessages = parserToJSONResultObject._messages; // Throw away the JSON (if any)
  // debugLog(`  Finished BCS USFM grammar check with messages: ${JSON.stringify(parserResult)}\n and warnings: ${JSON.stringify(ourUsfmParser.warnings)}.`);

  // TODO: I think most of the following code is now obsolete and can be deleted
  var parseError;
  parseError = parserMessages._error;
  var ourErrorMessage, lineNumberString, characterIndex, excerpt;
  // NOTE: The following code is quite fragile
  //  as it depends on the precise format of the error message returned from USFMParser
  var ourErrorObject = {};
  if (parseError) {
    (0, _utilities.debugLog)("Oh! This USFMGrammer check code IS still needed!!!");
    var contextRE = /(\d+?)\s\|\s(.+)/g;var _iterator = _createForOfIteratorHelper(
    parseError.split('\n')),_step;try {for (_iterator.s(); !(_step = _iterator.n()).done;) {var errorLine = _step.value;
        // debugLog(`BCS errorLine=${errorLine}`);
        if (errorLine.startsWith('>')) {
          var regexResult = contextRE.exec(errorLine.substring(1).trim());
          // debugLog(`  regexResult: ${JSON.stringify(regexResult)}`);
          if (regexResult) {
            lineNumberString = regexResult[1];
            excerpt = regexResult[2];
          }
        } else
        if (errorLine.endsWith('^')) {
          characterIndex = errorLine.indexOf('^') - 8;
          if (characterIndex < 0) characterIndex = 0; // Just in case
          if (excerpt.length)
          excerpt = (characterIndex > excerptHalfLength ? '…' : '') + excerpt.substring(characterIndex - excerptHalfLength, characterIndex + excerptHalfLengthPlus) + (characterIndex + excerptHalfLengthPlus < excerpt.length ? '…' : '');
        } else
        ourErrorMessage = errorLine; // We only want the last one
      }
      // debugLog(`  ourErrorMessage: '${ourErrorMessage}' lineNumberString=${lineNumberString} characterIndex=${characterIndex} excerpt='${excerpt}'`);

      // Some of these "errors" need to be degraded in priority
    } catch (err) {_iterator.e(err);} finally {_iterator.f();}
    var adjustedPriority = 594; // We don’t make these extra high coz the messages are hard for users to interpret
    if (excerpt === '\\s5' // Temporarily, even though \s5 fields are not valid USFM
    || ourErrorMessage.startsWith('Expected "f*", "+"') // Might neeed a OHM schema fix?
    )
      adjustedPriority = 294;

    ourErrorObject = {
      priority: adjustedPriority, message: "USFMGrammar: ".concat(ourErrorMessage),
      filename: filename,
      characterIndex: characterIndex, excerpt: excerpt,
      location: givenLocation };


    // Save our line number
    if (lineNumberString && lineNumberString.length) {
      // ourErrorObject.lineNumber = Number(lineNumberString);
      //  but we need a temporary fix for the BCS bug which doesn’t include blank lines in the count
      var lineNumber = Number(lineNumberString);
      var notified = false;
      var lines = fileText.split('\n');
      for (var n = 1; n <= lines.length; n++) {
        if (n >= lineNumber) break; // Gone far enough
        if (!lines[n - 1]) {
          lineNumber += 1; // Increment error line number for each blank line
          if (!notified) {
            (0, _utilities.userLog)("Temporarily adjusting BCS grammar error line number to account for blank lines");
            notified = true;
          }
        }
      }
      ourErrorObject.lineNumber = lineNumber;
    }
  }

  // debugLog(`  Warnings: ${JSON.stringify(parseWarnings)}`);
  var ourWarnings = [];var _iterator2 = _createForOfIteratorHelper(
  parseWarnings),_step2;try {for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {var warningString = _step2.value;
      // debugLog(`warningString: '${warningString}'`);
      // Clean up their warnings a little: Remove trailing spaces and periods
      var adjustedString = warningString.trim(); // Removes the trailing space
      if (adjustedString.endsWith('.')) adjustedString = adjustedString.substring(0, adjustedString.length - 1);
      ourWarnings.push(adjustedString);
    }} catch (err) {_iterator2.e(err);} finally {_iterator2.f();}

  return { isValidUSFM: !parseError, error: ourErrorObject, warnings: ourWarnings };
}
// end of runBCSGrammarCheck function


function checkUSFMGrammar(bookID, strictnessString, filename, givenText, givenLocation, checkingOptions) {
  /*
  This function is only used for the demonstration pages -- not for the core!
   bookID is a three-character UPPERCASE USFM book identifier.
   filename parameter can be an empty string if we don’t have one.
    Returns a result object containing a successList and a noticeList
   */



  (0, _utilities.functionLog)("checkUSFMGrammar(".concat(givenText.length.toLocaleString(), " chars, '").concat(givenLocation, "')\u2026"));
  //parameterAssert(strictnessString === 'strict' || strictnessString === 'relaxed', `Unexpected strictnessString='${strictnessString}'`);

  var ourLocation = givenLocation;
  if (ourLocation && ourLocation[0] !== ' ') ourLocation = " ".concat(ourLocation);


  var cugResult = { successList: [], noticeList: [] };

  /**
   *
   * @param {string} successString
   */
  function addSuccessMessage(successString) {
    // functionLog(`checkUSFMGrammar success: ${successString}`);
    cugResult.successList.push(successString);
  }
  /**
   *
   * @description - adds a new notice entry from the partial fields given -- adding bookID and filename to the given fields
   * @param {Object} noticeObject expected to contain priority, message, characterIndex, exerpt, location
   */
  function addNoticePartial(noticeObject) {
    // functionLog(`checkUSFMGrammar notice: (priority=${priority}) ${message}${characterIndex > 0 ? ` (at character ${characterIndex})` : ""}${excerpt ? ` ${excerpt}` : ""}${location}`);
    //parameterAssert(noticeObject.priority !== undefined, "cUSFMgr addNoticePartial: 'priority' parameter should be defined");
    //parameterAssert(typeof noticeObject.priority === 'number', `cUSFMgr addNoticePartial: 'priority' parameter should be a number not a '${typeof noticeObject.priority}': ${noticeObject.priority}`);
    //parameterAssert(noticeObject.message !== undefined, "cUSFMgr addNoticePartial: 'message' parameter should be defined");
    //parameterAssert(typeof noticeObject.message === 'string', `cUSFMgr addNoticePartial: 'message' parameter should be a string not a '${typeof noticeObject.message}': ${noticeObject.message}`);
    // //parameterAssert(characterIndex !== undefined, "cUSFMgr addNoticePartial: 'characterIndex' parameter should be defined");
    if (noticeObject.characterIndex) {//parameterAssert(typeof noticeObject.characterIndex === 'number', `cUSFMgr addNoticePartial: 'characterIndex' parameter should be a number not a '${typeof noticeObject.characterIndex}': ${noticeObject.characterIndex}`);
    }
    // //parameterAssert(excerpt !== undefined, "cUSFMgr addNoticePartial: 'excerpt' parameter should be defined");
    if (noticeObject.excerpt) {//parameterAssert(typeof noticeObject.excerpt === 'string', `cUSFMgr addNoticePartial: 'excerpt' parameter should be a string not a '${typeof excerpt}': ${noticeObject.excerpt}`);
    }
    //parameterAssert(noticeObject.location !== undefined, "cUSFMgr addNoticePartial: 'location' parameter should be defined");
    //parameterAssert(typeof noticeObject.location === 'string', `cUSFMgr addNoticePartial: 'location' parameter should be a string not a '${typeof noticeObject.location}': ${noticeObject.location}`);
    cugResult.noticeList.push(_objectSpread(_objectSpread({}, noticeObject), {}, { bookID: bookID, filename: filename }));
  }


  // Main code for checkUSFMGrammar function
  if (books.isExtraBookID(bookID)) // doesn’t work for these
    return cugResult;

  var grammarCheckResult = runBCSGrammarCheck(strictnessString, bookID, givenText, filename, ourLocation, checkingOptions);
  // debugLog(`grammarCheckResult=${JSON.stringify(grammarCheckResult)}`);

  if (!grammarCheckResult.isValidUSFM)
  addNoticePartial({ priority: 944, message: "USFM3 Grammar Check (".concat(strictnessString, " mode) doesn\u2019t pass"), filename: filename, location: ourLocation });

  // We only get one error if it fails
  if (grammarCheckResult.error && grammarCheckResult.priority)
  addNoticePartial(grammarCheckResult.error);

  // Display these warnings but with a lowish priority
  var _iterator3 = _createForOfIteratorHelper(grammarCheckResult.warnings),_step3;try {for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {var warningString = _step3.value;
      addNoticePartial({ priority: 101, message: "USFMGrammar: ".concat(warningString), filename: filename, location: ourLocation });}} catch (err) {_iterator3.e(err);} finally {_iterator3.f();}

  addSuccessMessage("Checked USFM Grammar (".concat(strictnessString, " mode) ").concat(grammarCheckResult.isValidUSFM ? "without errors" : " (but the USFM DIDN’T validate)"));
  // debugLog(`  checkUSFMGrammar returning with ${result.successList.length.toLocaleString()} success(es) and ${result.noticeList.length.toLocaleString()} notice(s).`);
  // functionLog(`checkUSFMGrammar result is ${JSON.stringify(result)}`);
  return cugResult;
}
// end of checkUSFMGrammar function
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9jb3JlL0JDUy11c2ZtLWdyYW1tYXItY2hlY2suanMiXSwibmFtZXMiOlsiTElORV9DT0xVTU5fTlVNQkVSU19SRUdFWCIsIlJlZ0V4cCIsInJ1bkJDU0dyYW1tYXJDaGVjayIsInN0cmljdG5lc3NTdHJpbmciLCJib29rSUQiLCJmaWxlVGV4dCIsImZpbGVuYW1lIiwiZ2l2ZW5Mb2NhdGlvbiIsImNoZWNraW5nT3B0aW9ucyIsImV4Y2VycHRMZW5ndGgiLCJ1c2ZtRUxlcnJvciIsImlzTmFOIiwiREVGQVVMVF9FWENFUlBUX0xFTkdUSCIsImV4Y2VycHRIYWxmTGVuZ3RoIiwiTWF0aCIsImZsb29yIiwiZXhjZXJwdEhhbGZMZW5ndGhQbHVzIiwicGFyc2VyVG9KU09OUmVzdWx0T2JqZWN0IiwicGFyc2VXYXJuaW5ncyIsIm91clVzZm1QYXJzZXIiLCJncmFtbWFyIiwiVVNGTVBhcnNlciIsIkxFVkVMIiwiUkVMQVhFRCIsInRvSlNPTiIsIl93YXJuaW5ncyIsIndhcm5pbmdzIiwicGFyc2VyRXJyb3IiLCJvdXJFcnJvck9iamVjdCIsInByaW9yaXR5IiwibWVzc2FnZSIsImRldGFpbHMiLCJsb2NhdGlvbiIsInJlZ2V4UmVzdWx0QXJyYXkiLCJleGVjIiwidG90YWxMaW5rIiwibGluZU51bWJlclN0cmluZyIsImNvbHVtbk51bWJlclN0cmluZyIsImxpbmVOdW1iZXIiLCJjaGFyYWN0ZXJJbmRleCIsImVycm9yTGluZVRleHQiLCJzcGxpdCIsImV4Y2VycHQiLCJzdWJzdHJpbmciLCJsZW5ndGgiLCJzZWNvbmRFcnJvciIsImlzVmFsaWRVU0ZNIiwiZXJyb3IiLCJwYXJzZXJNZXNzYWdlcyIsIl9tZXNzYWdlcyIsInBhcnNlRXJyb3IiLCJfZXJyb3IiLCJvdXJFcnJvck1lc3NhZ2UiLCJjb250ZXh0UkUiLCJlcnJvckxpbmUiLCJzdGFydHNXaXRoIiwicmVnZXhSZXN1bHQiLCJ0cmltIiwiZW5kc1dpdGgiLCJpbmRleE9mIiwiYWRqdXN0ZWRQcmlvcml0eSIsIk51bWJlciIsIm5vdGlmaWVkIiwibGluZXMiLCJuIiwib3VyV2FybmluZ3MiLCJ3YXJuaW5nU3RyaW5nIiwiYWRqdXN0ZWRTdHJpbmciLCJwdXNoIiwiY2hlY2tVU0ZNR3JhbW1hciIsImdpdmVuVGV4dCIsInRvTG9jYWxlU3RyaW5nIiwib3VyTG9jYXRpb24iLCJjdWdSZXN1bHQiLCJzdWNjZXNzTGlzdCIsIm5vdGljZUxpc3QiLCJhZGRTdWNjZXNzTWVzc2FnZSIsInN1Y2Nlc3NTdHJpbmciLCJhZGROb3RpY2VQYXJ0aWFsIiwibm90aWNlT2JqZWN0IiwiYm9va3MiLCJpc0V4dHJhQm9va0lEIiwiZ3JhbW1hckNoZWNrUmVzdWx0Il0sIm1hcHBpbmdzIjoiaWZBQUE7QUFDQTtBQUNBOztBQUVBLHdDOzs7QUFHQTs7QUFFQSxJQUFNQSx5QkFBeUIsR0FBRyxJQUFJQyxNQUFKLENBQVcsa0NBQVgsQ0FBbEMsQyxDQUFrRjs7O0FBR2xGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sU0FBU0Msa0JBQVQsQ0FBNEJDLGdCQUE1QixFQUE4Q0MsTUFBOUMsRUFBc0RDLFFBQXRELEVBQWdFQyxRQUFoRSxFQUEwRUMsYUFBMUUsRUFBeUZDLGVBQXpGLEVBQTBHO0FBQzdHO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE1BQUlDLGFBQUo7QUFDQSxNQUFJO0FBQ0FBLElBQUFBLGFBQWEsR0FBR0QsZUFBSCxhQUFHQSxlQUFILHVCQUFHQSxlQUFlLENBQUVDLGFBQWpDO0FBQ0gsR0FGRCxDQUVFLE9BQU9DLFdBQVAsRUFBb0IsQ0FBRztBQUN6QixNQUFJLE9BQU9ELGFBQVAsS0FBeUIsUUFBekIsSUFBcUNFLEtBQUssQ0FBQ0YsYUFBRCxDQUE5QyxFQUErRDtBQUMzREEsSUFBQUEsYUFBYSxHQUFHRyxnQ0FBaEI7QUFDQTtBQUNIO0FBQ0Q7QUFDQTtBQUNBLE1BQU1DLGlCQUFpQixHQUFHQyxJQUFJLENBQUNDLEtBQUwsQ0FBV04sYUFBYSxHQUFHLENB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QUFFSjtBQUNBLE1BQUlVLGtCQUFrQixDQUFDbkMsS0FBbkIsSUFBNEJtQyxrQkFBa0IsQ0FBQ3JELFFBQW5EO0FBQ0lpRCxFQUFBQSxnQkFBZ0IsQ0FBQ0ksa0JBQWtCLENBQUNuQyxLQUFwQixDQUFoQjs7QUFFSjtBQWhFNEcsOENBaUVoRm1DLGtCQUFrQixDQUFDeEQsUUFqRTZELGNBaUU1Ryw0REFBV3dDLGFBQVg7QUFDSVksTUFBQUEsZ0JBQWdCLENBQUMsRUFBRWpELFFBQVEsRUFBRSxHQUFaLEVBQWlCQyxPQUFPLHlCQUFrQm9DLGFBQWxCLENBQXhCLEVBQTJENUQsUUFBUSxFQUFSQSxRQUEzRCxFQUFxRTBCLFFBQVEsRUFBRXdDLFdBQS9FLEVBQUQsQ0FBaEIsQ0FESixDQWpFNEc7O0FBb0U1R0ksRUFBQUEsaUJBQWlCLGlDQUEwQnpFLGdCQUExQixvQkFBb0QrRSxrQkFBa0IsQ0FBQ3BDLFdBQW5CLEdBQWlDLGdCQUFqQyxHQUFvRCxpQ0FBeEcsRUFBakI7QUFDQTtBQUNBO0FBQ0EsU0FBTzJCLFNBQVA7QUFDSDtBQUNEIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGdyYW1tYXIgZnJvbSAndXNmbS1ncmFtbWFyJztcbmltcG9ydCAqIGFzIGJvb2tzIGZyb20gJy4uL2NvcmUvYm9va3MvYm9va3MnO1xuaW1wb3J0IHsgREVGQVVMVF9FWENFUlBUX0xFTkdUSCB9IGZyb20gJy4vZGVmYXVsdHMnXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLXZhcnNcbmltcG9ydCB7IHVzZXJMb2csIGRlYnVnTG9nLCBmdW5jdGlvbkxvZywgcGFyYW1ldGVyQXNzZXJ0LCBvdXJQYXJzZUludCB9IGZyb20gJy4vdXRpbGl0aWVzJztcblxuXG4vLyBjb25zdCBVU0ZNX0dSQU1NQVJfVkFMSURBVE9SX1ZFUlNJT05fU1RSSU5HID0gJzAuNC41JztcblxuY29uc3QgTElORV9DT0xVTU5fTlVNQkVSU19SRUdFWCA9IG5ldyBSZWdFeHAoJ0xpbmUgKFxcXFxkezEsNn0pLCBjb2wgKFxcXFxkezEsNH0pOicpOyAvLyBlLmcuLCBcIkxpbmUgMTUzOCwgY29sIDQ6IDE1MzcgLi4uXCJcblxuXG4vKipcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaWN0bmVzc1N0cmluZyAtLSAnc3RyaWN0JyBvciAncmVsYXhlZCdcbiAqIEBwYXJhbSB7c3RyaW5nfSBib29rSUQgLS0gMy1jaGFyYWN0ZXIgYm9vayBJRFxuICogQHBhcmFtIHtzdHJpbmd9IGZpbGVUZXh0IC0tIHRoZSBhY3R1YWwgVVNGTSB0ZXh0XG4gKiBAcGFyYW0ge3N0cmluZ30gZmlsZW5hbWUgLS0gZm9yIGVycm9yIG1lc3NhZ2VzXG4gKiBAcGFyYW0ge3N0cmluZ30gZ2l2ZW5Mb2NhdGlvbiAtLSBmb3IgZXJyb3IgbWVzc2FnZXNcbiAqIEBwYXJhbSB7T2JqZWN0fSBjaGVja2luZ09wdGlvbnMgLS0gb3B0aW9uYWwgb3B0aW9uc1xuICogQHJldHVybnMge09iamVjdH0gaW5jbHVkaW5nIGlzVmFsaWRVU0ZNIGZsYWdcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJ1bkJDU0dyYW1tYXJDaGVjayhzdHJpY3RuZXNzU3RyaW5nLCBib29rSUQsIGZpbGVUZXh0LCBmaWxlbmFtZSwgZ2l2ZW5Mb2NhdGlvbiwgY2hlY2tpbmdPcHRpb25zKSB7XG4gICAgLy8gUnVucyB0aGUgQkNTIFVTRk0gR3JhbW1hciBjaGVja2VyXG4gICAgLy8gIHdoaWNoIGNhbiBiZSBxdWl0ZSB0aW1lLWNvbnN1bWluZyBvbiBsYXJnZSwgY29tcGxleCBVU0ZNIGZpbGVzXG4gICAgLy8gdXNlckxvZyhgUnVubmluZyAke3N0cmljdG5lc3NTdHJpbmd9IEJDUyBVU0ZNIGdyYW1tYXIgY2hlY2ske2dpdmVuTG9jYXRpb259IChjYW4gdGFrZSBxdWl0ZSBhIHdoaWxlIGZvciBhIGxhcmdlIGJvb2sp4oCmYCk7XG4gICAgLy9wYXJhbWV0ZXJBc3NlcnQoc3RyaWN0bmVzc1N0cmluZyA9PT0gJ3N0cmljdCcgfHwgc3RyaWN0bmVzc1N0cmluZyA9PT0gJ3JlbGF4ZWQnLCBgVW5leHBlY3RlZCBzdHJpY3RuZXNzU3RyaW5nPScke3N0cmljdG5lc3NTdHJpbmd9J2ApO1xuXG4gICAgbGV0IGV4Y2VycHRMZW5ndGg7XG4gICAgdHJ5IHtcbiAgICAgICAgZXhjZXJwdExlbmd0aCA9IGNoZWNraW5nT3B0aW9ucz8uZXhjZXJwdExlbmd0aDtcbiAgICB9IGNhdGNoICh1c2ZtRUxlcnJvcikgeyB9XG4gICAgaWYgKHR5cGVvZiBleGNlcnB0TGVuZ3RoICE9PSAnbnVtYmVyJyB8fCBpc05hTihleGNlcnB0TGVuZ3RoKSkge1xuICAgICAgICBleGNlcnB0TGVuZ3RoID0gREVGQVVMVF9FWENFUlBUX0xFTkdUSDtcbiAgICAgICAgLy8gZGVidWdMb2coYFVzaW5nIGRlZmF1bHQgZXhjZXJwdExlbmd0aD0ke2V4Y2VycHRMZW5ndGh9YCk7XG4gICAgfVxuICAgIC8vIGVsc2VcbiAgICAvLyBkZWJ1Z0xvZyhgVXNpbmcgc3VwcGxpZWQgZXhjZXJwdExlbmd0aD0ke2V4Y2VycHRMZW5ndGh9IGNmLiBkZWZhdWx0PSR7REVGQVVMVF9FWENFUlBUX0xFTkdUSH1gKTtcbiAgICBjb25zdCBleGNlcnB0SGFsZkxlbmd0aCA9IE1hdGguZmxvb3IoZXhjZXJwdExlbmd0aCAvIDIpOyAvLyByb3VuZGVkIGRvd25cbiAgICBjb25zdCBleGNlcnB0SGFsZkxlbmd0aFBsdXMgPSBNYXRoLmZsb29yKChleGNlcnB0TGVuZ3RoICsgMSkgLyAyKTsgLy8gcm91bmRlZCB1cFxuICAgIC8vIGRlYnVnTG9nKGBVc2luZyBleGNlcnB0SGFsZkxlbmd0aD0ke2V4Y2VycHRIYWxmTGVuZ3RofWAsIGBleGNlcnB0SGFsZkxlbmd0aFBsdXM9JHtleGNlcnB0SGFsZkxlbmd0aFBsdXN9YCk7XG5cbiAgICAvLyBOb3cgY3JlYXRlIHRoZSBwYXJzZXIgYW5kIHJ1biB0aGUgY2hlY2tcbiAgICBsZXQgcGFyc2VyVG9KU09OUmVzdWx0T2JqZWN0LCBwYXJzZVdhcm5pbmdzO1xuICAgIHRyeSB7XG4gICAgICAgIC8vIGRlYnVnTG9nKGAke25ldyBEYXRlKCkuZ2V0VGltZSgpIC8gMTAwMH0gU2V0dGluZy11cCB0aGUgVVNGTUdyYW1tYXIgY2hlY2tlcuKApmApO1xuICAgICAgICBjb25zdCBvdXJVc2ZtUGFyc2VyID0gbmV3IGdyYW1tYXIuVVNGTVBhcnNlcihmaWxlVGV4dCwgc3RyaWN0bmVzc1N0cmluZyA9PT0gJ3JlbGF4ZWQnID8gZ3JhbW1hci5MRVZFTC5SRUxBWEVEIDogbnVsbCk7XG4gICAgICAgIC8vIFJldHVybnMgYSBCb29sZWFuIGluZGljYXRpbmcgd2hldGhlciB0aGUgaW5wdXQgVVNGTSB0ZXh0IHNhdGlzZmllcyB0aGUgZ3JhbW1hciBvciBub3QuXG4gICAgICAgIC8vIFRoaXMgbWV0aG9kIGlzIGF2YWlsYWJsZSBpbiBib3RoIGRlZmF1bHQgYW5kIHJlbGF4ZWQgbW9kZXMuXG4gICAgICAgIC8vIGNvbnN0IHBhcnNlclJlc3VsdCA9IG91clVzZm1QYXJzZXIudmFsaWRhdGUoKTtcbiAgICAgICAgLy8gZGVidWdMb2coYCR7bmV3IERhdGUoKS5nZXRUaW1lKCkgLyAxMDAwfSBSdW5uaW5nIHRoZSBCQ1MgVVNGTUdyYW1tYXIgY2hlY2tlciAobWF5IHRha2Ugc2V2ZXJhbCBzZWNvbmRzKeKApmApO1xuICAgICAgICAvLyB1c2VyTG9nKGBSdW5uaW5nIHRoZSBCQ1MgVVNGTUdyYW1tYXIgY2hlY2tlciBmb3IgJHtib29rSUR9IChtYXkgdGFrZSBzZXZlcmFsIHNlY29uZHMp4oCmYCk7XG4gICAgICAgIHBhcnNlclRvSlNPTlJlc3VsdE9iamVjdCA9IG91clVzZm1QYXJzZXIudG9KU09OKCk7XG4gICAgICAgIC8vIGRlYnVnTG9nKGAke25ldyBEYXRlKCkuZ2V0VGltZSgpIC8gMTAwMH0gR290IHRoZSBCQ1MgVVNGTUdyYW1tYXIgY2hlY2tlciB0b0pTT04gcmVzdWx0OiAke09iamVjdC5rZXlzKHBhcnNlclRvSlNPTlJlc3VsdE9iamVjdCl9YCk7XG4gICAgICAgIC8vIGRlYnVnTG9nKGAke25ldyBEYXRlKCkuZ2V0VGltZSgpIC8gMTAwMH0gR290IHRoZSBCQ1MgVVNGTUdyYW1tYXIgY2hlY2tlciB0b0pTT04gX21lc3NhZ2VzOiAke09iamVjdC5rZXlzKHBhcnNlclRvSlNPTlJlc3VsdE9iamVjdC5fbWVzc2FnZXMpfWApO1xuICAgICAgICAvLyBkZWJ1Z0xvZyhgJHtuZXcgRGF0ZSgpLmdldFRpbWUoKSAvIDEwMDB9IEdvdCB0aGUgQkNTIFVTRk1HcmFtbWFyIGNoZWNrZXI6ICR7T2JqZWN0LmtleXMob3VyVXNmbVBhcnNlcil9YCk7XG4gICAgICAgIHBhcnNlV2FybmluZ3MgPSBwYXJzZXJUb0pTT05SZXN1bHRPYmplY3QuX3dhcm5pbmdzID8gcGFyc2VyVG9KU09OUmVzdWx0T2JqZWN0Ll93YXJuaW5ncyA6IG91clVzZm1QYXJzZXIud2FybmluZ3M7XG4gICAgICAgIC8vIGRlYnVnTG9nKGAke25ldyBEYXRlKCkuZ2V0VGltZSgpIC8gMTAwMH0gR290IHdhcm5pbmdzIGZyb20gdGhlIEJDUyBVU0ZNR3JhbW1hciBjaGVja2VyOiAoJHtwYXJzZVdhcm5pbmdzLmxlbmd0aH0pICR7cGFyc2VXYXJuaW5nc31gKTtcbiAgICB9IGNhdGNoIChwYXJzZXJFcnJvcikgeyAvLyBUaGlzIGlzIGhvdyB0aGUgUGFyc2VyIHJldHVybnMgVVNGTSBlcnJvcnMsIGkuZS4sIGl0IHN0b3BzIGFmdGVyIHRoZSBmaXJzdCBlcnJvclxuICAgICAgICAvLyBkZWJ1Z0xvZyhgJHtuZXcgRGF0ZSgpLmdldFRpbWUoKSAvIDEwMDB9IEdvdCBhbiBleGNlcHRpb24gd2hlbiB1c2luZyB0aGUgQkNTIFVTRk1HcmFtbWFyIGNoZWNrZXI6ICR7cGFyc2VyRXJyb3J9YCk7XG4gICAgICAgIGNvbnN0IG91ckVycm9yT2JqZWN0ID0ge1xuICAgICAgICAgICAgcHJpb3JpdHk6IDg0MCwgbWVzc2FnZTogXCJVU0ZNR3JhbW1hciBjaGVjayBmYWlsZWRcIixcbiAgICAgICAgICAgIGRldGFpbHM6IHBhcnNlckVycm9yLFxuICAgICAgICAgICAgZmlsZW5hbWUsXG4gICAgICAgICAgICBsb2NhdGlvbjogZ2l2ZW5Mb2NhdGlvblxuICAgICAgICB9O1xuICAgICAgICB0cnkgeyAvLyBTZWUgaWYgd2UgY2FuIGltcHJvdmUgdGhlIHJlc3VsdCB3aXRoIGxpbmUgYW5kIGNvbHVtbiBudW1iZXJzXG4gICAgICAgICAgICAvLyBOT1RFOiBUaGUgZm9sbG93aW5nIGNvZGUgaXMgcXVpdGUgZnJhZ2lsZVxuICAgICAgICAgICAgLy8gIGFzIGl0IGRlcGVuZHMgb24gdGhlIHByZWNpc2UgZm9ybWF0IG9mIHRoZSBlcnJvciBtZXNzYWdlIHJldHVybmVkIGZyb20gVVNGTVBhcnNlclxuICAgICAgICAgICAgY29uc3QgcmVnZXhSZXN1bHRBcnJheSA9IExJTkVfQ09MVU1OX05VTUJFUlNfUkVHRVguZXhlYyhwYXJzZXJFcnJvcik7XG4gICAgICAgICAgICBjb25zdCBbdG90YWxMaW5rLCBsaW5lTnVtYmVyU3RyaW5nLCBjb2x1bW5OdW1iZXJTdHJpbmddID0gcmVnZXhSZXN1bHRBcnJheTtcbiAgICAgICAgICAgIG91ckVycm9yT2JqZWN0LmxpbmVOdW1iZXIgPSBvdXJQYXJzZUludChsaW5lTnVtYmVyU3RyaW5nKTtcbiAgICAgICAgICAgIG91ckVycm9yT2JqZWN0LmNoYXJhY3RlckluZGV4ID0gb3VyUGFyc2VJbnQoY29sdW1uTnVtYmVyU3RyaW5nKSAtIDE7XG4gICAgICAgICAgICBjb25zdCBlcnJvckxpbmVUZXh0ID0gZmlsZVRleHQuc3BsaXQoJ1xcbicpW291ckVycm9yT2JqZWN0LmxpbmVOdW1iZXIgLSAxXTtcbiAgICAgICAgICAgIG91ckVycm9yT2JqZWN0LmV4Y2VycHQgPSAob3VyRXJyb3JPYmplY3QuY2hhcmFjdGVySW5kZXggPiBleGNlcnB0SGFsZkxlbmd0aCA/ICfigKYnIDogJycpICsgZXJyb3JMaW5lVGV4dC5zdWJzdHJpbmcob3VyRXJyb3JPYmplY3QuY2hhcmFjdGVySW5kZXggLSBleGNlcnB0SGFsZkxlbmd0aCwgb3VyRXJyb3JPYmplY3QuY2hhcmFjdGVySW5kZXggKyBleGNlcnB0SGFsZkxlbmd0aFBsdXMpICsgKG91ckVycm9yT2JqZWN0LmNoYXJhY3RlckluZGV4ICsgZXhjZXJwdEhhbGZMZW5ndGhQbHVzIDwgZXJyb3JMaW5lVGV4dC5sZW5ndGggPyAn4oCmJyA6ICcnKTtcbiAgICAgICAgICAgIC8vIE5PVEU6IE5vdCAxMDAlIHN1cmUgdGhhdCBpdCdzIG1vcmUgaGVscGZ1bCB0byB0aGUgdXNlciBpZiB3ZSBkbyB0aGlzIG5leHQgbGluZSA/Pz9cbiAgICAgICAgICAgIG91ckVycm9yT2JqZWN0LmRldGFpbHMgPSBvdXJFcnJvck9iamVjdC5kZXRhaWxzLnN1YnN0cmluZyh0b3RhbExpbmsubGVuZ3RoKTsgLy8gRGVsZXRlIHRoZSBsaW5lIGFuZCBjb2x1bW4gbnVtYmVycyB0aGF0IHdlIGZvdW5kXG4gICAgICAgIH0gY2F0Y2ggKHNlY29uZEVycm9yKSB7XG4gICAgICAgICAgICBkZWJ1Z0xvZyhgVVNGTUdyYW1tYXIgc2Vjb25kIGVycm9yOiAke3NlY29uZEVycm9yfWApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IGlzVmFsaWRVU0ZNOiBmYWxzZSwgZXJyb3I6IG91ckVycm9yT2JqZWN0LCB3YXJuaW5nczogW10gfTtcbiAgICB9XG4gICAgbGV0IHBhcnNlck1lc3NhZ2VzO1xuICAgIHBhcnNlck1lc3NhZ2VzID0gcGFyc2VyVG9KU09OUmVzdWx0T2JqZWN0Ll9tZXNzYWdlczsgLy8gVGhyb3cgYXdheSB0aGUgSlNPTiAoaWYgYW55KVxuICAgIC8vIGRlYnVnTG9nKGAgIEZpbmlzaGVkIEJDUyBVU0ZNIGdyYW1tYXIgY2hlY2sgd2l0aCBtZXNzYWdlczogJHtKU09OLnN0cmluZ2lmeShwYXJzZXJSZXN1bHQpfVxcbiBhbmQgd2FybmluZ3M6ICR7SlNPTi5zdHJpbmdpZnkob3VyVXNmbVBhcnNlci53YXJuaW5ncyl9LmApO1xuXG4gICAgLy8gVE9ETzogSSB0aGluayBtb3N0IG9mIHRoZSBmb2xsb3dpbmcgY29kZSBpcyBub3cgb2Jzb2xldGUgYW5kIGNhbiBiZSBkZWxldGVkXG4gICAgbGV0IHBhcnNlRXJyb3I7XG4gICAgcGFyc2VFcnJvciA9IHBhcnNlck1lc3NhZ2VzLl9lcnJvcjtcbiAgICBsZXQgb3VyRXJyb3JNZXNzYWdlLCBsaW5lTnVtYmVyU3RyaW5nLCBjaGFyYWN0ZXJJbmRleCwgZXhjZXJwdDtcbiAgICAvLyBOT1RFOiBUaGUgZm9sbG93aW5nIGNvZGUgaXMgcXVpdGUgZnJhZ2lsZVxuICAgIC8vICBhcyBpdCBkZXBlbmRzIG9uIHRoZSBwcmVjaXNlIGZvcm1hdCBvZiB0aGUgZXJyb3IgbWVzc2FnZSByZXR1cm5lZCBmcm9tIFVTRk1QYXJzZXJcbiAgICBsZXQgb3VyRXJyb3JPYmplY3QgPSB7fTtcbiAgICBpZiAocGFyc2VFcnJvcikge1xuICAgICAgICBkZWJ1Z0xvZyhcIk9oISBUaGlzIFVTRk1HcmFtbWVyIGNoZWNrIGNvZGUgSVMgc3RpbGwgbmVlZGVkISEhXCIpO1xuICAgICAgICBjb25zdCBjb250ZXh0UkUgPSAvKFxcZCs/KVxcc1xcfFxccyguKykvZztcbiAgICAgICAgZm9yIChjb25zdCBlcnJvckxpbmUgb2YgcGFyc2VFcnJvci5zcGxpdCgnXFxuJykpIHtcbiAgICAgICAgICAgIC8vIGRlYnVnTG9nKGBCQ1MgZXJyb3JMaW5lPSR7ZXJyb3JMaW5lfWApO1xuICAgICAgICAgICAgaWYgKGVycm9yTGluZS5zdGFydHNXaXRoKCc+JykpIHtcbiAgICAgICAgICAgICAgICBjb25zdCByZWdleFJlc3VsdCA9IGNvbnRleHRSRS5leGVjKGVycm9yTGluZS5zdWJzdHJpbmcoMSkudHJpbSgpKTtcbiAgICAgICAgICAgICAgICAvLyBkZWJ1Z0xvZyhgICByZWdleFJlc3VsdDogJHtKU09OLnN0cmluZ2lmeShyZWdleFJlc3VsdCl9YCk7XG4gICAgICAgICAgICAgICAgaWYgKHJlZ2V4UmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgIGxpbmVOdW1iZXJTdHJpbmcgPSByZWdleFJlc3VsdFsxXTtcbiAgICAgICAgICAgICAgICAgICAgZXhjZXJwdCA9IHJlZ2V4UmVzdWx0WzJdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGVycm9yTGluZS5lbmRzV2l0aCgnXicpKSB7XG4gICAgICAgICAgICAgICAgY2hhcmFjdGVySW5kZXggPSBlcnJvckxpbmUuaW5kZXhPZignXicpIC0gODtcbiAgICAgICAgICAgICAgICBpZiAoY2hhcmFjdGVySW5kZXggPCAwKSBjaGFyYWN0ZXJJbmRleCA9IDA7IC8vIEp1c3QgaW4gY2FzZVxuICAgICAgICAgICAgICAgIGlmIChleGNlcnB0Lmxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgZXhjZXJwdCA9IChjaGFyYWN0ZXJJbmRleCA+IGV4Y2VycHRIYWxmTGVuZ3RoID8gJ+KApicgOiAnJykgKyBleGNlcnB0LnN1YnN0cmluZyhjaGFyYWN0ZXJJbmRleCAtIGV4Y2VycHRIYWxmTGVuZ3RoLCBjaGFyYWN0ZXJJbmRleCArIGV4Y2VycHRIYWxmTGVuZ3RoUGx1cykgKyAoY2hhcmFjdGVySW5kZXggKyBleGNlcnB0SGFsZkxlbmd0aFBsdXMgPCBleGNlcnB0Lmxlbmd0aCA/ICfigKYnIDogJycpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIG91ckVycm9yTWVzc2FnZSA9IGVycm9yTGluZTsgLy8gV2Ugb25seSB3YW50IHRoZSBsYXN0IG9uZVxuICAgICAgICB9XG4gICAgICAgIC8vIGRlYnVnTG9nKGAgIG91ckVycm9yTWVzc2FnZTogJyR7b3VyRXJyb3JNZXNzYWdlfScgbGluZU51bWJlclN0cmluZz0ke2xpbmVOdW1iZXJTdHJpbmd9IGNoYXJhY3RlckluZGV4PSR7Y2hhcmFjdGVySW5kZXh9IGV4Y2VycHQ9JyR7ZXhjZXJwdH0nYCk7XG5cbiAgICAgICAgLy8gU29tZSBvZiB0aGVzZSBcImVycm9yc1wiIG5lZWQgdG8gYmUgZGVncmFkZWQgaW4gcHJpb3JpdHlcblxuICAgICAgICBsZXQgYWRqdXN0ZWRQcmlvcml0eSA9IDU5NDsgLy8gV2UgZG9u4oCZdCBtYWtlIHRoZXNlIGV4dHJhIGhpZ2ggY296IHRoZSBtZXNzYWdlcyBhcmUgaGFyZCBmb3IgdXNlcnMgdG8gaW50ZXJwcmV0XG4gICAgICAgIGlmIChleGNlcnB0ID09PSAnXFxcXHM1JyAvLyBUZW1wb3JhcmlseSwgZXZlbiB0aG91Z2ggXFxzNSBmaWVsZHMgYXJlIG5vdCB2YWxpZCBVU0ZNXG4gICAgICAgICAgICB8fCBvdXJFcnJvck1lc3NhZ2Uuc3RhcnRzV2l0aCgnRXhwZWN0ZWQgXCJmKlwiLCBcIitcIicpIC8vIE1pZ2h0IG5lZWVkIGEgT0hNIHNjaGVtYSBmaXg/XG4gICAgICAgIClcbiAgICAgICAgICAgIGFkanVzdGVkUHJpb3JpdHkgPSAyOTQ7XG5cbiAgICAgICAgb3VyRXJyb3JPYmplY3QgPSB7XG4gICAgICAgICAgICBwcmlvcml0eTogYWRqdXN0ZWRQcmlvcml0eSwgbWVzc2FnZTogYFVTRk1HcmFtbWFyOiAke291ckVycm9yTWVzc2FnZX1gLFxuICAgICAgICAgICAgZmlsZW5hbWUsXG4gICAgICAgICAgICBjaGFyYWN0ZXJJbmRleCwgZXhjZXJwdCxcbiAgICAgICAgICAgIGxvY2F0aW9uOiBnaXZlbkxvY2F0aW9uXG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gU2F2ZSBvdXIgbGluZSBudW1iZXJcbiAgICAgICAgaWYgKGxpbmVOdW1iZXJTdHJpbmcgJiYgbGluZU51bWJlclN0cmluZy5sZW5ndGgpIHtcbiAgICAgICAgICAgIC8vIG91ckVycm9yT2JqZWN0LmxpbmVOdW1iZXIgPSBOdW1iZXIobGluZU51bWJlclN0cmluZyk7XG4gICAgICAgICAgICAvLyAgYnV0IHdlIG5lZWQgYSB0ZW1wb3JhcnkgZml4IGZvciB0aGUgQkNTIGJ1ZyB3aGljaCBkb2VzbuKAmXQgaW5jbHVkZSBibGFuayBsaW5lcyBpbiB0aGUgY291bnRcbiAgICAgICAgICAgIGxldCBsaW5lTnVtYmVyID0gTnVtYmVyKGxpbmVOdW1iZXJTdHJpbmcpXG4gICAgICAgICAgICBsZXQgbm90aWZpZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIGNvbnN0IGxpbmVzID0gZmlsZVRleHQuc3BsaXQoJ1xcbicpO1xuICAgICAgICAgICAgZm9yIChsZXQgbiA9IDE7IG4gPD0gbGluZXMubGVuZ3RoOyBuKyspIHtcbiAgICAgICAgICAgICAgICBpZiAobiA+PSBsaW5lTnVtYmVyKSBicmVhazsgLy8gR29uZSBmYXIgZW5vdWdoXG4gICAgICAgICAgICAgICAgaWYgKCFsaW5lc1tuIC0gMV0pIHtcbiAgICAgICAgICAgICAgICAgICAgbGluZU51bWJlciArPSAxOyAvLyBJbmNyZW1lbnQgZXJyb3IgbGluZSBudW1iZXIgZm9yIGVhY2ggYmxhbmsgbGluZVxuICAgICAgICAgICAgICAgICAgICBpZiAoIW5vdGlmaWVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB1c2VyTG9nKFwiVGVtcG9yYXJpbHkgYWRqdXN0aW5nIEJDUyBncmFtbWFyIGVycm9yIGxpbmUgbnVtYmVyIHRvIGFjY291bnQgZm9yIGJsYW5rIGxpbmVzXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbm90aWZpZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3VyRXJyb3JPYmplY3QubGluZU51bWJlciA9IGxpbmVOdW1iZXI7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBkZWJ1Z0xvZyhgICBXYXJuaW5nczogJHtKU09OLnN0cmluZ2lmeShwYXJzZVdhcm5pbmdzKX1gKTtcbiAgICBsZXQgb3VyV2FybmluZ3MgPSBbXTtcbiAgICBmb3IgKGNvbnN0IHdhcm5pbmdTdHJpbmcgb2YgcGFyc2VXYXJuaW5ncykge1xuICAgICAgICAvLyBkZWJ1Z0xvZyhgd2FybmluZ1N0cmluZzogJyR7d2FybmluZ1N0cmluZ30nYCk7XG4gICAgICAgIC8vIENsZWFuIHVwIHRoZWlyIHdhcm5pbmdzIGEgbGl0dGxlOiBSZW1vdmUgdHJhaWxpbmcgc3BhY2VzIGFuZCBwZXJpb2RzXG4gICAgICAgIGxldCBhZGp1c3RlZFN0cmluZyA9IHdhcm5pbmdTdHJpbmcudHJpbSgpOyAvLyBSZW1vdmVzIHRoZSB0cmFpbGluZyBzcGFjZVxuICAgICAgICBpZiAoYWRqdXN0ZWRTdHJpbmcuZW5kc1dpdGgoJy4nKSkgYWRqdXN0ZWRTdHJpbmcgPSBhZGp1c3RlZFN0cmluZy5zdWJzdHJpbmcoMCwgYWRqdXN0ZWRTdHJpbmcubGVuZ3RoIC0gMSk7XG4gICAgICAgIG91cldhcm5pbmdzLnB1c2goYWRqdXN0ZWRTdHJpbmcpO1xuICAgIH1cblxuICAgIHJldHVybiB7IGlzVmFsaWRVU0ZNOiAhcGFyc2VFcnJvciwgZXJyb3I6IG91ckVycm9yT2JqZWN0LCB3YXJuaW5nczogb3VyV2FybmluZ3MgfTtcbn1cbi8vIGVuZCBvZiBydW5CQ1NHcmFtbWFyQ2hlY2sgZnVuY3Rpb25cblxuXG5leHBvcnQgZnVuY3Rpb24gY2hlY2tVU0ZNR3JhbW1hcihib29rSUQsIHN0cmljdG5lc3NTdHJpbmcsIGZpbGVuYW1lLCBnaXZlblRleHQsIGdpdmVuTG9jYXRpb24sIGNoZWNraW5nT3B0aW9ucykge1xuICAgIC8qXG4gICAgVGhpcyBmdW5jdGlvbiBpcyBvbmx5IHVzZWQgZm9yIHRoZSBkZW1vbnN0cmF0aW9uIHBhZ2VzIC0tIG5vdCBmb3IgdGhlIGNvcmUhXG5cbiAgICBib29rSUQgaXMgYSB0aHJlZS1jaGFyYWN0ZXIgVVBQRVJDQVNFIFVTRk0gYm9vayBpZGVudGlmaWVyLlxuXG4gICAgZmlsZW5hbWUgcGFyYW1ldGVyIGNhbiBiZSBhbiBlbXB0eSBzdHJpbmcgaWYgd2UgZG9u4oCZdCBoYXZlIG9uZS5cblxuICAgICBSZXR1cm5zIGEgcmVzdWx0IG9iamVjdCBjb250YWluaW5nIGEgc3VjY2Vzc0xpc3QgYW5kIGEgbm90aWNlTGlzdFxuICAgICAqL1xuICAgIGZ1bmN0aW9uTG9nKGBjaGVja1VTRk1HcmFtbWFyKCR7Z2l2ZW5UZXh0Lmxlbmd0aC50b0xvY2FsZVN0cmluZygpfSBjaGFycywgJyR7Z2l2ZW5Mb2NhdGlvbn0nKeKApmApO1xuICAgIC8vcGFyYW1ldGVyQXNzZXJ0KHN0cmljdG5lc3NTdHJpbmcgPT09ICdzdHJpY3QnIHx8IHN0cmljdG5lc3NTdHJpbmcgPT09ICdyZWxheGVkJywgYFVuZXhwZWN0ZWQgc3RyaWN0bmVzc1N0cmluZz0nJHtzdHJpY3RuZXNzU3RyaW5nfSdgKTtcblxuICAgIGxldCBvdXJMb2NhdGlvbiA9IGdpdmVuTG9jYXRpb247XG4gICAgaWYgKG91ckxvY2F0aW9uICYmIG91ckxvY2F0aW9uWzBdICE9PSAnICcpIG91ckxvY2F0aW9uID0gYCAke291ckxvY2F0aW9ufWA7XG5cblxuICAgIGNvbnN0IGN1Z1Jlc3VsdCA9IHsgc3VjY2Vzc0xpc3Q6IFtdLCBub3RpY2VMaXN0OiBbXSB9O1xuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3VjY2Vzc1N0cmluZ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGFkZFN1Y2Nlc3NNZXNzYWdlKHN1Y2Nlc3NTdHJpbmcpIHtcbiAgICAgICAgLy8gZnVuY3Rpb25Mb2coYGNoZWNrVVNGTUdyYW1tYXIgc3VjY2VzczogJHtzdWNjZXNzU3RyaW5nfWApO1xuICAgICAgICBjdWdSZXN1bHQuc3VjY2Vzc0xpc3QucHVzaChzdWNjZXNzU3RyaW5nKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAZGVzY3JpcHRpb24gLSBhZGRzIGEgbmV3IG5vdGljZSBlbnRyeSBmcm9tIHRoZSBwYXJ0aWFsIGZpZWxkcyBnaXZlbiAtLSBhZGRpbmcgYm9va0lEIGFuZCBmaWxlbmFtZSB0byB0aGUgZ2l2ZW4gZmllbGRzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG5vdGljZU9iamVjdCBleHBlY3RlZCB0byBjb250YWluIHByaW9yaXR5LCBtZXNzYWdlLCBjaGFyYWN0ZXJJbmRleCwgZXhlcnB0LCBsb2NhdGlvblxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGFkZE5vdGljZVBhcnRpYWwobm90aWNlT2JqZWN0KSB7XG4gICAgICAgIC8vIGZ1bmN0aW9uTG9nKGBjaGVja1VTRk1HcmFtbWFyIG5vdGljZTogKHByaW9yaXR5PSR7cHJpb3JpdHl9KSAke21lc3NhZ2V9JHtjaGFyYWN0ZXJJbmRleCA+IDAgPyBgIChhdCBjaGFyYWN0ZXIgJHtjaGFyYWN0ZXJJbmRleH0pYCA6IFwiXCJ9JHtleGNlcnB0ID8gYCAke2V4Y2VycHR9YCA6IFwiXCJ9JHtsb2NhdGlvbn1gKTtcbiAgICAgICAgLy9wYXJhbWV0ZXJBc3NlcnQobm90aWNlT2JqZWN0LnByaW9yaXR5ICE9PSB1bmRlZmluZWQsIFwiY1VTRk1nciBhZGROb3RpY2VQYXJ0aWFsOiAncHJpb3JpdHknIHBhcmFtZXRlciBzaG91bGQgYmUgZGVmaW5lZFwiKTtcbiAgICAgICAgLy9wYXJhbWV0ZXJBc3NlcnQodHlwZW9mIG5vdGljZU9iamVjdC5wcmlvcml0eSA9PT0gJ251bWJlcicsIGBjVVNGTWdyIGFkZE5vdGljZVBhcnRpYWw6ICdwcmlvcml0eScgcGFyYW1ldGVyIHNob3VsZCBiZSBhIG51bWJlciBub3QgYSAnJHt0eXBlb2Ygbm90aWNlT2JqZWN0LnByaW9yaXR5fSc6ICR7bm90aWNlT2JqZWN0LnByaW9yaXR5fWApO1xuICAgICAgICAvL3BhcmFtZXRlckFzc2VydChub3RpY2VPYmplY3QubWVzc2FnZSAhPT0gdW5kZWZpbmVkLCBcImNVU0ZNZ3IgYWRkTm90aWNlUGFydGlhbDogJ21lc3NhZ2UnIHBhcmFtZXRlciBzaG91bGQgYmUgZGVmaW5lZFwiKTtcbiAgICAgICAgLy9wYXJhbWV0ZXJBc3NlcnQodHlwZW9mIG5vdGljZU9iamVjdC5tZXNzYWdlID09PSAnc3RyaW5nJywgYGNVU0ZNZ3IgYWRkTm90aWNlUGFydGlhbDogJ21lc3NhZ2UnIHBhcmFtZXRlciBzaG91bGQgYmUgYSBzdHJpbmcgbm90IGEgJyR7dHlwZW9mIG5vdGljZU9iamVjdC5tZXNzYWdlfSc6ICR7bm90aWNlT2JqZWN0Lm1lc3NhZ2V9YCk7XG4gICAgICAgIC8vIC8vcGFyYW1ldGVyQXNzZXJ0KGNoYXJhY3RlckluZGV4ICE9PSB1bmRlZmluZWQsIFwiY1VTRk1nciBhZGROb3RpY2VQYXJ0aWFsOiAnY2hhcmFjdGVySW5kZXgnIHBhcmFtZXRlciBzaG91bGQgYmUgZGVmaW5lZFwiKTtcbiAgICAgICAgaWYgKG5vdGljZU9iamVjdC5jaGFyYWN0ZXJJbmRleCkgeyAvL3BhcmFtZXRlckFzc2VydCh0eXBlb2Ygbm90aWNlT2JqZWN0LmNoYXJhY3RlckluZGV4ID09PSAnbnVtYmVyJywgYGNVU0ZNZ3IgYWRkTm90aWNlUGFydGlhbDogJ2NoYXJhY3RlckluZGV4JyBwYXJhbWV0ZXIgc2hvdWxkIGJlIGEgbnVtYmVyIG5vdCBhICcke3R5cGVvZiBub3RpY2VPYmplY3QuY2hhcmFjdGVySW5kZXh9JzogJHtub3RpY2VPYmplY3QuY2hhcmFjdGVySW5kZXh9YCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gLy9wYXJhbWV0ZXJBc3NlcnQoZXhjZXJwdCAhPT0gdW5kZWZpbmVkLCBcImNVU0ZNZ3IgYWRkTm90aWNlUGFydGlhbDogJ2V4Y2VycHQnIHBhcmFtZXRlciBzaG91bGQgYmUgZGVmaW5lZFwiKTtcbiAgICAgICAgaWYgKG5vdGljZU9iamVjdC5leGNlcnB0KSB7IC8vcGFyYW1ldGVyQXNzZXJ0KHR5cGVvZiBub3RpY2VPYmplY3QuZXhjZXJwdCA9PT0gJ3N0cmluZycsIGBjVVNGTWdyIGFkZE5vdGljZVBhcnRpYWw6ICdleGNlcnB0JyBwYXJhbWV0ZXIgc2hvdWxkIGJlIGEgc3RyaW5nIG5vdCBhICcke3R5cGVvZiBleGNlcnB0fSc6ICR7bm90aWNlT2JqZWN0LmV4Y2VycHR9YCk7XG4gICAgICAgIH1cbiAgICAgICAgLy9wYXJhbWV0ZXJBc3NlcnQobm90aWNlT2JqZWN0LmxvY2F0aW9uICE9PSB1bmRlZmluZWQsIFwiY1VTRk1nciBhZGROb3RpY2VQYXJ0aWFsOiAnbG9jYXRpb24nIHBhcmFtZXRlciBzaG91bGQgYmUgZGVmaW5lZFwiKTtcbiAgICAgICAgLy9wYXJhbWV0ZXJBc3NlcnQodHlwZW9mIG5vdGljZU9iamVjdC5sb2NhdGlvbiA9PT0gJ3N0cmluZycsIGBjVVNGTWdyIGFkZE5vdGljZVBhcnRpYWw6ICdsb2NhdGlvbicgcGFyYW1ldGVyIHNob3VsZCBiZSBhIHN0cmluZyBub3QgYSAnJHt0eXBlb2Ygbm90aWNlT2JqZWN0LmxvY2F0aW9ufSc6ICR7bm90aWNlT2JqZWN0LmxvY2F0aW9ufWApO1xuICAgICAgICBjdWdSZXN1bHQubm90aWNlTGlzdC5wdXNoKHsgLi4ubm90aWNlT2JqZWN0LCBib29rSUQsIGZpbGVuYW1lIH0pO1xuICAgIH1cblxuXG4gICAgLy8gTWFpbiBjb2RlIGZvciBjaGVja1VTRk1HcmFtbWFyIGZ1bmN0aW9uXG4gICAgaWYgKGJvb2tzLmlzRXh0cmFCb29rSUQoYm9va0lEKSkgLy8gZG9lc27igJl0IHdvcmsgZm9yIHRoZXNlXG4gICAgICAgIHJldHVybiBjdWdSZXN1bHQ7XG5cbiAgICBjb25zdCBncmFtbWFyQ2hlY2tSZXN1bHQgPSBydW5CQ1NHcmFtbWFyQ2hlY2soc3RyaWN0bmVzc1N0cmluZywgYm9va0lELCBnaXZlblRleHQsIGZpbGVuYW1lLCBvdXJMb2NhdGlvbiwgY2hlY2tpbmdPcHRpb25zKTtcbiAgICAvLyBkZWJ1Z0xvZyhgZ3JhbW1hckNoZWNrUmVzdWx0PSR7SlNPTi5zdHJpbmdpZnkoZ3JhbW1hckNoZWNrUmVzdWx0KX1gKTtcblxuICAgIGlmICghZ3JhbW1hckNoZWNrUmVzdWx0LmlzVmFsaWRVU0ZNKVxuICAgICAgICBhZGROb3RpY2VQYXJ0aWFsKHsgcHJpb3JpdHk6IDk0NCwgbWVzc2FnZTogYFVTRk0zIEdyYW1tYXIgQ2hlY2sgKCR7c3RyaWN0bmVzc1N0cmluZ30gbW9kZSkgZG9lc27igJl0IHBhc3NgLCBmaWxlbmFtZSwgbG9jYXRpb246IG91ckxvY2F0aW9uIH0pO1xuXG4gICAgLy8gV2Ugb25seSBnZXQgb25lIGVycm9yIGlmIGl0IGZhaWxzXG4gICAgaWYgKGdyYW1tYXJDaGVja1Jlc3VsdC5lcnJvciAmJiBncmFtbWFyQ2hlY2tSZXN1bHQucHJpb3JpdHkpXG4gICAgICAgIGFkZE5vdGljZVBhcnRpYWwoZ3JhbW1hckNoZWNrUmVzdWx0LmVycm9yKTtcblxuICAgIC8vIERpc3BsYXkgdGhlc2Ugd2FybmluZ3MgYnV0IHdpdGggYSBsb3dpc2ggcHJpb3JpdHlcbiAgICBmb3IgKGNvbnN0IHdhcm5pbmdTdHJpbmcgb2YgZ3JhbW1hckNoZWNrUmVzdWx0Lndhcm5pbmdzKVxuICAgICAgICBhZGROb3RpY2VQYXJ0aWFsKHsgcHJpb3JpdHk6IDEwMSwgbWVzc2FnZTogYFVTRk1HcmFtbWFyOiAke3dhcm5pbmdTdHJpbmd9YCwgZmlsZW5hbWUsIGxvY2F0aW9uOiBvdXJMb2NhdGlvbiB9KTtcblxuICAgIGFkZFN1Y2Nlc3NNZXNzYWdlKGBDaGVja2VkIFVTRk0gR3JhbW1hciAoJHtzdHJpY3RuZXNzU3RyaW5nfSBtb2RlKSAke2dyYW1tYXJDaGVja1Jlc3VsdC5pc1ZhbGlkVVNGTSA/IFwid2l0aG91dCBlcnJvcnNcIiA6IFwiIChidXQgdGhlIFVTRk0gRElETuKAmVQgdmFsaWRhdGUpXCJ9YCk7XG4gICAgLy8gZGVidWdMb2coYCAgY2hlY2tVU0ZNR3JhbW1hciByZXR1cm5pbmcgd2l0aCAke3Jlc3VsdC5zdWNjZXNzTGlzdC5sZW5ndGgudG9Mb2NhbGVTdHJpbmcoKX0gc3VjY2VzcyhlcykgYW5kICR7cmVzdWx0Lm5vdGljZUxpc3QubGVuZ3RoLnRvTG9jYWxlU3RyaW5nKCl9IG5vdGljZShzKS5gKTtcbiAgICAvLyBmdW5jdGlvbkxvZyhgY2hlY2tVU0ZNR3JhbW1hciByZXN1bHQgaXMgJHtKU09OLnN0cmluZ2lmeShyZXN1bHQpfWApO1xuICAgIHJldHVybiBjdWdSZXN1bHQ7XG59XG4vLyBlbmQgb2YgY2hlY2tVU0ZNR3JhbW1hciBmdW5jdGlvblxuIl19