"use strict";var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");var _typeof = require("@babel/runtime/helpers/typeof");Object.defineProperty(exports, "__esModule", { value: true });exports.clearCaches = clearCaches;exports.formRepoName = formRepoName;exports.cachedGetFile = cachedGetFile;exports.cachedGetBookFilenameFromManifest = cachedGetBookFilenameFromManifest;exports.preloadReposIfNecessary = preloadReposIfNecessary;exports.cachedFetchFileFromServerWithTag = cachedFetchFileFromServerWithTag;exports.repositoryExistsOnDoor43 = repositoryExistsOnDoor43;exports.cachedGetFileUsingFullURL = cachedGetFileUsingFullURL;exports.cachedGetRepositoryZipFile = cachedGetRepositoryZipFile;exports.getFileListFromZip = getFileListFromZip;var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));var _path = _interopRequireDefault(require("path"));
var _yaml = _interopRequireDefault(require("yaml"));
var _localforage = _interopRequireDefault(require("localforage"));
var _axiosCacheAdapter = require("axios-cache-adapter");
var _jszip = _interopRequireDefault(require("jszip"));
var books = _interopRequireWildcard(require("./books"));
var _notesLinksCheck = require("./notes-links-check");

var _utilities = require("./utilities");function _getRequireWildcardCache(nodeInterop) {if (typeof WeakMap !== "function") return null;var cacheBabelInterop = new WeakMap();var cacheNodeInterop = new WeakMap();return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) {return nodeInterop ? cacheNodeInterop : cacheBabelInterop;})(nodeInterop);}function _interopRequireWildcard(obj, nodeInterop) {if (!nodeInterop && obj && obj.__esModule) {return obj;}if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") {return { default: obj };}var cache = _getRequireWildcardCache(nodeInterop);if (cache && cache.has(obj)) {return cache.get(obj);}var newObj = {};var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;for (var key in obj) {if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;if (desc && (desc.get || desc.set)) {Object.defineProperty(newObj, key, desc);} else {newObj[key] = obj[key];}}}newObj.default = obj;if (cache) {cache.set(obj, newObj);}return newObj;}function _createForOfIteratorHelper(o, allowArrayLike) {var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];if (!it) {if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {if (it) o = it;var i = 0;var F = function F() {};return { s: F, n: function n() {if (i >= o.length) return { done: true };return { done: false, value: o[i++] };}, e: function e(_e) {throw _e;}, f: F };}throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");}var normalCompletion = true,didErr = false,err;return { s: function s() {it = it.call(o);}, n: function n() {var step = it.next();normalCompletion = step.done;return step;}, e: function e(_e2) {didErr = true;err = _e2;}, f: function f() {try {if (!normalCompletion && it.return != null) it.return();} finally {if (didErr) throw err;}} };}function _unsupportedIterableToArray(o, minLen) {if (!o) return;if (typeof o === "string") return _arrayLikeToArray(o, minLen);var n = Object.prototype.toString.call(o).slice(8, -1);if (n === "Object" && o.constructor) n = o.constructor.name;if (n === "Map" || n === "Set") return Array.from(o);if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);}function _arrayLikeToArray(arr, len) {if (len == null || len > arr.length) len = arr.length;for (var i = 0, arr2 = new Array(len); i < len; i++) {arr2[i] = arr[i];}return arr2;}


// const GETAPI_VERSION_STRING = '0.8.1';

var MAX_INDIVIDUAL_FILES_TO_DOWNLOAD = 5; // More than this and it downloads the zipfile for the entire repo

var DOOR43_BASE_URL = 'https://git.door43.org/';
var API_PATH = 'api/v1';

var OBS_PICTURE_ZIP_FILENAME = 'obs-images-360px.zip';
var OBS_PICTURE_ZIP_URI = "https://cdn.door43.org/obs/jpg/".concat(OBS_PICTURE_ZIP_FILENAME);


// caches failed http file fetches so we don’t waste time with repeated attempts
var failedStore = _localforage.default.createInstance({
  driver: [_localforage.default.INDEXEDDB],
  name: 'CV-failed-store' });


// caches zip file fetches done by cachedGetRepositoryZipFile()
var zipStore = _localforage.default.createInstance({
  driver: [_localforage.default.INDEXEDDB],
  name: 'CV-zip-store' });


// caches http file fetches done by cachedFetchFileFromServerWithBranch()
var cacheStore = _localforage.default.createInstance({
  driver: [_localforage.default.INDEXEDDB],
  name: 'CV-web-cache' });


// caches the unzipped files requested so we don’t do repeated unzipping of the same file which is slow in JS
var unzipStore = _localforage.default.createInstance({
  driver: [_localforage.default.INDEXEDDB],
  name: 'CV-unzip-store' });


// API for http requests
// NOTE: Even if data expires in this AxiosCacheAdapter, the localforage caches don’t have the same / any expiry ages
//        (We expect the users of the demos to manually clear the caches when an update is required.)
var Door43Api = (0, _axiosCacheAdapter.setup)({
  baseURL: DOOR43_BASE_URL,
  cache: {
    store: cacheStore,
    maxAge: 1 * 60 * 60 * 1000, // 1 hour (unless they manually clear the cache)
    exclude: { query: false },
    key: function key(req) {
      // if (req.params) debugger
      var serialized = req.params instanceof URLSearchParams ?
      req.params.toString() : JSON.stringify(req.params) || '';
      return req.url + serialized;
    } } });




/**
 * Clear all the localforage.INDEXEDDB stores
 * @return {Promise<void>}
 */function
clearCaches() {return _clearCaches.apply(this, arguments);}












/**
 * @description - Forms and returns a Door43 repoName string
 * @param {string} languageCode - the language code, e.g., 'en'
 * @param {string} repoCode - the repo code, e.g., 'TQ2'
 * @return {String} - the Door43 repoName string
 */function _clearCaches() {_clearCaches = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee() {return _regenerator.default.wrap(function _callee$(_context) {while (1) {switch (_context.prev = _context.next) {case 0:(0, _utilities.userLog)("Clearing all four CV localforage.INDEXEDDB caches…"); // const tasks = [zipStore, cacheStore].map(localforage.clear);
            // const results = await Promise.all(tasks);
            // results.forEach(x => userLog("Done it", x));
            _context.next = 3;return failedStore.clear();case 3:_context.next = 5;return zipStore.clear();case 5:_context.next = 7;return cacheStore.clear();case 7:_context.next = 9;return unzipStore.clear();case 9:_context.next = 11;return (0, _notesLinksCheck.clearCheckedArticleCache)();case 11:case "end":return _context.stop();}}}, _callee);}));return _clearCaches.apply(this, arguments);}function formRepoName(languageCode, repoCode) {//    userLog(`formRepoName('${languageCode}', '${repoCode}')…`);
  // TODO: Should we also check the username 'unfoldingWord' and/or 'Door43-Catalog' here???
  //        (We don’t currently have the username available in this function.)
  if (repoCode === 'LT') repoCode = languageCode === 'en' ? 'ULT' : 'GLT';
  if (repoCode === 'ST') repoCode = languageCode === 'en' ? 'UST' : 'GST';

  var repo_languageCode = languageCode;
  if (repoCode === 'UHB') repo_languageCode = 'hbo';else
  if (repoCode === 'UGNT') repo_languageCode = 'el-x-koine';

  var repoName;

  // if (repoCode.endsWith('2')) repoCode = repoCode.substring(0, repoCode.length - 1);
  repoName = "".concat(repo_languageCode, "_").concat(repoCode.toLowerCase());
  return repoName;
}


/**
 * add new repo to list if missing
 * @param repos
 * @param newRepo
 */
/*
function addToListIfMissing(repos, newRepo) {
  if (!repos.includes(newRepo)) {
    repos.unshift(newRepo);
  }
}
*/


/**
 * try to get previously unzipped file from cache
 * @param {string} path
 * @return {Promise<unknown>} resolves to file contents or null if not found
 */function
getUnZippedFile(_x) {return _getUnZippedFile.apply(this, arguments);}






/**
 * try to get previously unzipped picture file from cache
 * @param {string} uri
 * @return {Promise<unknown>} resolves to file contents or null if not found
 */function _getUnZippedFile() {_getUnZippedFile = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee2(path) {var contents;return _regenerator.default.wrap(function _callee2$(_context2) {while (1) {switch (_context2.prev = _context2.next) {case 0:_context2.next = 2;return unzipStore.getItem(path.toLowerCase());case 2:contents = _context2.sent;return _context2.abrupt("return", contents);case 4:case "end":return _context2.stop();}}}, _callee2);}));return _getUnZippedFile.apply(this, arguments);}function
getUnZippedPictureFile(_x2) {return _getUnZippedPictureFile.apply(this, arguments);}






/**
 * searches for files in this order:
 *   - cache of uncompressed files (unzipStore)
 *   - cache of zipped repos (zipStore)
 *   - and finally calls cachedFetchFileFromServerWithBranch() which first checks in cacheStore to see if already fetched. * @param {string} username
 * @param {string} repository
 * @param {string} path
 * @param {string} branch
 * @return {Promise<*>}
 */
// This is the function that we call the most from the outside
function _getUnZippedPictureFile() {_getUnZippedPictureFile = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee3(uri) {var contents;return _regenerator.default.wrap(function _callee3$(_context3) {while (1) {switch (_context3.prev = _context3.next) {case 0:_context3.next = 2;return unzipStore.getItem(uri);case 2:contents = _context3.sent;return _context3.abrupt("return", contents);case 4:case "end":return _context3.stop();}}}, _callee3);}));return _getUnZippedPictureFile.apply(this, arguments);}function cachedGetFile(_x3) {return _cachedGetFile.apply(this, arguments);}

































/**
 * Retrieve manifest.yaml from requested repo
 * @param {string} username
 * @param {string} repository
 * @param {string} branch
 * @return {Promise<[]|*[]>} resolves to manifest contents if downloaded (else undefined)
 */function _cachedGetFile() {_cachedGetFile = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee4(_ref) {var username, repository, path, branch, filePath, contents;return _regenerator.default.wrap(function _callee4$(_context4) {while (1) {switch (_context4.prev = _context4.next) {case 0:username = _ref.username, repository = _ref.repository, path = _ref.path, branch = _ref.branch; // functionLog(`cachedGetFile(${username}, ${repository}, ${path}, ${branch})…`);
            //parameterAssert(typeof username === 'string' && username.length, `cachedGetFile: username parameter should be a non-empty string not ${typeof username}: ${username}`);
            //parameterAssert(typeof repository === 'string' && repository.length, `cachedGetFile: repository parameter should be a non-empty string not ${typeof repository}: ${repository}`);
            //parameterAssert(typeof path === 'string' && path.length, `cachedGetFile: path parameter should be a non-empty string not ${typeof path}: ${path}`);
            //parameterAssert(typeof branch === 'string' && branch.length, `cachedGetFile: branch parameter should be a non-empty string not ${typeof branch}: ${branch}`);
            filePath = _path.default.join(username, repository, path, branch);_context4.next = 4;return getUnZippedFile(filePath);case 4:contents = _context4.sent;if (!contents) {_context4.next = 7;break;}return _context4.abrupt("return", contents);case 7:_context4.next = 9;return getFileFromZip({ username: username, repository: repository, path: path, branchOrRelease: branch });case 9:contents = _context4.sent;if (contents) {_context4.next = 14;break;}_context4.next = 13;return cachedFetchFileFromServerWithBranch({ username: username, repository: repository, path: path, branch: branch });case 13:contents = _context4.sent;case 14:if (!contents) {_context4.next = 17;break;}_context4.next = 17;return unzipStore.setItem(filePath.toLowerCase(), contents);case 17:return _context4.abrupt("return", contents);case 18:case "end":return _context4.stop();}}}, _callee4);}));return _cachedGetFile.apply(this, arguments);}function cachedGetManifest(_x4) {return _cachedGetManifest.apply(this, arguments);}











/**
 * Retrieve manifest.yaml from requested repo
 * @param {string} username
 * @param {string} repository
 * @param {string} branch
 * @param {string} bookID -- 3-character USFM book code
 * @return {Promise<[]|*[]>} resolves to filename from the manifest for the book (else undefined)
 */function _cachedGetManifest() {_cachedGetManifest = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee5(_ref2) {var username, repository, branch, manifestContents, formData;return _regenerator.default.wrap(function _callee5$(_context5) {while (1) {switch (_context5.prev = _context5.next) {case 0:username = _ref2.username, repository = _ref2.repository, branch = _ref2.branch;_context5.next = 3;return cachedGetFile({ username: username, repository: repository, path: 'manifest.yaml', branch: branch });case 3:manifestContents = _context5.sent;try {formData = _yaml.default.parse(manifestContents); // debugLog("yaml.parse(YAMLText) got formData", JSON.stringify(formData));
            } catch (yamlError) {console.error("".concat(username, " ").concat(repository, " ").concat(branch, " manifest yaml parse error: ").concat(yamlError.message));}return _context5.abrupt("return", formData);case 6:case "end":return _context5.stop();}}}, _callee5);}));return _cachedGetManifest.apply(this, arguments);}function cachedGetBookFilenameFromManifest(_x5) {return _cachedGetBookFilenameFromManifest.apply(this, arguments);}












/**
 * Preloads any necessary repo zips, before running book package checks
 *   This allows the calling app to clear cache and start loading repos in the backgound as soon as it starts up.
 *      In this case it would not need to use await to wait for results.
 *   TRICKY: note that even if the user is super fast in selecting books and clicking next, it will not hurt anything.
 *            cachedGetFileFromZipOrServer() would just be fetching files directly from repo until the zips are loaded.
 *            After that the files would be pulled out of zipStore.
 * @param {string} username
 * @param {string} languageCode
 * @param {Array} bookIDList - one or more books that will be checked
 * @param {string} branch - optional, defaults to master
 * @param {Array} repoList - optional, list of repos to pre-load
 * @return {Promise<Boolean>} resolves to true if file loads are successful
 */function _cachedGetBookFilenameFromManifest() {_cachedGetBookFilenameFromManifest = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee6(_ref3) {var username, repository, branch, bookID, manifestJSON, _iterator, _step, projectEntry, bookPath;return _regenerator.default.wrap(function _callee6$(_context6) {while (1) {switch (_context6.prev = _context6.next) {case 0:username = _ref3.username, repository = _ref3.repository, branch = _ref3.branch, bookID = _ref3.bookID;_context6.next = 3;return cachedGetManifest({ username: username, repository: repository, branch: branch });case 3:manifestJSON = _context6.sent;_iterator = _createForOfIteratorHelper(manifestJSON.projects);_context6.prev = 5;_iterator.s();case 7:if ((_step = _iterator.n()).done) {_context6.next = 15;break;}projectEntry = _step.value;if (!(projectEntry.identifier === bookID)) {_context6.next = 13;break;}bookPath = projectEntry.path;if (bookPath.startsWith('./')) bookPath = bookPath.substring(2);return _context6.abrupt("return", bookPath);case 13:_context6.next = 7;break;case 15:_context6.next = 20;break;case 17:_context6.prev = 17;_context6.t0 = _context6["catch"](5);_iterator.e(_context6.t0);case 20:_context6.prev = 20;_iterator.f();return _context6.finish(20);case 23:case "end":return _context6.stop();}}}, _callee6, null, [[5, 17, 20, 23]]);}));return _cachedGetBookFilenameFromManifest.apply(this, arguments);}function
preloadReposIfNecessary(_x6, _x7, _x8, _x9, _x10) {return _preloadReposIfNecessary.apply(this, arguments);}




























































































/**
 * does http file fetch from server  uses cacheStore to minimize repeated fetches of same file
 * @param {string} username
 * @param {string} repository
 * @param {string} path
 * @param {string} branch
 * @return {Promise<null|any>} resolves to file content
 */function _preloadReposIfNecessary() {_preloadReposIfNecessary = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee7(username, languageCode, bookIDList, branchOrRelease, repoList) {var success, repos_, _iterator2, _step2, bookID, whichTestament, origLangRepo, _iterator3, _step3, repoCode, adjustedLanguageCode, adjustedBranchOrRelease, adjustedRepoCode, repoName, zipFetchSucceeded, zipBlob, response, zipArrayBuffer;return _regenerator.default.wrap(function _callee7$(_context7) {while (1) {switch (_context7.prev = _context7.next) {case 0: // NOTE: We preload TA and TW by default because we are likely to have many links to those repos
            //        We preload TQ by default because it has thousands of files (17,337), so individual file fetches might be slow
            //          even for one book which might have several hundred files.
            // functionLog(`preloadReposIfNecessary(${username}, ${languageCode}, ${bookIDList} (${typeof bookID}), ${branchOrRelease}, [${repoList}])…`);
            success = true;repos_ = (0, _toConsumableArray2.default)(repoList);if (bookIDList.includes('OBS')) {if (!repos_.includes('OBS')) repos_.unshift('OBS'); // push to beginning of list
            }if (bookIDList && Array.isArray(bookIDList) && bookIDList.length > MAX_INDIVIDUAL_FILES_TO_DOWNLOAD) {// Fetch individually if checking less books
              // make sure we have the original languages needed
              _iterator2 = _createForOfIteratorHelper(bookIDList);try {for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {bookID = _step2.value;if (bookID !== 'OBS') {whichTestament = books.testament(bookID); // returns 'old' or 'new'
                    (0, _utilities.logicAssert)(whichTestament === 'old' || whichTestament === 'new', "preloadReposIfNecessary() couldn't find testament for '".concat(bookID, "'"));origLangRepo = whichTestament === 'old' ? 'UHB' : 'UGNT';if (!repos_.includes(origLangRepo)) repos_.unshift(origLangRepo);}}} catch (err) {_iterator2.e(err);} finally {_iterator2.f();}} // debugLog(`  Adjusted repo list: (${repos_.length}) ${JSON.stringify(repos_)}`);
            // // See if the required repos are there already
            // debugLog(`Check if need to preload ${repos_.length} repos: ${repos_}`)
            // const newRepoList = [];
            // for (const repoCode of repos_) {
            //   const repoName = formRepoName(languageCode, repoCode);
            //   // debugLog(`preloadReposIfNecessary: checking zip file for ${repoName}…`);
            //   const uri = zipUri({ username, repository: repoName, branchOrRelease });
            //   const zipBlob = await zipStore.getItem(uri.toLowerCase());
            //   if (!zipBlob) newRepoList.push(repoCode);
            // }
            // if (newRepoList.length) { // Fetch zipped versions of all the repos needing to be preloaded
            //   userLog(`Need to preload ${newRepoList.length} repos: ${newRepoList}`)
            //   for (const repoCode of newRepoList) {
            //     const repoName = formRepoName(languageCode, repoCode);
            //     userLog(`preloadReposIfNecessary: preloading zip file for ${repoName}…`);
            //     const zipFetchSucceeded = await cachedGetRepositoryZipFile({ username, repository: repoName, branchOrRelease });
            //     if (!zipFetchSucceeded) {
            //       userLog(`preloadReposIfNecessary: misfetched zip file for ${repoCode} repo with ${zipFetchSucceeded}`);
            //       success = false;
            //     }
            //   }
            // }
            // else userLog("All repos were cached already!");
            _iterator3 = _createForOfIteratorHelper(repos_);_context7.prev = 5;_iterator3.s();case 7:if ((_step3 = _iterator3.n()).done) {_context7.next = 41;break;}repoCode = _step3.value; // debugLog(`preloadReposIfNecessary: looking at repoCode '${repoCode}'…`);
            adjustedLanguageCode = languageCode;if (languageCode === 'hbo' && repoCode !== 'UHB' || languageCode === 'el-x-koine' && repoCode !== 'UGNT') adjustedLanguageCode = 'en'; // Assume English then
            adjustedBranchOrRelease = branchOrRelease;adjustedRepoCode = repoCode;if (repoCode.endsWith('2')) {adjustedRepoCode = adjustedRepoCode.substring(0, adjustedRepoCode.length - 1); // Remove the '2' from the end
              adjustedBranchOrRelease = 'newFormat';} // else if (repoCode === 'OBS-TN' || repoCode === 'OBS-TQ' || repoCode === 'OBS-SN' || repoCode === 'OBS-SQ')
            //   adjustedBranchOrRelease = 'newFormat';
            repoName = formRepoName(adjustedLanguageCode, adjustedRepoCode); // debugLog(`preloadReposIfNecessary: preloading zip file for ${repoName}…`);
            _context7.next = 17;return cachedGetRepositoryZipFile({ username: username, repository: repoName, branchOrRelease: adjustedBranchOrRelease });case 17:zipFetchSucceeded = _context7.sent;if (!zipFetchSucceeded) {console.error("preloadReposIfNecessary() misfetched zip file for ".concat(repoCode, " (").concat(adjustedRepoCode, ") repo with ").concat(zipFetchSucceeded));success = false;}if (!(repoCode === 'OBS')) {_context7.next = 39;break;}(0, _utilities.debugLog)("preloadReposIfNecessary: preloading OBS zipped pictures file from ".concat(OBS_PICTURE_ZIP_URI, "\u2026"));_context7.next = 23;return zipStore.getItem(OBS_PICTURE_ZIP_FILENAME);case 23:zipBlob = _context7.sent;if (zipBlob) {_context7.next = 39;break;}(0, _utilities.userLog)("downloadingOBSPicturesZipFile(".concat(OBS_PICTURE_ZIP_URI, ")\u2026"));_context7.next = 28;return fetch(OBS_PICTURE_ZIP_URI);case 28:response = _context7.sent;if (!(response.status === 200 || response.status === 0)) {_context7.next = 37;break;}_context7.next = 32;return response.arrayBuffer();case 32:zipArrayBuffer = _context7.sent;_context7.next = 35;return zipStore.setItem(OBS_PICTURE_ZIP_FILENAME, zipArrayBuffer);case 35:_context7.next = 39;break;case 37:console.error("downloadingOBSPicturesZipFile(".concat(OBS_PICTURE_ZIP_URI, ") -- got response status: ").concat(response.status));success = false;case 39:_context7.next = 7;break;case 41:_context7.next = 46;break;case 43:_context7.prev = 43;_context7.t0 = _context7["catch"](5);_iterator3.e(_context7.t0);case 46:_context7.prev = 46;_iterator3.f();return _context7.finish(46);case 49:return _context7.abrupt("return", success);case 50:case "end":return _context7.stop();}}}, _callee7, null, [[5, 43, 46, 49]]);}));return _preloadReposIfNecessary.apply(this, arguments);}function cachedFetchFileFromServerWithBranch(_x11) {return _cachedFetchFileFromServerWithBranch.apply(this, arguments);}function _cachedFetchFileFromServerWithBranch() {_cachedFetchFileFromServerWithBranch = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee8(_ref4) {var username, repository, path, _ref4$branch, branch, uri;return _regenerator.default.wrap(function _callee8$(_context8) {while (1) {switch (_context8.prev = _context8.next) {case 0:username = _ref4.username, repository = _ref4.repository, path = _ref4.path, _ref4$branch = _ref4.branch, branch = _ref4$branch === void 0 ? 'master' : _ref4$branch; // functionLog(`cachedFetchFileFromServerWithBranch(${username}, ${repository}, ${path}, ${branch})…`);
            // TODO: Check how slow this next call is -- can it be avoided or cached?
            // RJH removed this 2Oct2020 -- what’s the point -- it just slows things down --
            //      if it needs to be checked, should be checked before this point
            // const repositoryExistsOnDoor43 = await repositoryExistsOnDoor43({ username, repository });
            // let uri;
            uri = _path.default.join(username, repository, 'raw/branch', branch, path);_context8.next = 4;return cachedFetchFileFromServerWorker(uri, username, repository, path, branch);case 4:return _context8.abrupt("return", _context8.sent);case 5:case "end":return _context8.stop();}}}, _callee8);}));return _cachedFetchFileFromServerWithBranch.apply(this, arguments);}; /**
 * does http file fetch from server  uses cacheStore to minimize repeated fetches of same file
 * @param {string} username
 * @param {string} repository
 * @param {string} path
 * @param {string} tag
 * @return {Promise<null|any>} resolves to file content
 */function cachedFetchFileFromServerWithTag(_x12) {return _cachedFetchFileFromServerWithTag.apply(this, arguments);}function _cachedFetchFileFromServerWithTag() {_cachedFetchFileFromServerWithTag = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee9(_ref5) {var username, repository, path, tag, uri;return _regenerator.default.wrap(function _callee9$(_context9) {while (1) {switch (_context9.prev = _context9.next) {case 0:username = _ref5.username, repository = _ref5.repository, path = _ref5.path, tag = _ref5.tag; // functionLog(`cachedFetchFileFromServerWithTag(${username}, ${repository}, ${path}, ${tag})…`);
            // TODO: Check how slow this next call is -- can it be avoided or cached?
            // RJH removed this 2Oct2020 -- what’s the point -- it just slows things down --
            //      if it needs to be checked, should be checked before this point
            // const repositoryExistsOnDoor43 = await repositoryExistsOnDoor43({ username, repository });
            // let uri;
            uri = _path.default.join(username, repository, 'raw/tag', tag, path);_context9.next = 4;return cachedFetchFileFromServerWorker(uri, username, repository, path, tag);case 4:return _context9.abrupt("return", _context9.sent);case 5:case "end":return _context9.stop();}}}, _callee9);}));return _cachedFetchFileFromServerWithTag.apply(this, arguments);}; /**
 * does http file fetch from server  uses cacheStore to minimize repeated fetches of same file
 * @param {string} username
 * @param {string} repository
 * @param {string} path
 * @param {string} branch
 * @return {Promise<null|any>} resolves to file content
 */function cachedFetchFileFromServerWorker(_x13, _x14, _x15, _x16, _x17) {return _cachedFetchFileFromServerWorker.apply(this, arguments);}function _cachedFetchFileFromServerWorker() {_cachedFetchFileFromServerWorker = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee10(uri, username, repository, path, branchOrTag) {var failMessage, data;return _regenerator.default.wrap(function _callee10$(_context10) {while (1) {switch (_context10.prev = _context10.next) {case 0:_context10.next = 2;return failedStore.getItem(uri.toLowerCase());case 2:failMessage = _context10.sent;if (!failMessage) {_context10.next = 5;break;}return _context10.abrupt("return", null);case 5:_context10.prev = 5;_context10.next = 8;return cachedGetFileUsingPartialURL({ uri: uri });case 8:data = _context10.sent;return _context10.abrupt("return", data);case 12:_context10.prev = 12;_context10.t0 = _context10["catch"](5);console.error("cachedFetchFileFromServerWorker could not fetch ".concat(username, " ").concat(repository, " ").concat(branchOrTag, " ").concat(path, ": ").concat(_context10.t0)); /* await */failedStore.setItem(uri.toLowerCase(), _context10.t0.message);return _context10.abrupt("return", null);case 17:case "end":return _context10.stop();}}}, _callee10, null, [[5, 12]]);}));return _cachedFetchFileFromServerWorker.apply(this, arguments);} // } else { // ! repositoryExistsOnDoor43
//   console.error(`cachedFetchFileFromServerWorker repo ${username} '${repository}' does not exist!`);
//   /* await */ failedStore.setItem(uri.toLowerCase(), `Repo '${repository}' does not exist!`);
//   return null;
// }
;


/**
 *  older getFile without that doesn’t use the unzipStore
 * @param {string} username
 * @param {string} repository
 * @param {string} path
 * @param {string} branch
 * @return {Promise<*>}
 */
/*
async function cachedGetFileFromZipOrServer({ username, repository, path, branch }) {
  // functionLog(`cachedGetFileFromZipOrServer(${username}, ${repository}, ${path}, ${branch})…`);
  let file;
  file = await getFileFromZip({ username, repository, path, branch });
  if (!file) {
    file = await cachedFetchFileFromServerWithBranch({ username, repository, path, branch });
  }
  return file;
}
*/function

getUID(_x18) {return _getUID.apply(this, arguments);}function _getUID() {_getUID = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee11(_ref6) {var username, uri, user, uid;return _regenerator.default.wrap(function _callee11$(_context11) {while (1) {switch (_context11.prev = _context11.next) {case 0:username = _ref6.username;
            // functionLog(`getUID(${username})…`);
            uri = _path.default.join(API_PATH, 'users', username);
            // debugLog(`getUID uri=${uri}`);
            _context11.next = 4;return cachedGetFileUsingPartialURL({ uri: uri });case 4:user = _context11.sent;
            // debugLog(`getUID user=${user}`);
            uid = user.id;
            // debugLog(`  getUID returning: ${uid}`);
            return _context11.abrupt("return", uid);case 7:case "end":return _context11.stop();}}}, _callee11);}));return _getUID.apply(this, arguments);}function


repositoryExistsOnDoor43(_x19) {return _repositoryExistsOnDoor.apply(this, arguments);}function _repositoryExistsOnDoor() {_repositoryExistsOnDoor = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee12(_ref7) {var username, repository, uid, params, uri, retrievedRepoList, _yield$cachedGetFileU, retrievedRepoListData, desiredMatch, filteredRepoList;return _regenerator.default.wrap(function _callee12$(_context12) {while (1) {switch (_context12.prev = _context12.next) {case 0:username = _ref7.username, repository = _ref7.repository;_context12.prev = 1;_context12.next = 4;return (



              getUID({ username: username }));case 4:uid = _context12.sent;_context12.next = 11;break;case 7:_context12.prev = 7;_context12.t0 = _context12["catch"](1);

            console.error("repositoryExistsOnDoor43(".concat(username, ", ").concat(repository, ") - invalid username"), _context12.t0.message);return _context12.abrupt("return",
            false);case 11:

            // debugLog(`repositoryExistsOnDoor43 uid=${uid}`);
            // Default limit is 10 -- way too small
            params = { q: repository, limit: 500, uid: uid }; // Documentation says limit is 50, but larger numbers seem to work ok
            uri = _path.default.join(API_PATH, 'repos', "search");
            // debugLog(`repositoryExistsOnDoor43 uri=${uri}`);
            _context12.prev = 13;_context12.next = 16;return (

              cachedGetFileUsingPartialURL({ uri: uri, params: params }));case 16:_yield$cachedGetFileU = _context12.sent;retrievedRepoListData = _yield$cachedGetFileU.data;
            retrievedRepoList = retrievedRepoListData;_context12.next = 25;break;case 21:_context12.prev = 21;_context12.t1 = _context12["catch"](13);


            console.error("repositoryExistsOnDoor43(".concat(username, ", ").concat(repository, ") - error fetching repo list"), _context12.t1.message);return _context12.abrupt("return",
            false);case 25:if (!(


            retrievedRepoList.length < 1)) {_context12.next = 28;break;}
            (0, _utilities.userLog)("repositoryExistsOnDoor43(".concat(username, ", ").concat(repository, ") - no repos found"));return _context12.abrupt("return",
            false);case 28:

            // debugLog(`repositoryExistsOnDoor43 retrievedRepoList (${retrievedRepoList.length})=${JSON.stringify(retrievedRepoList)}`);
            // for (const thisRepo of retrievedRepoList) userLog(`  thisRepo (${JSON.stringify(Object.keys(thisRepo))}) =${JSON.stringify(thisRepo.name)}`);
            desiredMatch = "".concat(username, "/").concat(repository).toLowerCase();
            filteredRepoList = retrievedRepoList.filter(function (repo) {return repo.full_name.toLowerCase() === desiredMatch;});if (!(
            filteredRepoList.length < 1)) {_context12.next = 33;break;}
            (0, _utilities.userLog)("repositoryExistsOnDoor43(".concat(username, ", ").concat(repository, ") - repo not found ").concat(retrievedRepoList.length, " ").concat(filteredRepoList.length));return _context12.abrupt("return",
            false);case 33:return _context12.abrupt("return",



            true);case 34:case "end":return _context12.stop();}}}, _callee12, null, [[1, 7], [13, 21]]);}));return _repositoryExistsOnDoor.apply(this, arguments);}
;function


cachedGetFileUsingPartialURL(_x20) {return _cachedGetFileUsingPartialURL.apply(this, arguments);}function _cachedGetFileUsingPartialURL() {_cachedGetFileUsingPartialURL = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee13(_ref8) {var uri, params, response;return _regenerator.default.wrap(function _callee13$(_context13) {while (1) {switch (_context13.prev = _context13.next) {case 0:uri = _ref8.uri, params = _ref8.params;_context13.next = 3;return (


              Door43Api.get(DOOR43_BASE_URL + uri, { params: params }));case 3:response = _context13.sent;
            if (response.request.fromCache !== true) (0, _utilities.userLog)("  Door43Api downloaded Door43 ".concat(uri));
            // debugLog(`  cachedGetFileUsingPartialURL returning: ${JSON.stringify(response.data)}`);
            return _context13.abrupt("return", response.data);case 6:case "end":return _context13.stop();}}}, _callee13);}));return _cachedGetFileUsingPartialURL.apply(this, arguments);}
;function

cachedGetFileUsingFullURL(_x21) {return _cachedGetFileUsingFullURL.apply(this, arguments);}function _cachedGetFileUsingFullURL() {_cachedGetFileUsingFullURL = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee14(_ref9) {var uri, params, pictureContents, zipBlob, zip, zipPath, response;return _regenerator.default.wrap(function _callee14$(_context14) {while (1) {switch (_context14.prev = _context14.next) {case 0:uri = _ref9.uri, params = _ref9.params;if (!

            uri.startsWith('https://cdn.door43.org/obs/jpg/360px/obs')) {_context14.next = 29;break;}_context14.next = 4;return (

              getUnZippedPictureFile(uri));case 4:pictureContents = _context14.sent;if (!
            pictureContents) {_context14.next = 7;break;}return _context14.abrupt("return",

            pictureContents);case 7:_context14.next = 9;return (

              zipStore.getItem(OBS_PICTURE_ZIP_FILENAME));case 9:zipBlob = _context14.sent;_context14.prev = 10;if (!


            zipBlob) {_context14.next = 19;break;}_context14.next = 14;return (

              _jszip.default.loadAsync(zipBlob));case 14:zip = _context14.sent;
            // zip.forEach(function (relativePath) {
            // debugLog(`relPath=${relativePath}`); // Displays 'relPath=360px/obs-en-17-09.jpg'
            // })
            zipPath = uri.substring(31); // Drop https://cdn.door43.org/obs/jpg/ to get 360px/obs-en-01-05.jpg
            // debugLog(`  zipPath=${zipPath}`);
            _context14.next = 18;return zip.file(zipPath).async('string');case 18:pictureContents = _context14.sent;case 19:_context14.next = 25;break;case 21:_context14.prev = 21;_context14.t0 = _context14["catch"](10);




            if (_context14.t0.message.indexOf(' is null') < 0)
            console.error("cachedGetFileUsingPartialURL for ".concat(uri, " got: ").concat(_context14.t0.message));
            pictureContents = null;case 25:if (!




            pictureContents) {_context14.next = 29;break;}_context14.next = 28;return (

              unzipStore.setItem(uri, pictureContents));case 28:return _context14.abrupt("return",

            pictureContents);case 29:_context14.next = 31;return (



              Door43Api.get(uri, { params: params }));case 31:response = _context14.sent;
            if (response.request.fromCache !== true) (0, _utilities.userLog)("  Door43Api downloaded ".concat(uri));
            // debugLog(`  cachedGetFileUsingFullURL returning: ${response.data}`);
            return _context14.abrupt("return", response.data);case 34:case "end":return _context14.stop();}}}, _callee14, null, [[10, 21]]);}));return _cachedGetFileUsingFullURL.apply(this, arguments);}
;


/*
function fetchRepositoriesZipFiles({username, languageId, branch}) {
  const repositories = resourceRepositories({languageId});
  const promises = Object.values(repositories).map(repository => {
    return downloadRepositoryZipFile({username, repository, branch});
  });
  const zipArray = await Promise.all(promises);
  return zipArray;
};
*/


/**
 * retrieve repo as zip file
 * @param {string} username
 * @param {string} repository
 * @param {string} branch
 * @param {boolean} forceLoad - if not true, then use existing repo in zipstore
 * @return {Promise<[]|*[]>} resolves to true if downloaded
 */function
cachedGetRepositoryZipFile(_x22) {return _cachedGetRepositoryZipFile.apply(this, arguments);}function _cachedGetRepositoryZipFile() {_cachedGetRepositoryZipFile = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee15(_ref10) {var username,repository,branchOrRelease,forceLoad,zipBlob,_args15 = arguments;return _regenerator.default.wrap(function _callee15$(_context15) {while (1) {switch (_context15.prev = _context15.next) {case 0:username = _ref10.username, repository = _ref10.repository, branchOrRelease = _ref10.branchOrRelease;forceLoad = _args15.length > 1 && _args15[1] !== undefined ? _args15[1] : false;if (



            forceLoad) {_context15.next = 8;break;}_context15.next = 5;return (
              getZipFromStore(username, repository, branchOrRelease));case 5:zipBlob = _context15.sent;if (!
            zipBlob) {_context15.next = 8;break;}return _context15.abrupt("return",

            true);case 8:return _context15.abrupt("return",


            downloadRepositoryZipFile({ username: username, repository: repository, branchOrRelease: branchOrRelease }));case 9:case "end":return _context15.stop();}}}, _callee15);}));return _cachedGetRepositoryZipFile.apply(this, arguments);}
;function


downloadRepositoryZipFile(_x23) {return _downloadRepositoryZipFile.apply(this, arguments);}function _downloadRepositoryZipFile() {_downloadRepositoryZipFile = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee16(_ref11) {var username, repository, branchOrRelease, uri, response, zipArrayBuffer;return _regenerator.default.wrap(function _callee16$(_context16) {while (1) {switch (_context16.prev = _context16.next) {case 0:username = _ref11.username, repository = _ref11.repository, branchOrRelease = _ref11.branchOrRelease;
            (0, _utilities.functionLog)("downloadRepositoryZipFile(".concat(username, ", ").concat(repository, ", ").concat(branchOrRelease, ")\u2026"));
            // RJH removed this 2Oct2020 -- what’s the point -- it just slows things down --
            //      if it needs to be checked, should be checked before this point
            // const repoExists = await repositoryExistsOnDoor43({ username, repository });
            // if (!repoExists) {
            //   console.error(`downloadRepositoryZipFile(${username}, ${repository}, ${branchOrRelease}) -- repo doesn’t even exist`);
            //   return null;
            // }

            // Template is https://git.door43.org/{username}/{repository}/archive/{branchOrRelease}.zip
            uri = zipUri({ username: username, repository: repository, branchOrRelease: branchOrRelease });_context16.next = 5;return (
              fetch(uri));case 5:response = _context16.sent;if (!(
            response.status === 200 || response.status === 0)) {_context16.next = 15;break;}_context16.next = 9;return (
              response.arrayBuffer());case 9:zipArrayBuffer = _context16.sent;_context16.next = 12;return (
              zipStore.setItem(uri.toLowerCase(), zipArrayBuffer));case 12:return _context16.abrupt("return",

            true);case 15:

            console.error("downloadRepositoryZipFile(".concat(username, ", ").concat(repository, ", ").concat(branchOrRelease, ") -- got response status: ").concat(response.status));return _context16.abrupt("return",
            false);case 17:case "end":return _context16.stop();}}}, _callee16);}));return _downloadRepositoryZipFile.apply(this, arguments);}

;


/**
 * pull repo from zipstore and get a file list
 * @param {string} username
 * @param {string} repository
 * @param {string} branchOrRelease
 * @param {string} optionalPrefix - to filter by book, etc.
 * @return {Promise<[]|*[]>}  resolves to file list
 */function
getFileListFromZip(_x24) {return _getFileListFromZip.apply(this, arguments);}

















































/**
 * try to get zip file from cache
 * @param {string} username
 * @param {string} repository
 * @param {string} branchOrRelease
 * @return {Promise<unknown>} resolves to null if not found
 */function _getFileListFromZip() {_getFileListFromZip = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee17(_ref12) {var username, repository, branchOrRelease, optionalPrefix, uri, zipBlob, response, zipArrayBuffer, pathList, zip;return _regenerator.default.wrap(function _callee17$(_context17) {while (1) {switch (_context17.prev = _context17.next) {case 0:username = _ref12.username, repository = _ref12.repository, branchOrRelease = _ref12.branchOrRelease, optionalPrefix = _ref12.optionalPrefix; // functionLog(`getFileListFromZip(${username}, ${repository}, ${branchOrRelease}, ${optionalPrefix})…`);
            uri = zipUri({ username: username, repository: repository, branchOrRelease: branchOrRelease });_context17.next = 4;return getZipFromStore(username, repository, branchOrRelease);case 4:zipBlob = _context17.sent;if (zipBlob) {_context17.next = 20;break;}_context17.next = 8;return fetch(uri);case 8:response = _context17.sent;if (!(response.status === 200 || response.status === 0)) {_context17.next = 18;break;}_context17.next = 12;return response.arrayBuffer();case 12:zipArrayBuffer = _context17.sent;_context17.next = 15;return zipStore.setItem(uri.toLowerCase(), zipArrayBuffer);case 15:zipBlob = _context17.sent;_context17.next = 20;break;case 18:console.error("getFileListFromZip got response status: ".concat(response.status));return _context17.abrupt("return", []);case 20:pathList = [];_context17.prev = 21;if (!zipBlob) {_context17.next = 27;break;}_context17.next = 25;return _jszip.default.loadAsync(zipBlob);case 25:zip = _context17.sent; // debugLog(`  Got zip`);
            // Now we need to fetch the list of files from the repo
            // zip.forEach(function (relativePath, fileObject) {
            zip.forEach(function (relativePath) {// debugLog(`relPath=${relativePath}`)
              // consoleLogObject('fileObject', fileObject);
              if (!relativePath.endsWith('/')) // it’s not a folder
                {if (relativePath.startsWith("".concat(repository, "/"))) // remove repo name prefix
                    relativePath = relativePath.substring(repository.length + 1);if (relativePath.length && !relativePath.startsWith('.git') // skips files in these folders
                  && !relativePath.startsWith('.apps') // skips files in this folder
                  && (!optionalPrefix || relativePath.startsWith(optionalPrefix))) // it’s the correct prefix
                    pathList.push(relativePath);}});case 27:_context17.next = 32;break;case 29:_context17.prev = 29;_context17.t0 = _context17["catch"](21);console.error("getFileListFromZip got: ".concat(_context17.t0.message));case 32:return _context17.abrupt("return", pathList);case 33:case "end":return _context17.stop();}}}, _callee17, null, [[21, 29]]);}));return _getFileListFromZip.apply(this, arguments);}function getZipFromStore(_x25, _x26, _x27) {return _getZipFromStore.apply(this, arguments);} /**
 * pull repo from zipstore and get the unzipped file
 * @param {string} username
 * @param {string} repository
 * @param {string} branchOrRelease
 * @param {object} optionalPrefix
 * @return {Promise<[]|*[]>} resolves to unzipped file if found or null
 */function _getZipFromStore() {_getZipFromStore = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee18(username, repository, branchOrRelease) {var uri, zipBlob;return _regenerator.default.wrap(function _callee18$(_context18) {while (1) {switch (_context18.prev = _context18.next) {case 0: // functionLog(`getZipFromStore(${username}, ${repository}, ${branchOrRelease})…`);
            uri = zipUri({ username: username, repository: repository, branchOrRelease: branchOrRelease }); // debugLog(`  uri=${uri}`);
            _context18.next = 3;return zipStore.getItem(uri.toLowerCase());case 3:zipBlob = _context18.sent;return _context18.abrupt("return", zipBlob);case 5:case "end":return _context18.stop();}}}, _callee18);}));return _getZipFromStore.apply(this, arguments);}function getFileFromZip(_x28) {return _getFileFromZip.apply(this, arguments);}function _getFileFromZip() {_getFileFromZip = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee19(_ref13) {var username, repository, path, branchOrRelease, file, zipBlob, zip, zipPath;return _regenerator.default.wrap(function _callee19$(_context19) {while (1) {switch (_context19.prev = _context19.next) {case 0:username = _ref13.username, repository = _ref13.repository, path = _ref13.path, branchOrRelease = _ref13.branchOrRelease;_context19.next = 3;return (

              getZipFromStore(username, repository, branchOrRelease));case 3:zipBlob = _context19.sent;_context19.prev = 4;if (!

            zipBlob) {_context19.next = 13;break;}_context19.next = 8;return (

              _jszip.default.loadAsync(zipBlob));case 8:zip = _context19.sent;
            zipPath = _path.default.join(repository.toLowerCase(), path);
            // debugLog(`  zipPath=${zipPath}`);
            _context19.next = 12;return zip.file(zipPath).async('string');case 12:file = _context19.sent;case 13:_context19.next = 19;break;case 15:_context19.prev = 15;_context19.t0 = _context19["catch"](4);




            if (_context19.t0.message.indexOf(' is null') < 0)
            console.error("getFileFromZip for ".concat(username, " ").concat(repository, " ").concat(path, " ").concat(branchOrRelease, " got: ").concat(_context19.t0.message));
            file = null;case 19:return _context19.abrupt("return",

            file);case 20:case "end":return _context19.stop();}}}, _callee19, null, [[4, 15]]);}));return _getFileFromZip.apply(this, arguments);}
;


function zipUri(_ref14) {var username = _ref14.username,repository = _ref14.repository,_ref14$branchOrReleas = _ref14.branchOrRelease,branchOrRelease = _ref14$branchOrReleas === void 0 ? 'master' : _ref14$branchOrReleas;
  // functionLog(`zipUri(${username}, ${repository}, ${branchOrRelease})…`);
  var zipPath = _path.default.join(username, repository, 'archive', "".concat(branchOrRelease, ".zip"));
  var zipUri = DOOR43_BASE_URL + zipPath;
  return zipUri;
};


// async function fetchTree({ username, repository, sha = 'master' }) {
//   // functionLog(`fetchTree(${username}, ${repository}, ${sha})…`);
//   let data;
//   try {
//     const uri = Path.join('api/v1/repos', username, repository, 'git/trees', sha);
//     // debugLog(`  uri='${uri}'`);
//     data = await cachedGetFileUsingPartialURL({ uri });
//     // debugLog(`  data (${typeof data})`);
//     return data;
//     // const tree = JSON.parse(data); // RJH: Why was this here???
//     // debugLog(`  tree (${typeof tree})`);
//     // return tree;
//   } catch (error) {
//     console.error(`fetchTree got: ${error.message}`);
//     userLog(`  Data was: ${JSON.stringify(data)}`);
//     return null;
//   }
// };


/*
async function recursiveTree({username, repository, path, sha}) {
  userLog("recurse tree args:",username,repository,path,sha)
  let tree = {};
  const pathArray = path.split();
  const results = fetchTree({username, repository, sha});
  const result = results.tree.filter(item => item.path === pathArray[0])[0];
  if (result) {
    if (result.type === 'tree') {
      const childPath = pathArray.slice(1).join('/');
      const children = recursiveTree({username, repository, path: childPath, sha: result.sha});
      tree[result.path] = children;
    } else if (result.type === 'blob') {
      tree[result.path] = true;
    }
  }
};

async function fileExists({username, repository, path, branch}) {
  // get root listing
  recursiveTree()
  // get recursive path listing
}
*/
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9jb3JlL2dldEFwaS5qcyJdLCJuYW1lcyI6WyJNQVhfSU5ESVZJRFVBTF9GSUxFU19UT19ET1dOTE9BRCIsIkRPT1I0M19CQVNFX1VSTCIsIkFQSV9QQVRIIiwiT0JTX1BJQ1RVUkVfWklQX0ZJTEVOQU1FIiwiT0JTX1BJQ1RVUkVfWklQX1VSSSIsImZhaWxlZFN0b3JlIiwibG9jYWxmb3JhZ2UiLCJjcmVhdGVJbnN0YW5jZSIsImRyaXZlciIsIklOREVYRUREQiIsIm5hbWUiLCJ6aXBTdG9yZSIsImNhY2hlU3RvcmUiLCJ1bnppcFN0b3JlIiwiRG9vcjQzQXBpIiwiYmFzZVVSTCIsImNhY2hlIiwic3RvcmUiLCJtYXhBZ2UiLCJleGNsdWRlIiwicXVlcnkiLCJrZXkiLCJyZXEiLCJzZXJpYWxpemVkIiwicGFyYW1zIiwiVVJMU2VhcmNoUGFyYW1zIiwidG9TdHJpbmciLCJKU09OIiwic3RyaW5naWZ5IiwidXJsIiwiY2xlYXJDYWNoZXMiLCJjbGVhciIsImZvcm1SZXBvTmFtZSIsImxhbmd1YWdlQ29kZSIsInJlcG9Db2RlIiwicmVwb19sYW5ndWFnZUNvZGUiLCJyZXBvTmFtZSIsInRvTG93ZXJDYXNlIiwiZ2V0VW5aaXBwZWRGaWxlIiwicGF0aCIsImdldEl0ZW0iLCJjb250ZW50cyIsImdldFVuWmlwcGVkUGljdHVyZUZpbGUiLCJ1cmkiLCJjYWNoZWRHZXRGaWxlIiwidXNlcm5hbWUiLCJyZXBvc2l0b3J5IiwiYnJhbmNoIiwiZmlsZVBhdGgiLCJQYXRoIiwiam9pbiIsImdldEZpbGVGcm9tWmlwIiwiYnJhbmNoT3JSZWxlYXNlIiwiY2FjaGVkRmV0Y2hGaWxlRnJvbVNlcnZlcldpdGhCcmFuY2giLCJzZXRJdGVtIiwiY2FjaGVkR2V0TWFuaWZlc3QiLCJtYW5pZmVzdENvbnRlbnRzIiwiZm9ybURhdGEiLCJ5YW1sIiwicGFyc2UiLCJ5YW1sRXJyb3IiLCJjb25zb2xlIiwiZXJyb3IiLCJtZXNzYWdlIiwiY2FjaGVkR2V0Qm9va0ZpbGVuYW1lRnJvbU1hbmlmZXN0IiwiYm9va0lEIiwibWFuaWZlc3RKU09OIiwicHJvamVjdHMiLCJwcm9qZWN0RW50cnkiLCJpZGVudGlmaWVyIiwiYm9va1BhdGgiLCJzdGFydHNXaXRoIiwic3Vic3RyaW5nIiwicHJlbG9hZFJlcG9zSWZOZWNlc3NhcnkiLCJib29rSURMaXN0IiwicmVwb0xpc3QiLCJzdWNjZXNzIiwicmVwb3NfIiwiaW5jbHVkZXMiLCJ1bnNoaWZ0IiwiQXJyYXkiLCJpc0FycmF5IiwibGVuZ3RoIiwid2hpY2hUZXN0YW1lbnQiLCJib29rcyIsInRlc3RhbWVudCIsIm9yaWdMYW5nUmVwbyIsImFkanVzdGVkTGFuZ3VhZ2VDb2RlIiwiYWRqdXN0ZWRCcmFuY2hPclJlbGVhc2UiLCJhZGp1c3RlZFJlcG9Db2RlIiwiZW5kc1dpdGgiLCJjYWNoZWRHZXRSZXBvc2l0b3J5WmlwRmlsZSIsInppcEZldGNoU3VjY2VlZGVkIiwiemlwQmxvYiIsImZldGNoIiwicmVzcG9uc2UiLCJzdGF0dXMiLCJhcnJheUJ1ZmZlciIsInppcEFycmF5QnVmZmVyIiwiY2FjaGVkRmV0Y2hGaWxlRnJvbVNlcnZlcldvcmtlciIsImNhY2hlZEZldGNoRmlsZUZyb21TZXJ2ZXJXaXRoVGFnIiwidGFnIiwiYnJhbmNoT3JUYWciLCJmYWlsTWVzc2FnZSIsImNhY2hlZEdldEZpbGVVc2luZ1BhcnRpYWxVUkwiLCJkYXRhIiwiZ2V0VUlEIiwidXNlciIsInVpZCIsImlkIiwicmVwb3NpdG9yeUV4aXN0c09uRG9vcjQzIiwicSIsImxpbWl0IiwicmV0cmlldmVkUmVwb0xpc3REYXRhIiwicmV0cmlldmVkUmVwb0xpc3QiLCJkZXNpcmVkTWF0Y2giLCJmaWx0ZXJlZFJlcG9MaXN0IiwiZmlsdGVyIiwicmVwbyIsImZ1bGxfbmFtZSIsImdldCIsInJlcXVlc3QiLCJmcm9tQ2FjaGUiLCJjYWNoZWRHZXRGaWxlVXNpbmdGdWxsVVJMIiwicGljdHVyZUNvbnRlbnRzIiwiSlNaaXAiLCJsb2FkQXN5bmMiLCJ6aXAiLCJ6aXBQYXRoIiwiZmlsZSIsImFzeW5jIiwiaW5kZXhPZiIsImZvcmNlTG9hZCIsImdldFppcEZyb21TdG9yZSIsImRvd25sb2FkUmVwb3NpdG9yeVppcEZpbGUiLCJ6aXBVcmkiLCJnZXRGaWxlTGlzdEZyb21aaXAiLCJvcHRpb25hbFByZWZpeCIsInBhdGhMaXN0IiwiZm9yRWFjaCIsInJlbGF0aXZlUGF0aCIsInB1c2giXSwibWFwcGluZ3MiOiI0aENBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsd0M7OztBQUdBOztBQUVBLElBQU1BLGdDQUFnQyxHQUFHLENBQXpDLEMsQ0FBNEM7O0FBRTVDLElBQU1DLGVBQWUsR0FBRyx5QkFBeEI7QUFDQSxJQUFNQyxRQUFRLEdBQUcsUUFBakI7O0FBRUEsSUFBTUMsd0JBQXdCLEdBQUcsc0JBQWpDO0FBQ0EsSUFBTUMsbUJBQW1CLDRDQUFxQ0Qsd0JBQXJDLENBQXpCOzs7QUFHQTtBQUNBLElBQU1FLFdBQVcsR0FBR0MscUJBQVlDLGNBQVosQ0FBMkI7QUFDN0NDLEVBQUFBLE1BQU0sRUFBRSxDQUFDRixxQkFBWUcsU0FBYixDQURxQztBQUU3Q0MsRUFBQUEsSUFBSSxFQUFFLGlCQUZ1QyxFQUEzQixDQUFwQjs7O0FBS0E7QUFDQSxJQUFNQyxRQUFRLEdBQUdMLHFCQUFZQyxjQUFaLENBQTJCO0FBQzFDQyxFQUFBQSxNQUFNLEVBQUUsQ0FBQ0YscUJBQVlHLFNBQWIsQ0FEa0M7QUFFMUNDLEVBQUFBLElBQUksRUFBRSxjQUZvQyxFQUEzQixDQUFqQjs7O0FBS0E7QUFDQSxJQUFNRSxVQUFVLEdBQUdOLHFCQUFZQyxjQUFaLENBQTJCO0FBQzVDQyxFQUFBQSxNQUFNLEVBQUUsQ0FBQ0YscUJBQVlHLFNBQWIsQ0FEb0M7QUFFNUNDLEVBQUFBLElBQUksRUFBRSxjQUZzQyxFQUEzQixDQUFuQjs7O0FBS0E7QUFDQSxJQUFNRyxVQUFVLEdBQUdQLHFCQUFZQyxjQUFaLENBQTJCO0FBQzVDQyxFQUFBQSxNQUFNLEVBQUUsQ0FBQ0YscUJBQVlH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S0FBUiw4QkFBb0NqQixRQUFwQyxjQUFnREMsVUFBaEQsY0FBOERQLElBQTlELGNBQXNFYSxlQUF0RSxtQkFBOEYsY0FBTVcsT0FBcEc7QUFDRmtFLFlBQUFBLElBQUksR0FBRyxJQUFQLENBakJKOztBQW1CU0EsWUFBQUEsSUFuQlQsZ0Y7QUFvQkM7OztBQUdELFNBQVNNLE1BQVQsU0FBc0UsS0FBcEQxRixRQUFvRCxVQUFwREEsUUFBb0QsQ0FBMUNDLFVBQTBDLFVBQTFDQSxVQUEwQyxnQ0FBOUJNLGVBQThCLENBQTlCQSxlQUE4QixzQ0FBWixRQUFZO0FBQ3BFO0FBQ0EsTUFBTTRFLE9BQU8sR0FBRy9FLGNBQUtDLElBQUwsQ0FBVUwsUUFBVixFQUFvQkMsVUFBcEIsRUFBZ0MsU0FBaEMsWUFBOENNLGVBQTlDLFVBQWhCO0FBQ0EsTUFBTW1GLE1BQU0sR0FBR3RJLGVBQWUsR0FBRytILE9BQWpDO0FBQ0EsU0FBT08sTUFBUDtBQUNEOzs7QUFHRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBQYXRoIGZyb20gJ3BhdGgnO1xuaW1wb3J0IHlhbWwgZnJvbSAneWFtbCc7XG5pbXBvcnQgbG9jYWxmb3JhZ2UgZnJvbSAnbG9jYWxmb3JhZ2UnO1xuaW1wb3J0IHsgc2V0dXAgfSBmcm9tICdheGlvcy1jYWNoZS1hZGFwdGVyJztcbmltcG9ydCBKU1ppcCBmcm9tICdqc3ppcCc7XG5pbXBvcnQgKiBhcyBib29rcyBmcm9tICcuL2Jvb2tzJztcbmltcG9ydCB7IGNsZWFyQ2hlY2tlZEFydGljbGVDYWNoZSB9IGZyb20gJy4vbm90ZXMtbGlua3MtY2hlY2snO1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC12YXJzXG5pbXBvcnQgeyBmdW5jdGlvbkxvZywgZGVidWdMb2csIHVzZXJMb2csIHBhcmFtZXRlckFzc2VydCwgbG9naWNBc3NlcnQgfSBmcm9tICcuL3V0aWxpdGllcyc7XG5cblxuLy8gY29uc3QgR0VUQVBJX1ZFUlNJT05fU1RSSU5HID0gJzAuOC4xJztcblxuY29uc3QgTUFYX0lORElWSURVQUxfRklMRVNfVE9fRE9XTkxPQUQgPSA1OyAvLyBNb3JlIHRoYW4gdGhpcyBhbmQgaXQgZG93bmxvYWRzIHRoZSB6aXBmaWxlIGZvciB0aGUgZW50aXJlIHJlcG9cblxuY29uc3QgRE9PUjQzX0JBU0VfVVJMID0gJ2h0dHBzOi8vZ2l0LmRvb3I0My5vcmcvJztcbmNvbnN0IEFQSV9QQVRIID0gJ2FwaS92MSc7XG5cbmNvbnN0IE9CU19QSUNUVVJFX1pJUF9GSUxFTkFNRSA9ICdvYnMtaW1hZ2VzLTM2MHB4LnppcCc7XG5jb25zdCBPQlNfUElDVFVSRV9aSVBfVVJJID0gYGh0dHBzOi8vY2RuLmRvb3I0My5vcmcvb2JzL2pwZy8ke09CU19QSUNUVVJFX1pJUF9GSUxFTkFNRX1gO1xuXG5cbi8vIGNhY2hlcyBmYWlsZWQgaHR0cCBmaWxlIGZldGNoZXMgc28gd2UgZG9u4oCZdCB3YXN0ZSB0aW1lIHdpdGggcmVwZWF0ZWQgYXR0ZW1wdHNcbmNvbnN0IGZhaWxlZFN0b3JlID0gbG9jYWxmb3JhZ2UuY3JlYXRlSW5zdGFuY2Uoe1xuICBkcml2ZXI6IFtsb2NhbGZvcmFnZS5JTkRFWEVEREJdLFxuICBuYW1lOiAnQ1YtZmFpbGVkLXN0b3JlJyxcbn0pO1xuXG4vLyBjYWNoZXMgemlwIGZpbGUgZmV0Y2hlcyBkb25lIGJ5IGNhY2hlZEdldFJlcG9zaXRvcnlaaXBGaWxlKClcbmNvbnN0IHppcFN0b3JlID0gbG9jYWxmb3JhZ2UuY3JlYXRlSW5zdGFuY2Uoe1xuICBkcml2ZXI6IFtsb2NhbGZvcmFnZS5JTkRFWEVEREJdLFxuICBuYW1lOiAnQ1YtemlwLXN0b3JlJyxcbn0pO1xuXG4vLyBjYWNoZXMgaHR0cCBmaWxlIGZldGNoZXMgZG9uZSBieSBjYWNoZWRGZXRjaEZpbGVGcm9tU2VydmVyV2l0aEJyYW5jaCgpXG5jb25zdCBjYWNoZVN0b3JlID0gbG9jYWxmb3JhZ2UuY3JlYXRlSW5zdGFuY2Uoe1xuICBkcml2ZXI6IFtsb2NhbGZvcmFnZS5JTkRFWEVEREJdLFxuICBuYW1lOiAnQ1Ytd2ViLWNhY2hlJyxcbn0pO1xuXG4vLyBjYWNoZXMgdGhlIHVuemlwcGVkIGZpbGVzIHJlcXVlc3RlZCBzbyB3ZSBkb27igJl0IGRvIHJlcGVhdGVkIHVuemlwcGluZyBvZiB0aGUgc2FtZSBmaWxlIHdoaWNoIGlzIHNsb3cgaW4gSlNcbmNvbnN0IHVuemlwU3RvcmUgPSBsb2NhbGZvcmFnZS5jcmVhdGVJbnN0YW5jZSh7XG4gIGRyaXZlcjogW2xvY2FsZm9yYWdlLklOREVYRUREQl0sXG4gIG5hbWU6ICdDVi11bnppcC1zdG9yZScsXG59KTtcblxuLy8gQVBJIGZvciBodHRwIHJlcXVlc3RzXG4vLyBOT1RFOiBFdmVuIGlmIGRhdGEgZXhwaXJlcyBpbiB0aGlzIEF4aW9zQ2FjaGVBZGFwdGVyLCB0aGUgbG9jYWxmb3JhZ2UgY2FjaGVzIGRvbuKAmXQgaGF2ZSB0aGUgc2FtZSAvIGFueSBleHBpcnkgYWdlc1xuLy8gICAgICAgIChXZSBleHBlY3QgdGhlIHVzZXJzIG9mIHRoZSBkZW1vcyB0byBtYW51YWxseSBjbGVhciB0aGUgY2FjaGVzIHdoZW4gYW4gdXBkYXRlIGlzIHJlcXVpcmVkLilcbmNvbnN0IERvb3I0M0FwaSA9IHNldHVwKHtcbiAgYmFzZVVSTDogRE9PUjQzX0JBU0VfVVJMLFxuICBjYWNoZToge1xuICAgIHN0b3JlOiBjYWNoZVN0b3JlLFxuICAgIG1heEFnZTogMSAqIDYwICogNjAgKiAxMDAwLCAvLyAxIGhvdXIgKHVubGVzcyB0aGV5IG1hbnVhbGx5IGNsZWFyIHRoZSBjYWNoZSlcbiAgICBleGNsdWRlOiB7IHF1ZXJ5OiBmYWxzZSB9LFxuICAgIGtleTogcmVxID0+IHtcbiAgICAgIC8vIGlmIChyZXEucGFyYW1zKSBkZWJ1Z2dlclxuICAgICAgbGV0IHNlcmlhbGl6ZWQgPSByZXEucGFyYW1zIGluc3RhbmNlb2YgVVJMU2VhcmNoUGFyYW1zID9cbiAgICAgICAgcmVxLnBhcmFtcy50b1N0cmluZygpIDogSlNPTi5zdHJpbmdpZnkocmVxLnBhcmFtcykgfHwgJyc7XG4gICAgICByZXR1cm4gcmVxLnVybCArIHNlcmlhbGl6ZWQ7XG4gICAgfSxcbiAgfSxcbn0pO1xuXG5cbi8qKlxuICogQ2xlYXIgYWxsIHRoZSBsb2NhbGZvcmFnZS5JTkRFWEVEREIgc3RvcmVzXG4gKiBAcmV0dXJuIHtQcm9taXNlPHZvaWQ+fVxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gY2xlYXJDYWNoZXMoKSB7XG4gIHVzZXJMb2coXCJDbGVhcmluZyBhbGwgZm91ciBDViBsb2NhbGZvcmFnZS5JTkRFWEVEREIgY2FjaGVz4oCmXCIpO1xuICAvLyBjb25zdCB0YXNrcyA9IFt6aXBTdG9yZSwgY2FjaGVTdG9yZV0ubWFwKGxvY2FsZm9yYWdlLmNsZWFyKTtcbiAgLy8gY29uc3QgcmVzdWx0cyA9IGF3YWl0IFByb21pc2UuYWxsKHRhc2tzKTtcbiAgLy8gcmVzdWx0cy5mb3JFYWNoKHggPT4gdXNlckxvZyhcIkRvbmUgaXRcIiwgeCkpO1xuICBhd2FpdCBmYWlsZWRTdG9yZS5jbGVhcigpO1xuICBhd2FpdCB6aXBTdG9yZS5jbGVhcigpO1xuICBhd2FpdCBjYWNoZVN0b3JlLmNsZWFyKCk7IC8vIFRoaXMgaXMgdGhlIG9uZSB1c2VkIGJ5IHRoZSBBeGlvbiBEb29yNDNBcGkgKGFib3ZlKVxuICBhd2FpdCB1bnppcFN0b3JlLmNsZWFyKCk7XG4gIGF3YWl0IGNsZWFyQ2hlY2tlZEFydGljbGVDYWNoZSgpOyAvLyBVc2VkIGZvciBjaGVja2luZyBUQSBhbmQgVFcgYXJ0aWNsZXMgcmVmZXJyZWQgdG8gYnkgVE4gbGlua3Ncbn1cblxuXG4vKipcbiAqIEBkZXNjcmlwdGlvbiAtIEZvcm1zIGFuZCByZXR1cm5zIGEgRG9vcjQzIHJlcG9OYW1lIHN0cmluZ1xuICogQHBhcmFtIHtzdHJpbmd9IGxhbmd1YWdlQ29kZSAtIHRoZSBsYW5ndWFnZSBjb2RlLCBlLmcuLCAnZW4nXG4gKiBAcGFyYW0ge3N0cmluZ30gcmVwb0NvZGUgLSB0aGUgcmVwbyBjb2RlLCBlLmcuLCAnVFEyJ1xuICogQHJldHVybiB7U3RyaW5nfSAtIHRoZSBEb29yNDMgcmVwb05hbWUgc3RyaW5nXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmb3JtUmVwb05hbWUobGFuZ3VhZ2VDb2RlLCByZXBvQ29kZSkge1xuICAvLyAgICB1c2VyTG9nKGBmb3JtUmVwb05hbWUoJyR7bGFuZ3VhZ2VDb2RlfScsICcke3JlcG9Db2RlfScp4oCmYCk7XG5cbiAgLy8gVE9ETzogU2hvdWxkIHdlIGFsc28gY2hlY2sgdGhlIHVzZXJuYW1lICd1bmZvbGRpbmdXb3JkJyBhbmQvb3IgJ0Rvb3I0My1DYXRhbG9nJyBoZXJlPz8/XG4gIC8vICAgICAgICAoV2UgZG9u4oCZdCBjdXJyZW50bHkgaGF2ZSB0aGUgdXNlcm5hbWUgYXZhaWxhYmxlIGluIHRoaXMgZnVuY3Rpb24uKVxuICBpZiAocmVwb0NvZGUgPT09ICdMVCcpIHJlcG9Db2RlID0gbGFuZ3VhZ2VDb2RlID09PSAnZW4nID8gJ1VMVCcgOiAnR0xUJztcbiAgaWYgKHJlcG9Db2RlID09PSAnU1QnKSByZXBvQ29kZSA9IGxhbmd1YWdlQ29kZSA9PT0gJ2VuJyA/ICdVU1QnIDogJ0dTVCc7XG5cbiAgbGV0IHJlcG9fbGFuZ3VhZ2VDb2RlID0gbGFuZ3VhZ2VDb2RlO1xuICBpZiAocmVwb0NvZGUgPT09ICdVSEInKSByZXBvX2xhbmd1YWdlQ29kZSA9ICdoYm8nO1xuICBlbHNlIGlmIChyZXBvQ29kZSA9PT0gJ1VHTlQnKSByZXBvX2xhbmd1YWdlQ29kZSA9ICdlbC14LWtvaW5lJztcblxuICBsZXQgcmVwb05hbWU7XG5cbiAgLy8gaWYgKHJlcG9Db2RlLmVuZHNXaXRoKCcyJykpIHJlcG9Db2RlID0gcmVwb0NvZGUuc3Vic3RyaW5nKDAsIHJlcG9Db2RlLmxlbmd0aCAtIDEpO1xuICByZXBvTmFtZSA9IGAke3JlcG9fbGFuZ3VhZ2VDb2RlfV8ke3JlcG9Db2RlLnRvTG93ZXJDYXNlKCl9YDtcbiAgcmV0dXJuIHJlcG9OYW1lO1xufVxuXG5cbi8qKlxuICogYWRkIG5ldyByZXBvIHRvIGxpc3QgaWYgbWlzc2luZ1xuICogQHBhcmFtIHJlcG9zXG4gKiBAcGFyYW0gbmV3UmVwb1xuICovXG4vKlxuZnVuY3Rpb24gYWRkVG9MaXN0SWZNaXNzaW5nKHJlcG9zLCBuZXdSZXBvKSB7XG4gIGlmICghcmVwb3MuaW5jbHVkZXMobmV3UmVwbykpIHtcbiAgICByZXBvcy51bnNoaWZ0KG5ld1JlcG8pO1xuICB9XG59XG4qL1xuXG5cbi8qKlxuICogdHJ5IHRvIGdldCBwcmV2aW91c2x5IHVuemlwcGVkIGZpbGUgZnJvbSBjYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IHBhdGhcbiAqIEByZXR1cm4ge1Byb21pc2U8dW5rbm93bj59IHJlc29sdmVzIHRvIGZpbGUgY29udGVudHMgb3IgbnVsbCBpZiBub3QgZm91bmRcbiAqL1xuYXN5bmMgZnVuY3Rpb24gZ2V0VW5aaXBwZWRGaWxlKHBhdGgpIHtcbiAgLy8gZnVuY3Rpb25Mb2coYGdldFVuWmlwcGVkRmlsZSgke3BhdGh9KWApO1xuICAvLyBUT0RPOiBXaHkgZGlkIHdlIG5lZWQgdG8gbG93ZXJDYXNlIGl0IGhlcmUgPz8/XG4gIGNvbnN0IGNvbnRlbnRzID0gYXdhaXQgdW56aXBTdG9yZS5nZXRJdGVtKHBhdGgudG9Mb3dlckNhc2UoKSk7XG4gIHJldHVybiBjb250ZW50cztcbn1cblxuLyoqXG4gKiB0cnkgdG8gZ2V0IHByZXZpb3VzbHkgdW56aXBwZWQgcGljdHVyZSBmaWxlIGZyb20gY2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSB1cmlcbiAqIEByZXR1cm4ge1Byb21pc2U8dW5rbm93bj59IHJlc29sdmVzIHRvIGZpbGUgY29udGVudHMgb3IgbnVsbCBpZiBub3QgZm91bmRcbiAqL1xuYXN5bmMgZnVuY3Rpb24gZ2V0VW5aaXBwZWRQaWN0dXJlRmlsZSh1cmkpIHtcbiAgLy8gZnVuY3Rpb25Mb2coYGdldFVuWmlwcGVkUGljdHVyZUZpbGUoJHt1cml9KWApO1xuICBjb25zdCBjb250ZW50cyA9IGF3YWl0IHVuemlwU3RvcmUuZ2V0SXRlbSh1cmkpO1xuICByZXR1cm4gY29udGVudHM7XG59XG5cblxuLyoqXG4gKiBzZWFyY2hlcyBmb3IgZmlsZXMgaW4gdGhpcyBvcmRlcjpcbiAqICAgLSBjYWNoZSBvZiB1bmNvbXByZXNzZWQgZmlsZXMgKHVuemlwU3RvcmUpXG4gKiAgIC0gY2FjaGUgb2YgemlwcGVkIHJlcG9zICh6aXBTdG9yZSlcbiAqICAgLSBhbmQgZmluYWxseSBjYWxscyBjYWNoZWRGZXRjaEZpbGVGcm9tU2VydmVyV2l0aEJyYW5jaCgpIHdoaWNoIGZpcnN0IGNoZWNrcyBpbiBjYWNoZVN0b3JlIHRvIHNlZSBpZiBhbHJlYWR5IGZldGNoZWQuICogQHBhcmFtIHtzdHJpbmd9IHVzZXJuYW1lXG4gKiBAcGFyYW0ge3N0cmluZ30gcmVwb3NpdG9yeVxuICogQHBhcmFtIHtzdHJpbmd9IHBhdGhcbiAqIEBwYXJhbSB7c3RyaW5nfSBicmFuY2hcbiAqIEByZXR1cm4ge1Byb21pc2U8Kj59XG4gKi9cbi8vIFRoaXMgaXMgdGhlIGZ1bmN0aW9uIHRoYXQgd2UgY2FsbCB0aGUgbW9zdCBmcm9tIHRoZSBvdXRzaWRlXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gY2FjaGVkR2V0RmlsZSh7IHVzZXJuYW1lLCByZXBvc2l0b3J5LCBwYXRoLCBicmFuY2ggfSkge1xuICAvLyBmdW5jdGlvbkxvZyhgY2FjaGVkR2V0RmlsZSgke3VzZXJuYW1lfSwgJHtyZXBvc2l0b3J5fSwgJHtwYXRofSwgJHticmFuY2h9KeKApmApO1xuICAvL3BhcmFtZXRlckFzc2VydCh0eXBlb2YgdXNlcm5hbWUgPT09ICdzdHJpbmcnICYmIHVzZXJuYW1lLmxlbmd0aCwgYGNhY2hlZEdldEZpbGU6IHVzZXJuYW1lIHBhcmFtZXRlciBzaG91bGQgYmUgYSBub24tZW1wdHkgc3RyaW5nIG5vdCAke3R5cGVvZiB1c2VybmFtZX06ICR7dXNlcm5hbWV9YCk7XG4gIC8vcGFyYW1ldGVyQXNzZXJ0KHR5cGVvZiByZXBvc2l0b3J5ID09PSAnc3RyaW5nJyAmJiByZXBvc2l0b3J5Lmxlbmd0aCwgYGNhY2hlZEdldEZpbGU6IHJlcG9zaXRvcnkgcGFyYW1ldGVyIHNob3VsZCBiZSBhIG5vbi1lbXB0eSBzdHJpbmcgbm90ICR7dHlwZW9mIHJlcG9zaXRvcnl9OiAke3JlcG9zaXRvcnl9YCk7XG4gIC8vcGFyYW1ldGVyQXNzZXJ0KHR5cGVvZiBwYXRoID09PSAnc3RyaW5nJyAmJiBwYXRoLmxlbmd0aCwgYGNhY2hlZEdldEZpbGU6IHBhdGggcGFyYW1ldGVyIHNob3VsZCBiZSBhIG5vbi1lbXB0eSBzdHJpbmcgbm90ICR7dHlwZW9mIHBhdGh9OiAke3BhdGh9YCk7XG4gIC8vcGFyYW1ldGVyQXNzZXJ0KHR5cGVvZiBicmFuY2ggPT09ICdzdHJpbmcnICYmIGJyYW5jaC5sZW5ndGgsIGBjYWNoZWRHZXRGaWxlOiBicmFuY2ggcGFyYW1ldGVyIHNob3VsZCBiZSBhIG5vbi1lbXB0eSBzdHJpbmcgbm90ICR7dHlwZW9mIGJyYW5jaH06ICR7YnJhbmNofWApO1xuXG4gIGNvbnN0IGZpbGVQYXRoID0gUGF0aC5qb2luKHVzZXJuYW1lLCByZXBvc2l0b3J5LCBwYXRoLCBicmFuY2gpO1xuICBsZXQgY29udGVudHMgPSBhd2FpdCBnZXRVblppcHBlZEZpbGUoZmlsZVBhdGgpO1xuICBpZiAoY29udGVudHMpIHtcbiAgICAvLyBkZWJ1Z0xvZyhgY2FjaGVkR2V0RmlsZSBnb3QgJHtmaWxlUGF0aH0gZnJvbSB1bnppcHBlZCBjYWNoZWApO1xuICAgIHJldHVybiBjb250ZW50cztcbiAgfVxuXG4gIGNvbnRlbnRzID0gYXdhaXQgZ2V0RmlsZUZyb21aaXAoeyB1c2VybmFtZSwgcmVwb3NpdG9yeSwgcGF0aCwgYnJhbmNoT3JSZWxlYXNlOiBicmFuY2ggfSk7XG4gIC8vIGlmIChjb250ZW50cylcbiAgLy8gICBpZiAoZmlsZVBhdGguaW5kZXhPZignX3RxLycpIDwgMCkgLy8gRG9u4oCZdCBsb2cgZm9yIFRRMiBmaWxlcyBjb3ogdG9vIG1hbnlcbiAgLy8gICAgIHVzZXJMb2coYCAgY2FjaGVkR2V0RmlsZSBnb3QgJHtmaWxlUGF0aH0gZnJvbSB6aXBmaWxlYCk7XG4gIGlmICghY29udGVudHMpIHtcbiAgICBjb250ZW50cyA9IGF3YWl0IGNhY2hlZEZldGNoRmlsZUZyb21TZXJ2ZXJXaXRoQnJhbmNoKHsgdXNlcm5hbWUsIHJlcG9zaXRvcnksIHBhdGgsIGJyYW5jaCB9KTtcbiAgfVxuXG4gIGlmIChjb250ZW50cykge1xuICAgIC8vIHNhdmUgdW56aXBwZWQgZmlsZSBpbiBjYWNoZSB0byBzcGVlZCBsYXRlciByZXRyaWV2YWxcbiAgICBhd2FpdCB1bnppcFN0b3JlLnNldEl0ZW0oZmlsZVBhdGgudG9Mb3dlckNhc2UoKSwgY29udGVudHMpO1xuICAgIC8vIGlmIChmaWxlUGF0aC5pbmRleE9mKCdfdHEvJykgPCAwKSAvLyBEb27igJl0IGxvZyBmb3IgVFEyIGZpbGVzIGNveiB0b28gbWFueVxuICAgIC8vICAgdXNlckxvZyhgY2FjaGVkR2V0RmlsZSBzYXZlZCAke2ZpbGVQYXRofSB0byBjYWNoZSBmb3IgbmV4dCB0aW1lYCk7XG4gIH1cbiAgLy8gZWxzZSBjb25zb2xlLmVycm9yKGBjYWNoZWRHZXRGaWxlKCR7dXNlcm5hbWV9LCAke3JlcG9zaXRvcnl9LCAke3BhdGh9LCAke2JyYW5jaH0pIC0tIGZhaWxlZCB0byBnZXQgZmlsZWApO1xuXG4gIHJldHVybiBjb250ZW50cztcbn1cblxuXG4vKipcbiAqIFJldHJpZXZlIG1hbmlmZXN0LnlhbWwgZnJvbSByZXF1ZXN0ZWQgcmVwb1xuICogQHBhcmFtIHtzdHJpbmd9IHVzZXJuYW1lXG4gKiBAcGFyYW0ge3N0cmluZ30gcmVwb3NpdG9yeVxuICogQHBhcmFtIHtzdHJpbmd9IGJyYW5jaFxuICogQHJldHVybiB7UHJvbWlzZTxbXXwqW10+fSByZXNvbHZlcyB0byBtYW5pZmVzdCBjb250ZW50cyBpZiBkb3dubG9hZGVkIChlbHNlIHVuZGVmaW5lZClcbiAqL1xuYXN5bmMgZnVuY3Rpb24gY2FjaGVkR2V0TWFuaWZlc3QoeyB1c2VybmFtZSwgcmVwb3NpdG9yeSwgYnJhbmNoIH0pIHtcbiAgLy8gZnVuY3Rpb25Mb2coYGNhY2hlZEdldE1hbmlmZXN0KCR7dXNlcm5hbWV9LCAke3JlcG9zaXRvcnl9LCAke2JyYW5jaH0p4oCmYCk7XG5cbiAgY29uc3QgbWFuaWZlc3RDb250ZW50cyA9IGF3YWl0IGNhY2hlZEdldEZpbGUoeyB1c2VybmFtZSwgcmVwb3NpdG9yeSwgcGF0aDogJ21hbmlmZXN0LnlhbWwnLCBicmFuY2ggfSk7XG4gIGxldCBmb3JtRGF0YTtcbiAgdHJ5IHtcbiAgICBmb3JtRGF0YSA9IHlhbWwucGFyc2UobWFuaWZlc3RDb250ZW50cyk7XG4gICAgLy8gZGVidWdMb2coXCJ5YW1sLnBhcnNlKFlBTUxUZXh0KSBnb3QgZm9ybURhdGFcIiwgSlNPTi5zdHJpbmdpZnkoZm9ybURhdGEpKTtcbiAgfVxuICBjYXRjaCAoeWFtbEVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcihgJHt1c2VybmFtZX0gJHtyZXBvc2l0b3J5fSAke2JyYW5jaH0gbWFuaWZlc3QgeWFtbCBwYXJzZSBlcnJvcjogJHt5YW1sRXJyb3IubWVzc2FnZX1gKTtcbiAgfVxuICByZXR1cm4gZm9ybURhdGE7XG59XG5cblxuLyoqXG4gKiBSZXRyaWV2ZSBtYW5pZmVzdC55YW1sIGZyb20gcmVxdWVzdGVkIHJlcG9cbiAqIEBwYXJhbSB7c3RyaW5nfSB1c2VybmFtZVxuICogQHBhcmFtIHtzdHJpbmd9IHJlcG9zaXRvcnlcbiAqIEBwYXJhbSB7c3RyaW5nfSBicmFuY2hcbiAqIEBwYXJhbSB7c3RyaW5nfSBib29rSUQgLS0gMy1jaGFyYWN0ZXIgVVNGTSBib29rIGNvZGVcbiAqIEByZXR1cm4ge1Byb21pc2U8W118KltdPn0gcmVzb2x2ZXMgdG8gZmlsZW5hbWUgZnJvbSB0aGUgbWFuaWZlc3QgZm9yIHRoZSBib29rIChlbHNlIHVuZGVmaW5lZClcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGNhY2hlZEdldEJvb2tGaWxlbmFtZUZyb21NYW5pZmVzdCh7IHVzZXJuYW1lLCByZXBvc2l0b3J5LCBicmFuY2gsIGJvb2tJRCB9KSB7XG4gIC8vIGZ1bmN0aW9uTG9nKGBjYWNoZWRHZXRCb29rRmlsZW5hbWVGcm9tTWFuaWZlc3QoJHt1c2VybmFtZX0sICR7cmVwb3NpdG9yeX0sICR7YnJhbmNofSwgJHtib29rSUR9KeKApmApO1xuICBjb25zdCBtYW5pZmVzdEpTT04gPSBhd2FpdCBjYWNoZWRHZXRNYW5pZmVzdCh7IHVzZXJuYW1lLCByZXBvc2l0b3J5LCBicmFuY2ggfSk7XG4gIGZvciAoY29uc3QgcHJvamVjdEVudHJ5IG9mIG1hbmlmZXN0SlNPTi5wcm9qZWN0cykge1xuICAgIGlmIChwcm9qZWN0RW50cnkuaWRlbnRpZmllciA9PT0gYm9va0lEKSB7XG4gICAgICBsZXQgYm9va1BhdGggPSBwcm9qZWN0RW50cnkucGF0aDtcbiAgICAgIGlmIChib29rUGF0aC5zdGFydHNXaXRoKCcuLycpKSBib29rUGF0aCA9IGJvb2tQYXRoLnN1YnN0cmluZygyKTtcbiAgICAgIHJldHVybiBib29rUGF0aDtcbiAgICB9XG4gIH1cbn1cblxuXG4vKipcbiAqIFByZWxvYWRzIGFueSBuZWNlc3NhcnkgcmVwbyB6aXBzLCBiZWZvcmUgcnVubmluZyBib29rIHBhY2thZ2UgY2hlY2tzXG4gKiAgIFRoaXMgYWxsb3dzIHRoZSBjYWxsaW5nIGFwcCB0byBjbGVhciBjYWNoZSBhbmQgc3RhcnQgbG9hZGluZyByZXBvcyBpbiB0aGUgYmFja2dvdW5kIGFzIHNvb24gYXMgaXQgc3RhcnRzIHVwLlxuICogICAgICBJbiB0aGlzIGNhc2UgaXQgd291bGQgbm90IG5lZWQgdG8gdXNlIGF3YWl0IHRvIHdhaXQgZm9yIHJlc3VsdHMuXG4gKiAgIFRSSUNLWTogbm90ZSB0aGF0IGV2ZW4gaWYgdGhlIHVzZXIgaXMgc3VwZXIgZmFzdCBpbiBzZWxlY3RpbmcgYm9va3MgYW5kIGNsaWNraW5nIG5leHQsIGl0IHdpbGwgbm90IGh1cnQgYW55dGhpbmcuXG4gKiAgICAgICAgICAgIGNhY2hlZEdldEZpbGVGcm9tWmlwT3JTZXJ2ZXIoKSB3b3VsZCBqdXN0IGJlIGZldGNoaW5nIGZpbGVzIGRpcmVjdGx5IGZyb20gcmVwbyB1bnRpbCB0aGUgemlwcyBhcmUgbG9hZGVkLlxuICogICAgICAgICAgICBBZnRlciB0aGF0IHRoZSBmaWxlcyB3b3VsZCBiZSBwdWxsZWQgb3V0IG9mIHppcFN0b3JlLlxuICogQHBhcmFtIHtzdHJpbmd9IHVzZXJuYW1lXG4gKiBAcGFyYW0ge3N0cmluZ30gbGFuZ3VhZ2VDb2RlXG4gKiBAcGFyYW0ge0FycmF5fSBib29rSURMaXN0IC0gb25lIG9yIG1vcmUgYm9va3MgdGhhdCB3aWxsIGJlIGNoZWNrZWRcbiAqIEBwYXJhbSB7c3RyaW5nfSBicmFuY2ggLSBvcHRpb25hbCwgZGVmYXVsdHMgdG8gbWFzdGVyXG4gKiBAcGFyYW0ge0FycmF5fSByZXBvTGlzdCAtIG9wdGlvbmFsLCBsaXN0IG9mIHJlcG9zIHRvIHByZS1sb2FkXG4gKiBAcmV0dXJuIHtQcm9taXNlPEJvb2xlYW4+fSByZXNvbHZlcyB0byB0cnVlIGlmIGZpbGUgbG9hZHMgYXJlIHN1Y2Nlc3NmdWxcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHByZWxvYWRSZXBvc0lmTmVjZXNzYXJ5KHVzZXJuYW1lLCBsYW5ndWFnZUNvZGUsIGJvb2tJRExpc3QsIGJyYW5jaE9yUmVsZWFzZSwgcmVwb0xpc3QpIHtcbiAgLy8gTk9URTogV2UgcHJlbG9hZCBUQSBhbmQgVFcgYnkgZGVmYXVsdCBiZWNhdXNlIHdlIGFyZSBsaWtlbHkgdG8gaGF2ZSBtYW55IGxpbmtzIHRvIHRob3NlIHJlcG9zXG4gIC8vICAgICAgICBXZSBwcmVsb2FkIFRRIGJ5IGRlZmF1bHQgYmVjYXVzZSBpdCBoYXMgdGhvdXNhbmRzIG9mIGZpbGVzICgxNywzMzcpLCBzbyBpbmRpdmlkdWFsIGZpbGUgZmV0Y2hlcyBtaWdodCBiZSBzbG93XG4gIC8vICAgICAgICAgIGV2ZW4gZm9yIG9uZSBib29rIHdoaWNoIG1pZ2h0IGhhdmUgc2V2ZXJhbCBodW5kcmVkIGZpbGVzLlxuICAvLyBmdW5jdGlvbkxvZyhgcHJlbG9hZFJlcG9zSWZOZWNlc3NhcnkoJHt1c2VybmFtZX0sICR7bGFuZ3VhZ2VDb2RlfSwgJHtib29rSURMaXN0fSAoJHt0eXBlb2YgYm9va0lEfSksICR7YnJhbmNoT3JSZWxlYXNlfSwgWyR7cmVwb0xpc3R9XSnigKZgKTtcbiAgbGV0IHN1Y2Nlc3MgPSB0cnVlO1xuXG4gIGNvbnN0IHJlcG9zXyA9IFsuLi5yZXBvTGlzdF07XG4gIGlmIChib29rSURMaXN0LmluY2x1ZGVzKCdPQlMnKSkge1xuICAgIGlmICghcmVwb3NfLmluY2x1ZGVzKCdPQlMnKSlcbiAgICAgIHJlcG9zXy51bnNoaWZ0KCdPQlMnKTsgLy8gcHVzaCB0byBiZWdpbm5pbmcgb2YgbGlzdFxuICB9XG4gIGlmIChib29rSURMaXN0ICYmIEFycmF5LmlzQXJyYXkoYm9va0lETGlzdCkgJiYgYm9va0lETGlzdC5sZW5ndGggPiBNQVhfSU5ESVZJRFVBTF9GSUxFU19UT19ET1dOTE9BRCkgeyAvLyBGZXRjaCBpbmRpdmlkdWFsbHkgaWYgY2hlY2tpbmcgbGVzcyBib29rc1xuICAgIC8vIG1ha2Ugc3VyZSB3ZSBoYXZlIHRoZSBvcmlnaW5hbCBsYW5ndWFnZXMgbmVlZGVkXG4gICAgZm9yIChjb25zdCBib29rSUQgb2YgYm9va0lETGlzdCkge1xuICAgICAgaWYgKGJvb2tJRCAhPT0gJ09CUycpIHtcbiAgICAgICAgY29uc3Qgd2hpY2hUZXN0YW1lbnQgPSBib29rcy50ZXN0YW1lbnQoYm9va0lEKTsgLy8gcmV0dXJucyAnb2xkJyBvciAnbmV3J1xuICAgICAgICBsb2dpY0Fzc2VydCh3aGljaFRlc3RhbWVudCA9PT0gJ29sZCcgfHwgd2hpY2hUZXN0YW1lbnQgPT09ICduZXcnLCBgcHJlbG9hZFJlcG9zSWZOZWNlc3NhcnkoKSBjb3VsZG4ndCBmaW5kIHRlc3RhbWVudCBmb3IgJyR7Ym9va0lEfSdgKTtcbiAgICAgICAgY29uc3Qgb3JpZ0xhbmdSZXBvID0gd2hpY2hUZXN0YW1lbnQgPT09ICdvbGQnID8gJ1VIQicgOiAnVUdOVCc7XG4gICAgICAgIGlmICghcmVwb3NfLmluY2x1ZGVzKG9yaWdMYW5nUmVwbykpXG4gICAgICAgICAgcmVwb3NfLnVuc2hpZnQob3JpZ0xhbmdSZXBvKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLy8gZGVidWdMb2coYCAgQWRqdXN0ZWQgcmVwbyBsaXN0OiAoJHtyZXBvc18ubGVuZ3RofSkgJHtKU09OLnN0cmluZ2lmeShyZXBvc18pfWApO1xuXG4gIC8vIC8vIFNlZSBpZiB0aGUgcmVxdWlyZWQgcmVwb3MgYXJlIHRoZXJlIGFscmVhZHlcbiAgLy8gZGVidWdMb2coYENoZWNrIGlmIG5lZWQgdG8gcHJlbG9hZCAke3JlcG9zXy5sZW5ndGh9IHJlcG9zOiAke3JlcG9zX31gKVxuICAvLyBjb25zdCBuZXdSZXBvTGlzdCA9IFtdO1xuICAvLyBmb3IgKGNvbnN0IHJlcG9Db2RlIG9mIHJlcG9zXykge1xuICAvLyAgIGNvbnN0IHJlcG9OYW1lID0gZm9ybVJlcG9OYW1lKGxhbmd1YWdlQ29kZSwgcmVwb0NvZGUpO1xuICAvLyAgIC8vIGRlYnVnTG9nKGBwcmVsb2FkUmVwb3NJZk5lY2Vzc2FyeTogY2hlY2tpbmcgemlwIGZpbGUgZm9yICR7cmVwb05hbWV94oCmYCk7XG4gIC8vICAgY29uc3QgdXJpID0gemlwVXJpKHsgdXNlcm5hbWUsIHJlcG9zaXRvcnk6IHJlcG9OYW1lLCBicmFuY2hPclJlbGVhc2UgfSk7XG4gIC8vICAgY29uc3QgemlwQmxvYiA9IGF3YWl0IHppcFN0b3JlLmdldEl0ZW0odXJpLnRvTG93ZXJDYXNlKCkpO1xuICAvLyAgIGlmICghemlwQmxvYikgbmV3UmVwb0xpc3QucHVzaChyZXBvQ29kZSk7XG4gIC8vIH1cblxuICAvLyBpZiAobmV3UmVwb0xpc3QubGVuZ3RoKSB7IC8vIEZldGNoIHppcHBlZCB2ZXJzaW9ucyBvZiBhbGwgdGhlIHJlcG9zIG5lZWRpbmcgdG8gYmUgcHJlbG9hZGVkXG4gIC8vICAgdXNlckxvZyhgTmVlZCB0byBwcmVsb2FkICR7bmV3UmVwb0xpc3QubGVuZ3RofSByZXBvczogJHtuZXdSZXBvTGlzdH1gKVxuICAvLyAgIGZvciAoY29uc3QgcmVwb0NvZGUgb2YgbmV3UmVwb0xpc3QpIHtcbiAgLy8gICAgIGNvbnN0IHJlcG9OYW1lID0gZm9ybVJlcG9OYW1lKGxhbmd1YWdlQ29kZSwgcmVwb0NvZGUpO1xuICAvLyAgICAgdXNlckxvZyhgcHJlbG9hZFJlcG9zSWZOZWNlc3Nhcnk6IHByZWxvYWRpbmcgemlwIGZpbGUgZm9yICR7cmVwb05hbWV94oCmYCk7XG4gIC8vICAgICBjb25zdCB6aXBGZXRjaFN1Y2NlZWRlZCA9IGF3YWl0IGNhY2hlZEdldFJlcG9zaXRvcnlaaXBGaWxlKHsgdXNlcm5hbWUsIHJlcG9zaXRvcnk6IHJlcG9OYW1lLCBicmFuY2hPclJlbGVhc2UgfSk7XG4gIC8vICAgICBpZiAoIXppcEZldGNoU3VjY2VlZGVkKSB7XG4gIC8vICAgICAgIHVzZXJMb2coYHByZWxvYWRSZXBvc0lmTmVjZXNzYXJ5OiBtaXNmZXRjaGVkIHppcCBmaWxlIGZvciAke3JlcG9Db2RlfSByZXBvIHdpdGggJHt6aXBGZXRjaFN1Y2NlZWRlZH1gKTtcbiAgLy8gICAgICAgc3VjY2VzcyA9IGZhbHNlO1xuICAvLyAgICAgfVxuICAvLyAgIH1cbiAgLy8gfVxuICAvLyBlbHNlIHVzZXJMb2coXCJBbGwgcmVwb3Mgd2VyZSBjYWNoZWQgYWxyZWFkeSFcIik7XG5cbiAgZm9yIChjb25zdCByZXBvQ29kZSBvZiByZXBvc18pIHtcbiAgICAvLyBkZWJ1Z0xvZyhgcHJlbG9hZFJlcG9zSWZOZWNlc3Nhcnk6IGxvb2tpbmcgYXQgcmVwb0NvZGUgJyR7cmVwb0NvZGV9J+KApmApO1xuICAgIGxldCBhZGp1c3RlZExhbmd1YWdlQ29kZSA9IGxhbmd1YWdlQ29kZTtcbiAgICBpZiAoKGxhbmd1YWdlQ29kZSA9PT0gJ2hibycgJiYgcmVwb0NvZGUgIT09ICdVSEInKSB8fCAobGFuZ3VhZ2VDb2RlID09PSAnZWwteC1rb2luZScgJiYgcmVwb0NvZGUgIT09ICdVR05UJykpXG4gICAgICBhZGp1c3RlZExhbmd1YWdlQ29kZSA9ICdlbic7IC8vIEFzc3VtZSBFbmdsaXNoIHRoZW5cbiAgICBsZXQgYWRqdXN0ZWRCcmFuY2hPclJlbGVhc2UgPSBicmFuY2hPclJlbGVhc2U7XG4gICAgbGV0IGFkanVzdGVkUmVwb0NvZGUgPSByZXBvQ29kZTtcbiAgICBpZiAocmVwb0NvZGUuZW5kc1dpdGgoJzInKSkge1xuICAgICAgYWRqdXN0ZWRSZXBvQ29kZSA9IGFkanVzdGVkUmVwb0NvZGUuc3Vic3RyaW5nKDAsIGFkanVzdGVkUmVwb0NvZGUubGVuZ3RoIC0gMSk7IC8vIFJlbW92ZSB0aGUgJzInIGZyb20gdGhlIGVuZFxuICAgICAgYWRqdXN0ZWRCcmFuY2hPclJlbGVhc2UgPSAnbmV3Rm9ybWF0JztcbiAgICB9XG4gICAgLy8gZWxzZSBpZiAocmVwb0NvZGUgPT09ICdPQlMtVE4nIHx8IHJlcG9Db2RlID09PSAnT0JTLVRRJyB8fCByZXBvQ29kZSA9PT0gJ09CUy1TTicgfHwgcmVwb0NvZGUgPT09ICdPQlMtU1EnKVxuICAgIC8vICAgYWRqdXN0ZWRCcmFuY2hPclJlbGVhc2UgPSAnbmV3Rm9ybWF0JztcbiAgICBjb25zdCByZXBvTmFtZSA9IGZvcm1SZXBvTmFtZShhZGp1c3RlZExhbmd1YWdlQ29kZSwgYWRqdXN0ZWRSZXBvQ29kZSk7XG4gICAgLy8gZGVidWdMb2coYHByZWxvYWRSZXBvc0lmTmVjZXNzYXJ5OiBwcmVsb2FkaW5nIHppcCBmaWxlIGZvciAke3JlcG9OYW1lfeKApmApO1xuICAgIGNvbnN0IHppcEZldGNoU3VjY2VlZGVkID0gYXdhaXQgY2FjaGVkR2V0UmVwb3NpdG9yeVppcEZpbGUoeyB1c2VybmFtZSwgcmVwb3NpdG9yeTogcmVwb05hbWUsIGJyYW5jaE9yUmVsZWFzZTogYWRqdXN0ZWRCcmFuY2hPclJlbGVhc2UgfSk7XG4gICAgaWYgKCF6aXBGZXRjaFN1Y2NlZWRlZCkge1xuICAgICAgY29uc29sZS5lcnJvcihgcHJlbG9hZFJlcG9zSWZOZWNlc3NhcnkoKSBtaXNmZXRjaGVkIHppcCBmaWxlIGZvciAke3JlcG9Db2RlfSAoJHthZGp1c3RlZFJlcG9Db2RlfSkgcmVwbyB3aXRoICR7emlwRmV0Y2hTdWNjZWVkZWR9YCk7XG4gICAgICBzdWNjZXNzID0gZmFsc2U7XG4gICAgfVxuICAgIGlmIChyZXBvQ29kZSA9PT0gJ09CUycpIHtcbiAgICAgIGRlYnVnTG9nKGBwcmVsb2FkUmVwb3NJZk5lY2Vzc2FyeTogcHJlbG9hZGluZyBPQlMgemlwcGVkIHBpY3R1cmVzIGZpbGUgZnJvbSAke09CU19QSUNUVVJFX1pJUF9VUkl94oCmYCk7XG4gICAgICBjb25zdCB6aXBCbG9iID0gYXdhaXQgemlwU3RvcmUuZ2V0SXRlbShPQlNfUElDVFVSRV9aSVBfRklMRU5BTUUpO1xuICAgICAgLy8gZGVidWdMb2coYCAgZ2V0WmlwRnJvbVN0b3JlKCR7dXJpfSAtLSBlbXB0eTogJHshemlwQmxvYn1gKTtcbiAgICAgIGlmICghemlwQmxvYikge1xuICAgICAgICB1c2VyTG9nKGBkb3dubG9hZGluZ09CU1BpY3R1cmVzWmlwRmlsZSgke09CU19QSUNUVVJFX1pJUF9VUkl9KeKApmApO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKE9CU19QSUNUVVJFX1pJUF9VUkkpO1xuICAgICAgICBpZiAocmVzcG9uc2Uuc3RhdHVzID09PSAyMDAgfHwgcmVzcG9uc2Uuc3RhdHVzID09PSAwKSB7XG4gICAgICAgICAgY29uc3QgemlwQXJyYXlCdWZmZXIgPSBhd2FpdCByZXNwb25zZS5hcnJheUJ1ZmZlcigpOyAvLyBibG9iIHN0b3JhZ2Ugbm90IHN1cHBvcnRlZCBvbiBtb2JpbGVcbiAgICAgICAgICBhd2FpdCB6aXBTdG9yZS5zZXRJdGVtKE9CU19QSUNUVVJFX1pJUF9GSUxFTkFNRSwgemlwQXJyYXlCdWZmZXIpO1xuICAgICAgICAgIC8vIGRlYnVnTG9nKGAgIGRvd25sb2FkaW5nT0JTUGljdHVyZXNaaXBGaWxlKCR7dXJpfSkgLS0gc2F2ZWQgemlwYCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihgZG93bmxvYWRpbmdPQlNQaWN0dXJlc1ppcEZpbGUoJHtPQlNfUElDVFVSRV9aSVBfVVJJfSkgLS0gZ290IHJlc3BvbnNlIHN0YXR1czogJHtyZXNwb25zZS5zdGF0dXN9YCk7XG4gICAgICAgICAgc3VjY2VzcyA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBzdWNjZXNzO1xufVxuXG5cbi8qKlxuICogZG9lcyBodHRwIGZpbGUgZmV0Y2ggZnJvbSBzZXJ2ZXIgIHVzZXMgY2FjaGVTdG9yZSB0byBtaW5pbWl6ZSByZXBlYXRlZCBmZXRjaGVzIG9mIHNhbWUgZmlsZVxuICogQHBhcmFtIHtzdHJpbmd9IHVzZXJuYW1lXG4gKiBAcGFyYW0ge3N0cmluZ30gcmVwb3NpdG9yeVxuICogQHBhcmFtIHtzdHJpbmd9IHBhdGhcbiAqIEBwYXJhbSB7c3RyaW5nfSBicmFuY2hcbiAqIEByZXR1cm4ge1Byb21pc2U8bnVsbHxhbnk+fSByZXNvbHZlcyB0byBmaWxlIGNvbnRlbnRcbiAqL1xuYXN5bmMgZnVuY3Rpb24gY2FjaGVkRmV0Y2hGaWxlRnJvbVNlcnZlcldpdGhCcmFuY2goeyB1c2VybmFtZSwgcmVwb3NpdG9yeSwgcGF0aCwgYnJhbmNoID0gJ21hc3RlcicgfSkge1xuICAvLyBmdW5jdGlvbkxvZyhgY2FjaGVkRmV0Y2hGaWxlRnJvbVNlcnZlcldpdGhCcmFuY2goJHt1c2VybmFtZX0sICR7cmVwb3NpdG9yeX0sICR7cGF0aH0sICR7YnJhbmNofSnigKZgKTtcbiAgLy8gVE9ETzogQ2hlY2sgaG93IHNsb3cgdGhpcyBuZXh0IGNhbGwgaXMgLS0gY2FuIGl0IGJlIGF2b2lkZWQgb3IgY2FjaGVkP1xuICAvLyBSSkggcmVtb3ZlZCB0aGlzIDJPY3QyMDIwIC0tIHdoYXTigJlzIHRoZSBwb2ludCAtLSBpdCBqdXN0IHNsb3dzIHRoaW5ncyBkb3duIC0tXG4gIC8vICAgICAgaWYgaXQgbmVlZHMgdG8gYmUgY2hlY2tlZCwgc2hvdWxkIGJlIGNoZWNrZWQgYmVmb3JlIHRoaXMgcG9pbnRcbiAgLy8gY29uc3QgcmVwb3NpdG9yeUV4aXN0c09uRG9vcjQzID0gYXdhaXQgcmVwb3NpdG9yeUV4aXN0c09uRG9vcjQzKHsgdXNlcm5hbWUsIHJlcG9zaXRvcnkgfSk7XG4gIC8vIGxldCB1cmk7XG4gIGNvbnN0IHVyaSA9IFBhdGguam9pbih1c2VybmFtZSwgcmVwb3NpdG9yeSwgJ3Jhdy9icmFuY2gnLCBicmFuY2gsIHBhdGgpO1xuICByZXR1cm4gYXdhaXQgY2FjaGVkRmV0Y2hGaWxlRnJvbVNlcnZlcldvcmtlcih1cmksIHVzZXJuYW1lLCByZXBvc2l0b3J5LCBwYXRoLCBicmFuY2gpO1xufTtcblxuXG4vKipcbiAqIGRvZXMgaHR0cCBmaWxlIGZldGNoIGZyb20gc2VydmVyICB1c2VzIGNhY2hlU3RvcmUgdG8gbWluaW1pemUgcmVwZWF0ZWQgZmV0Y2hlcyBvZiBzYW1lIGZpbGVcbiAqIEBwYXJhbSB7c3RyaW5nfSB1c2VybmFtZVxuICogQHBhcmFtIHtzdHJpbmd9IHJlcG9zaXRvcnlcbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoXG4gKiBAcGFyYW0ge3N0cmluZ30gdGFnXG4gKiBAcmV0dXJuIHtQcm9taXNlPG51bGx8YW55Pn0gcmVzb2x2ZXMgdG8gZmlsZSBjb250ZW50XG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBjYWNoZWRGZXRjaEZpbGVGcm9tU2VydmVyV2l0aFRhZyh7IHVzZXJuYW1lLCByZXBvc2l0b3J5LCBwYXRoLCB0YWcgfSkge1xuICAvLyBmdW5jdGlvbkxvZyhgY2FjaGVkRmV0Y2hGaWxlRnJvbVNlcnZlcldpdGhUYWcoJHt1c2VybmFtZX0sICR7cmVwb3NpdG9yeX0sICR7cGF0aH0sICR7dGFnfSnigKZgKTtcbiAgLy8gVE9ETzogQ2hlY2sgaG93IHNsb3cgdGhpcyBuZXh0IGNhbGwgaXMgLS0gY2FuIGl0IGJlIGF2b2lkZWQgb3IgY2FjaGVkP1xuICAvLyBSSkggcmVtb3ZlZCB0aGlzIDJPY3QyMDIwIC0tIHdoYXTigJlzIHRoZSBwb2ludCAtLSBpdCBqdXN0IHNsb3dzIHRoaW5ncyBkb3duIC0tXG4gIC8vICAgICAgaWYgaXQgbmVlZHMgdG8gYmUgY2hlY2tlZCwgc2hvdWxkIGJlIGNoZWNrZWQgYmVmb3JlIHRoaXMgcG9pbnRcbiAgLy8gY29uc3QgcmVwb3NpdG9yeUV4aXN0c09uRG9vcjQzID0gYXdhaXQgcmVwb3NpdG9yeUV4aXN0c09uRG9vcjQzKHsgdXNlcm5hbWUsIHJlcG9zaXRvcnkgfSk7XG4gIC8vIGxldCB1cmk7XG4gIGNvbnN0IHVyaSA9IFBhdGguam9pbih1c2VybmFtZSwgcmVwb3NpdG9yeSwgJ3Jhdy90YWcnLCB0YWcsIHBhdGgpO1xuICByZXR1cm4gYXdhaXQgY2FjaGVkRmV0Y2hGaWxlRnJvbVNlcnZlcldvcmtlcih1cmksIHVzZXJuYW1lLCByZXBvc2l0b3J5LCBwYXRoLCB0YWcpO1xufTtcblxuXG4vKipcbiAqIGRvZXMgaHR0cCBmaWxlIGZldGNoIGZyb20gc2VydmVyICB1c2VzIGNhY2hlU3RvcmUgdG8gbWluaW1pemUgcmVwZWF0ZWQgZmV0Y2hlcyBvZiBzYW1lIGZpbGVcbiAqIEBwYXJhbSB7c3RyaW5nfSB1c2VybmFtZVxuICogQHBhcmFtIHtzdHJpbmd9IHJlcG9zaXRvcnlcbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoXG4gKiBAcGFyYW0ge3N0cmluZ30gYnJhbmNoXG4gKiBAcmV0dXJuIHtQcm9taXNlPG51bGx8YW55Pn0gcmVzb2x2ZXMgdG8gZmlsZSBjb250ZW50XG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGNhY2hlZEZldGNoRmlsZUZyb21TZXJ2ZXJXb3JrZXIodXJpLCB1c2VybmFtZSwgcmVwb3NpdG9yeSwgcGF0aCwgYnJhbmNoT3JUYWcpIHtcbiAgLy8gZnVuY3Rpb25Mb2coYGNhY2hlZEZldGNoRmlsZUZyb21TZXJ2ZXJXb3JrZXIoJHt1cml9LCAke3VzZXJuYW1lfSwgJHtyZXBvc2l0b3J5fSwgJHtwYXRofSwgJHticmFuY2hPclRhZ30p4oCmYCk7XG4gIC8vIFRPRE86IENoZWNrIGhvdyBzbG93IHRoaXMgbmV4dCBjYWxsIGlzIC0tIGNhbiBpdCBiZSBhdm9pZGVkIG9yIGNhY2hlZD9cbiAgLy8gUkpIIHJlbW92ZWQgdGhpcyAyT2N0MjAyMCAtLSB3aGF04oCZcyB0aGUgcG9pbnQgLS0gaXQganVzdCBzbG93cyB0aGluZ3MgZG93biAtLVxuICAvLyAgICAgIGlmIGl0IG5lZWRzIHRvIGJlIGNoZWNrZWQsIHNob3VsZCBiZSBjaGVja2VkIGJlZm9yZSB0aGlzIHBvaW50XG4gIC8vIGNvbnN0IHJlcG9zaXRvcnlFeGlzdHNPbkRvb3I0MyA9IGF3YWl0IHJlcG9zaXRvcnlFeGlzdHNPbkRvb3I0Myh7IHVzZXJuYW1lLCByZXBvc2l0b3J5IH0pO1xuICAvLyBsZXQgdXJpO1xuICBjb25zdCBmYWlsTWVzc2FnZSA9IGF3YWl0IGZhaWxlZFN0b3JlLmdldEl0ZW0odXJpLnRvTG93ZXJDYXNlKCkpO1xuICBpZiAoZmFpbE1lc3NhZ2UpIHtcbiAgICAvLyBkZWJ1Z0xvZyhgICBjYWNoZWRGZXRjaEZpbGVGcm9tU2VydmVyV29ya2VyIGZhaWxlZCBwcmV2aW91c2x5IGZvciAke3VyaX06ICR7ZmFpbE1lc3NhZ2V9YCk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgdHJ5IHtcbiAgICAvLyBkZWJ1Z0xvZyhcIlVSST1cIix1cmkpO1xuICAgIGNvbnN0IGRhdGEgPSBhd2FpdCBjYWNoZWRHZXRGaWxlVXNpbmdQYXJ0aWFsVVJMKHsgdXJpIH0pO1xuICAgIC8vIGRlYnVnTG9nKFwiR290IGRhdGFcIiwgZGF0YSk7XG4gICAgcmV0dXJuIGRhdGE7XG4gIH1cbiAgY2F0Y2ggKGZmZnNFcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoYGNhY2hlZEZldGNoRmlsZUZyb21TZXJ2ZXJXb3JrZXIgY291bGQgbm90IGZldGNoICR7dXNlcm5hbWV9ICR7cmVwb3NpdG9yeX0gJHticmFuY2hPclRhZ30gJHtwYXRofTogJHtmZmZzRXJyb3J9YClcbiAgICAgIC8qIGF3YWl0ICovIGZhaWxlZFN0b3JlLnNldEl0ZW0odXJpLnRvTG93ZXJDYXNlKCksIGZmZnNFcnJvci5tZXNzYWdlKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICAvLyB9IGVsc2UgeyAvLyAhIHJlcG9zaXRvcnlFeGlzdHNPbkRvb3I0M1xuICAvLyAgIGNvbnNvbGUuZXJyb3IoYGNhY2hlZEZldGNoRmlsZUZyb21TZXJ2ZXJXb3JrZXIgcmVwbyAke3VzZXJuYW1lfSAnJHtyZXBvc2l0b3J5fScgZG9lcyBub3QgZXhpc3QhYCk7XG4gIC8vICAgLyogYXdhaXQgKi8gZmFpbGVkU3RvcmUuc2V0SXRlbSh1cmkudG9Mb3dlckNhc2UoKSwgYFJlcG8gJyR7cmVwb3NpdG9yeX0nIGRvZXMgbm90IGV4aXN0IWApO1xuICAvLyAgIHJldHVybiBudWxsO1xuICAvLyB9XG59O1xuXG5cbi8qKlxuICogIG9sZGVyIGdldEZpbGUgd2l0aG91dCB0aGF0IGRvZXNu4oCZdCB1c2UgdGhlIHVuemlwU3RvcmVcbiAqIEBwYXJhbSB7c3RyaW5nfSB1c2VybmFtZVxuICogQHBhcmFtIHtzdHJpbmd9IHJlcG9zaXRvcnlcbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoXG4gKiBAcGFyYW0ge3N0cmluZ30gYnJhbmNoXG4gKiBAcmV0dXJuIHtQcm9taXNlPCo+fVxuICovXG4vKlxuYXN5bmMgZnVuY3Rpb24gY2FjaGVkR2V0RmlsZUZyb21aaXBPclNlcnZlcih7IHVzZXJuYW1lLCByZXBvc2l0b3J5LCBwYXRoLCBicmFuY2ggfSkge1xuICAvLyBmdW5jdGlvbkxvZyhgY2FjaGVkR2V0RmlsZUZyb21aaXBPclNlcnZlcigke3VzZXJuYW1lfSwgJHtyZXBvc2l0b3J5fSwgJHtwYXRofSwgJHticmFuY2h9KeKApmApO1xuICBsZXQgZmlsZTtcbiAgZmlsZSA9IGF3YWl0IGdldEZpbGVGcm9tWmlwKHsgdXNlcm5hbWUsIHJlcG9zaXRvcnksIHBhdGgsIGJyYW5jaCB9KTtcbiAgaWYgKCFmaWxlKSB7XG4gICAgZmlsZSA9IGF3YWl0IGNhY2hlZEZldGNoRmlsZUZyb21TZXJ2ZXJXaXRoQnJhbmNoKHsgdXNlcm5hbWUsIHJlcG9zaXRvcnksIHBhdGgsIGJyYW5jaCB9KTtcbiAgfVxuICByZXR1cm4gZmlsZTtcbn1cbiovXG5cbmFzeW5jIGZ1bmN0aW9uIGdldFVJRCh7IHVzZXJuYW1lIH0pIHtcbiAgLy8gZnVuY3Rpb25Mb2coYGdldFVJRCgke3VzZXJuYW1lfSnigKZgKTtcbiAgY29uc3QgdXJpID0gUGF0aC5qb2luKEFQSV9QQVRILCAndXNlcnMnLCB1c2VybmFtZSk7XG4gIC8vIGRlYnVnTG9nKGBnZXRVSUQgdXJpPSR7dXJpfWApO1xuICBjb25zdCB1c2VyID0gYXdhaXQgY2FjaGVkR2V0RmlsZVVzaW5nUGFydGlhbFVSTCh7IHVyaSB9KTtcbiAgLy8gZGVidWdMb2coYGdldFVJRCB1c2VyPSR7dXNlcn1gKTtcbiAgY29uc3QgeyBpZDogdWlkIH0gPSB1c2VyO1xuICAvLyBkZWJ1Z0xvZyhgICBnZXRVSUQgcmV0dXJuaW5nOiAke3VpZH1gKTtcbiAgcmV0dXJuIHVpZDtcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHJlcG9zaXRvcnlFeGlzdHNPbkRvb3I0Myh7IHVzZXJuYW1lLCByZXBvc2l0b3J5IH0pIHtcbiAgLy8gZnVuY3Rpb25Mb2coYHJlcG9zaXRvcnlFeGlzdHNPbkRvb3I0Mygke3VzZXJuYW1lfSwgJHtyZXBvc2l0b3J5fSnigKZgKTtcbiAgbGV0IHVpZDtcbiAgdHJ5IHtcbiAgICB1aWQgPSBhd2FpdCBnZXRVSUQoeyB1c2VybmFtZSB9KTtcbiAgfSBjYXRjaCAodWlkRXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKGByZXBvc2l0b3J5RXhpc3RzT25Eb29yNDMoJHt1c2VybmFtZX0sICR7cmVwb3NpdG9yeX0pIC0gaW52YWxpZCB1c2VybmFtZWAsIHVpZEVycm9yLm1lc3NhZ2UpO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvLyBkZWJ1Z0xvZyhgcmVwb3NpdG9yeUV4aXN0c09uRG9vcjQzIHVpZD0ke3VpZH1gKTtcbiAgLy8gRGVmYXVsdCBsaW1pdCBpcyAxMCAtLSB3YXkgdG9vIHNtYWxsXG4gIGNvbnN0IHBhcmFtcyA9IHsgcTogcmVwb3NpdG9yeSwgbGltaXQ6IDUwMCwgdWlkIH07IC8vIERvY3VtZW50YXRpb24gc2F5cyBsaW1pdCBpcyA1MCwgYnV0IGxhcmdlciBudW1iZXJzIHNlZW0gdG8gd29yayBva1xuICBjb25zdCB1cmkgPSBQYXRoLmpvaW4oQVBJX1BBVEgsICdyZXBvcycsIGBzZWFyY2hgKTtcbiAgLy8gZGVidWdMb2coYHJlcG9zaXRvcnlFeGlzdHNPbkRvb3I0MyB1cmk9JHt1cml9YCk7XG4gIGxldCByZXRyaWV2ZWRSZXBvTGlzdDtcbiAgdHJ5IHtcbiAgICBjb25zdCB7IGRhdGE6IHJldHJpZXZlZFJlcG9MaXN0RGF0YSB9ID0gYXdhaXQgY2FjaGVkR2V0RmlsZVVzaW5nUGFydGlhbFVSTCh7IHVyaSwgcGFyYW1zIH0pO1xuICAgIHJldHJpZXZlZFJlcG9MaXN0ID0gcmV0cmlldmVkUmVwb0xpc3REYXRhO1xuICB9XG4gIGNhdGNoIChyRUUpIHtcbiAgICBjb25zb2xlLmVycm9yKGByZXBvc2l0b3J5RXhpc3RzT25Eb29yNDMoJHt1c2VybmFtZX0sICR7cmVwb3NpdG9yeX0pIC0gZXJyb3IgZmV0Y2hpbmcgcmVwbyBsaXN0YCwgckVFLm1lc3NhZ2UpO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvLyBkZWJ1Z0xvZyhcInJldHJpZXZlZFJlcG9MaXN0Lmxlbmd0aFwiLCByZXRyaWV2ZWRSZXBvTGlzdC5sZW5ndGgpO1xuICBpZiAocmV0cmlldmVkUmVwb0xpc3QubGVuZ3RoIDwgMSkge1xuICAgIHVzZXJMb2coYHJlcG9zaXRvcnlFeGlzdHNPbkRvb3I0Mygke3VzZXJuYW1lfSwgJHtyZXBvc2l0b3J5fSkgLSBubyByZXBvcyBmb3VuZGApO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvLyBkZWJ1Z0xvZyhgcmVwb3NpdG9yeUV4aXN0c09uRG9vcjQzIHJldHJpZXZlZFJlcG9MaXN0ICgke3JldHJpZXZlZFJlcG9MaXN0Lmxlbmd0aH0pPSR7SlNPTi5zdHJpbmdpZnkocmV0cmlldmVkUmVwb0xpc3QpfWApO1xuICAvLyBmb3IgKGNvbnN0IHRoaXNSZXBvIG9mIHJldHJpZXZlZFJlcG9MaXN0KSB1c2VyTG9nKGAgIHRoaXNSZXBvICgke0pTT04uc3RyaW5naWZ5KE9iamVjdC5rZXlzKHRoaXNSZXBvKSl9KSA9JHtKU09OLnN0cmluZ2lmeSh0aGlzUmVwby5uYW1lKX1gKTtcbiAgY29uc3QgZGVzaXJlZE1hdGNoID0gYCR7dXNlcm5hbWV9LyR7cmVwb3NpdG9yeX1gLnRvTG93ZXJDYXNlKCk7XG4gIGNvbnN0IGZpbHRlcmVkUmVwb0xpc3QgPSByZXRyaWV2ZWRSZXBvTGlzdC5maWx0ZXIocmVwbyA9PiByZXBvLmZ1bGxfbmFtZS50b0xvd2VyQ2FzZSgpID09PSBkZXNpcmVkTWF0Y2gpO1xuICBpZiAoZmlsdGVyZWRSZXBvTGlzdC5sZW5ndGggPCAxKSB7XG4gICAgdXNlckxvZyhgcmVwb3NpdG9yeUV4aXN0c09uRG9vcjQzKCR7dXNlcm5hbWV9LCAke3JlcG9zaXRvcnl9KSAtIHJlcG8gbm90IGZvdW5kICR7cmV0cmlldmVkUmVwb0xpc3QubGVuZ3RofSAke2ZpbHRlcmVkUmVwb0xpc3QubGVuZ3RofWApO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvLyBjb25zdCBmb3VuZFJlcG8gPSBmaWx0ZXJlZFJlcG9MaXN0WzBdO1xuICAvLyBkZWJ1Z0xvZyhgcmVwb3NpdG9yeUV4aXN0c09uRG9vcjQzIGZvdW5kUmVwbz0ke0pTT04uc3RyaW5naWZ5KGZvdW5kUmVwbyl9YCk7XG4gIHJldHVybiB0cnVlO1xufTtcblxuXG5hc3luYyBmdW5jdGlvbiBjYWNoZWRHZXRGaWxlVXNpbmdQYXJ0aWFsVVJMKHsgdXJpLCBwYXJhbXMgfSkge1xuICAvLyBmdW5jdGlvbkxvZyhgY2FjaGVkR2V0RmlsZVVzaW5nUGFydGlhbFVSTCgke3VyaX0sICR7SlNPTi5zdHJpbmdpZnkocGFyYW1zKX0p4oCmYCk7XG4gIC8vIGRlYnVnTG9nKGAgIGdldCBxdWVyeWluZzogJHtiYXNlVVJMK3VyaX1gKTtcbiAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBEb29yNDNBcGkuZ2V0KERPT1I0M19CQVNFX1VSTCArIHVyaSwgeyBwYXJhbXMgfSk7XG4gIGlmIChyZXNwb25zZS5yZXF1ZXN0LmZyb21DYWNoZSAhPT0gdHJ1ZSkgdXNlckxvZyhgICBEb29yNDNBcGkgZG93bmxvYWRlZCBEb29yNDMgJHt1cml9YCk7XG4gIC8vIGRlYnVnTG9nKGAgIGNhY2hlZEdldEZpbGVVc2luZ1BhcnRpYWxVUkwgcmV0dXJuaW5nOiAke0pTT04uc3RyaW5naWZ5KHJlc3BvbnNlLmRhdGEpfWApO1xuICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcbn07XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBjYWNoZWRHZXRGaWxlVXNpbmdGdWxsVVJMKHsgdXJpLCBwYXJhbXMgfSkge1xuICAvLyBmdW5jdGlvbkxvZyhgY2FjaGVkR2V0RmlsZVVzaW5nRnVsbFVSTCgke3VyaX0sICR7cGFyYW1zfSnigKZgKTtcbiAgaWYgKHVyaS5zdGFydHNXaXRoKCdodHRwczovL2Nkbi5kb29yNDMub3JnL29icy9qcGcvMzYwcHgvb2JzJykpIHtcbiAgICAvLyB1c2VyTG9nKFwiY2FjaGVkR2V0RmlsZVVzaW5nRnVsbFVSTCgpIGlzIGNoZWNraW5nIGlmIHRoZSBPQlMgcGljdHVyZSBpcyBpbiBhIGRvd25sb2FkZWQgemlwIGZpbGXigKZcIik7XG4gICAgbGV0IHBpY3R1cmVDb250ZW50cyA9IGF3YWl0IGdldFVuWmlwcGVkUGljdHVyZUZpbGUodXJpKTtcbiAgICBpZiAocGljdHVyZUNvbnRlbnRzKSB7XG4gICAgICAvLyBkZWJ1Z0xvZyhgY2FjaGVkR2V0RmlsZVVzaW5nRnVsbFVSTCBnb3QgJHt1cml9IGZyb20gdW56aXBwZWQgY2FjaGVgKTtcbiAgICAgIHJldHVybiBwaWN0dXJlQ29udGVudHM7XG4gICAgfVxuICAgIGNvbnN0IHppcEJsb2IgPSBhd2FpdCB6aXBTdG9yZS5nZXRJdGVtKE9CU19QSUNUVVJFX1pJUF9GSUxFTkFNRSk7XG4gICAgLy8gZGVidWdMb2coYCAgZ2V0WmlwRnJvbVN0b3JlKCR7T0JTX1BJQ1RVUkVfWklQX0ZJTEVOQU1FfSAtLSBlbXB0eTogJHshemlwQmxvYn1gKTtcbiAgICB0cnkge1xuICAgICAgaWYgKHppcEJsb2IpIHtcbiAgICAgICAgLy8gZGVidWdMb2coYCAgR290IHppcEJsb2IgZm9yICR7T0JTX1BJQ1RVUkVfWklQX0ZJTEVOQU1FfWApO1xuICAgICAgICBjb25zdCB6aXAgPSBhd2FpdCBKU1ppcC5sb2FkQXN5bmMoemlwQmxvYik7XG4gICAgICAgIC8vIHppcC5mb3JFYWNoKGZ1bmN0aW9uIChyZWxhdGl2ZVBhdGgpIHtcbiAgICAgICAgICAvLyBkZWJ1Z0xvZyhgcmVsUGF0aD0ke3JlbGF0aXZlUGF0aH1gKTsgLy8gRGlzcGxheXMgJ3JlbFBhdGg9MzYwcHgvb2JzLWVuLTE3LTA5LmpwZydcbiAgICAgICAgLy8gfSlcbiAgICAgICAgY29uc3QgemlwUGF0aCA9IHVyaS5zdWJzdHJpbmcoMzEpOyAvLyBEcm9wIGh0dHBzOi8vY2RuLmRvb3I0My5vcmcvb2JzL2pwZy8gdG8gZ2V0IDM2MHB4L29icy1lbi0wMS0wNS5qcGdcbiAgICAgICAgLy8gZGVidWdMb2coYCAgemlwUGF0aD0ke3ppcFBhdGh9YCk7XG4gICAgICAgIHBpY3R1cmVDb250ZW50cyA9IGF3YWl0IHppcC5maWxlKHppcFBhdGgpLmFzeW5jKCdzdHJpbmcnKTtcbiAgICAgICAgLy8gZGVidWdMb2coYCAgICBHb3QgemlwQmxvYiAke3BpY3R1cmVDb250ZW50cy5sZW5ndGh9IGJ5dGVzYCk7XG4gICAgICB9XG4gICAgICAvLyBlbHNlIHVzZXJMb2coXCIgIE5vIHppcEJsb2JcIik7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGlmIChlcnJvci5tZXNzYWdlLmluZGV4T2YoJyBpcyBudWxsJykgPCAwKVxuICAgICAgICBjb25zb2xlLmVycm9yKGBjYWNoZWRHZXRGaWxlVXNpbmdQYXJ0aWFsVVJMIGZvciAke3VyaX0gZ290OiAke2Vycm9yLm1lc3NhZ2V9YCk7XG4gICAgICBwaWN0dXJlQ29udGVudHMgPSBudWxsO1xuICAgIH1cbiAgICAvLyBpZiAoY29udGVudHMpXG4gICAgLy8gICBpZiAoZmlsZVBhdGguaW5kZXhPZignX3RxLycpIDwgMCkgLy8gRG9u4oCZdCBsb2cgZm9yIFRRMiBmaWxlcyBjb3ogdG9vIG1hbnlcbiAgICAvLyAgICAgdXNlckxvZyhgICBjYWNoZWRHZXRGaWxlIGdvdCAke2ZpbGVQYXRofSBmcm9tIHppcGZpbGVgKTtcbiAgICBpZiAocGljdHVyZUNvbnRlbnRzKSB7XG4gICAgICAvLyBzYXZlIHVuemlwcGVkIGZpbGUgaW4gY2FjaGUgdG8gc3BlZWQgbGF0ZXIgcmV0cmlldmFsXG4gICAgICBhd2FpdCB1bnppcFN0b3JlLnNldEl0ZW0odXJpLCBwaWN0dXJlQ29udGVudHMpO1xuICAgICAgLy8gdXNlckxvZyhgY2FjaGVkR2V0RmlsZVVzaW5nRnVsbFVSTCBzYXZlZCAke3VyaX0gdG8gY2FjaGUgZm9yIG5leHQgdGltZWApO1xuICAgICAgcmV0dXJuIHBpY3R1cmVDb250ZW50cztcbiAgICB9XG4gICAgLy8gZWxzZSBjb25zb2xlLmVycm9yKGBjYWNoZWRHZXRGaWxlVXNpbmdGdWxsVVJMKCR7dXJpfSkgLS0gZmFpbGVkIHRvIGdldCBmaWxlIGZyb20gemlwYCk7XG4gIH1cbiAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBEb29yNDNBcGkuZ2V0KHVyaSwgeyBwYXJhbXMgfSk7XG4gIGlmIChyZXNwb25zZS5yZXF1ZXN0LmZyb21DYWNoZSAhPT0gdHJ1ZSkgdXNlckxvZyhgICBEb29yNDNBcGkgZG93bmxvYWRlZCAke3VyaX1gKTtcbiAgLy8gZGVidWdMb2coYCAgY2FjaGVkR2V0RmlsZVVzaW5nRnVsbFVSTCByZXR1cm5pbmc6ICR7cmVzcG9uc2UuZGF0YX1gKTtcbiAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XG59O1xuXG5cbi8qXG5mdW5jdGlvbiBmZXRjaFJlcG9zaXRvcmllc1ppcEZpbGVzKHt1c2VybmFtZSwgbGFuZ3VhZ2VJZCwgYnJhbmNofSkge1xuICBjb25zdCByZXBvc2l0b3JpZXMgPSByZXNvdXJjZVJlcG9zaXRvcmllcyh7bGFuZ3VhZ2VJZH0pO1xuICBjb25zdCBwcm9taXNlcyA9IE9iamVjdC52YWx1ZXMocmVwb3NpdG9yaWVzKS5tYXAocmVwb3NpdG9yeSA9PiB7XG4gICAgcmV0dXJuIGRvd25sb2FkUmVwb3NpdG9yeVppcEZpbGUoe3VzZXJuYW1lLCByZXBvc2l0b3J5LCBicmFuY2h9KTtcbiAgfSk7XG4gIGNvbnN0IHppcEFycmF5ID0gYXdhaXQgUHJvbWlzZS5hbGwocHJvbWlzZXMpO1xuICByZXR1cm4gemlwQXJyYXk7XG59O1xuKi9cblxuXG4vKipcbiAqIHJldHJpZXZlIHJlcG8gYXMgemlwIGZpbGVcbiAqIEBwYXJhbSB7c3RyaW5nfSB1c2VybmFtZVxuICogQHBhcmFtIHtzdHJpbmd9IHJlcG9zaXRvcnlcbiAqIEBwYXJhbSB7c3RyaW5nfSBicmFuY2hcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gZm9yY2VMb2FkIC0gaWYgbm90IHRydWUsIHRoZW4gdXNlIGV4aXN0aW5nIHJlcG8gaW4gemlwc3RvcmVcbiAqIEByZXR1cm4ge1Byb21pc2U8W118KltdPn0gcmVzb2x2ZXMgdG8gdHJ1ZSBpZiBkb3dubG9hZGVkXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBjYWNoZWRHZXRSZXBvc2l0b3J5WmlwRmlsZSh7IHVzZXJuYW1lLCByZXBvc2l0b3J5LCBicmFuY2hPclJlbGVhc2UgfSwgZm9yY2VMb2FkID0gZmFsc2UpIHtcbiAgLy8gaHR0cHM6Ly9naXQuZG9vcjQzLm9yZy97dXNlcm5hbWV9L3tyZXBvc2l0b3J5fS9hcmNoaXZlL3ticmFuY2h9LnppcFxuICAvLyBmdW5jdGlvbkxvZyhgY2FjaGVkR2V0UmVwb3NpdG9yeVppcEZpbGUoJHt1c2VybmFtZX0sICR7cmVwb3NpdG9yeX0sICR7YnJhbmNoT3JSZWxlYXNlfSwgJHtmb3JjZUxvYWR9KeKApmApO1xuXG4gIGlmICghZm9yY2VMb2FkKSB7IC8vIHNlZSBpZiB3ZSBhbHJlYWR5IGhhdmUgaW4gemlwU3RvcmVcbiAgICBjb25zdCB6aXBCbG9iID0gYXdhaXQgZ2V0WmlwRnJvbVN0b3JlKHVzZXJuYW1lLCByZXBvc2l0b3J5LCBicmFuY2hPclJlbGVhc2UpO1xuICAgIGlmICh6aXBCbG9iKSB7XG4gICAgICAvLyBkZWJ1Z0xvZyhgY2FjaGVkR2V0UmVwb3NpdG9yeVppcEZpbGUgZm9yICR7dXNlcm5hbWV9LCAke3JlcG9zaXRvcnl9LCAke2JyYW5jaE9yUmVsZWFzZX0gLS0gYWxyZWFkeSBsb2FkZWRgKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZG93bmxvYWRSZXBvc2l0b3J5WmlwRmlsZSh7IHVzZXJuYW1lLCByZXBvc2l0b3J5LCBicmFuY2hPclJlbGVhc2UgfSk7XG59O1xuXG5cbmFzeW5jIGZ1bmN0aW9uIGRvd25sb2FkUmVwb3NpdG9yeVppcEZpbGUoeyB1c2VybmFtZSwgcmVwb3NpdG9yeSwgYnJhbmNoT3JSZWxlYXNlIH0pIHtcbiAgZnVuY3Rpb25Mb2coYGRvd25sb2FkUmVwb3NpdG9yeVppcEZpbGUoJHt1c2VybmFtZX0sICR7cmVwb3NpdG9yeX0sICR7YnJhbmNoT3JSZWxlYXNlfSnigKZgKTtcbiAgLy8gUkpIIHJlbW92ZWQgdGhpcyAyT2N0MjAyMCAtLSB3aGF04oCZcyB0aGUgcG9pbnQgLS0gaXQganVzdCBzbG93cyB0aGluZ3MgZG93biAtLVxuICAvLyAgICAgIGlmIGl0IG5lZWRzIHRvIGJlIGNoZWNrZWQsIHNob3VsZCBiZSBjaGVja2VkIGJlZm9yZSB0aGlzIHBvaW50XG4gIC8vIGNvbnN0IHJlcG9FeGlzdHMgPSBhd2FpdCByZXBvc2l0b3J5RXhpc3RzT25Eb29yNDMoeyB1c2VybmFtZSwgcmVwb3NpdG9yeSB9KTtcbiAgLy8gaWYgKCFyZXBvRXhpc3RzKSB7XG4gIC8vICAgY29uc29sZS5lcnJvcihgZG93bmxvYWRSZXBvc2l0b3J5WmlwRmlsZSgke3VzZXJuYW1lfSwgJHtyZXBvc2l0b3J5fSwgJHticmFuY2hPclJlbGVhc2V9KSAtLSByZXBvIGRvZXNu4oCZdCBldmVuIGV4aXN0YCk7XG4gIC8vICAgcmV0dXJuIG51bGw7XG4gIC8vIH1cblxuICAvLyBUZW1wbGF0ZSBpcyBodHRwczovL2dpdC5kb29yNDMub3JnL3t1c2VybmFtZX0ve3JlcG9zaXRvcnl9L2FyY2hpdmUve2JyYW5jaE9yUmVsZWFzZX0uemlwXG4gIGNvbnN0IHVyaSA9IHppcFVyaSh7IHVzZXJuYW1lLCByZXBvc2l0b3J5LCBicmFuY2hPclJlbGVhc2UgfSk7XG4gIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2godXJpKTtcbiAgaWYgKHJlc3BvbnNlLnN0YXR1cyA9PT0gMjAwIHx8IHJlc3BvbnNlLnN0YXR1cyA9PT0gMCkge1xuICAgIGNvbnN0IHppcEFycmF5QnVmZmVyID0gYXdhaXQgcmVzcG9uc2UuYXJyYXlCdWZmZXIoKTsgLy8gYmxvYiBzdG9yYWdlIG5vdCBzdXBwb3J0ZWQgb24gbW9iaWxlXG4gICAgYXdhaXQgemlwU3RvcmUuc2V0SXRlbSh1cmkudG9Mb3dlckNhc2UoKSwgemlwQXJyYXlCdWZmZXIpO1xuICAgIC8vIGRlYnVnTG9nKGAgIGRvd25sb2FkUmVwb3NpdG9yeVppcEZpbGUoJHt1c2VybmFtZX0sICR7cmVwb3NpdG9yeX0sICR7YnJhbmNoT3JSZWxlYXNlfSkgLS0gc2F2ZWQgemlwOiAke3VyaX1gKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBlbHNlIHtcbiAgICBjb25zb2xlLmVycm9yKGBkb3dubG9hZFJlcG9zaXRvcnlaaXBGaWxlKCR7dXNlcm5hbWV9LCAke3JlcG9zaXRvcnl9LCAke2JyYW5jaE9yUmVsZWFzZX0pIC0tIGdvdCByZXNwb25zZSBzdGF0dXM6ICR7cmVzcG9uc2Uuc3RhdHVzfWApO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufTtcblxuXG4vKipcbiAqIHB1bGwgcmVwbyBmcm9tIHppcHN0b3JlIGFuZCBnZXQgYSBmaWxlIGxpc3RcbiAqIEBwYXJhbSB7c3RyaW5nfSB1c2VybmFtZVxuICogQHBhcmFtIHtzdHJpbmd9IHJlcG9zaXRvcnlcbiAqIEBwYXJhbSB7c3RyaW5nfSBicmFuY2hPclJlbGVhc2VcbiAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25hbFByZWZpeCAtIHRvIGZpbHRlciBieSBib29rLCBldGMuXG4gKiBAcmV0dXJuIHtQcm9taXNlPFtdfCpbXT59ICByZXNvbHZlcyB0byBmaWxlIGxpc3RcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldEZpbGVMaXN0RnJvbVppcCh7IHVzZXJuYW1lLCByZXBvc2l0b3J5LCBicmFuY2hPclJlbGVhc2UsIG9wdGlvbmFsUHJlZml4IH0pIHtcbiAgLy8gZnVuY3Rpb25Mb2coYGdldEZpbGVMaXN0RnJvbVppcCgke3VzZXJuYW1lfSwgJHtyZXBvc2l0b3J5fSwgJHticmFuY2hPclJlbGVhc2V9LCAke29wdGlvbmFsUHJlZml4fSnigKZgKTtcblxuICBjb25zdCB1cmkgPSB6aXBVcmkoeyB1c2VybmFtZSwgcmVwb3NpdG9yeSwgYnJhbmNoT3JSZWxlYXNlIH0pO1xuICBsZXQgemlwQmxvYiA9IGF3YWl0IGdldFppcEZyb21TdG9yZSh1c2VybmFtZSwgcmVwb3NpdG9yeSwgYnJhbmNoT3JSZWxlYXNlKTtcblxuICBpZiAoIXppcEJsb2IpIHsgLy8gU2VlbXMgdGhhdCB3ZSBuZWVkIHRvIGxvYWQgdGhlIHppcCBmaWxlIGZpcnN0XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCh1cmkpO1xuICAgIGlmIChyZXNwb25zZS5zdGF0dXMgPT09IDIwMCB8fCByZXNwb25zZS5zdGF0dXMgPT09IDApIHtcbiAgICAgIGNvbnN0IHppcEFycmF5QnVmZmVyID0gYXdhaXQgcmVzcG9uc2UuYXJyYXlCdWZmZXIoKTsgLy8gYmxvYiBzdG9yYWdlIG5vdCBzdXBwb3J0ZWQgb24gbW9iaWxlXG4gICAgICB6aXBCbG9iID0gYXdhaXQgemlwU3RvcmUuc2V0SXRlbSh1cmkudG9Mb3dlckNhc2UoKSwgemlwQXJyYXlCdWZmZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zb2xlLmVycm9yKGBnZXRGaWxlTGlzdEZyb21aaXAgZ290IHJlc3BvbnNlIHN0YXR1czogJHtyZXNwb25zZS5zdGF0dXN9YCk7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICB9XG5cbiAgY29uc3QgcGF0aExpc3QgPSBbXTtcbiAgdHJ5IHtcbiAgICBpZiAoemlwQmxvYikge1xuICAgICAgLy8gZGVidWdMb2coYCAgR290IHppcEJsb2IgZm9yIHVyaT0ke3VyaX1gKTtcbiAgICAgIGNvbnN0IHppcCA9IGF3YWl0IEpTWmlwLmxvYWRBc3luYyh6aXBCbG9iKTtcbiAgICAgIC8vIGRlYnVnTG9nKGAgIEdvdCB6aXBgKTtcbiAgICAgIC8vIE5vdyB3ZSBuZWVkIHRvIGZldGNoIHRoZSBsaXN0IG9mIGZpbGVzIGZyb20gdGhlIHJlcG9cbiAgICAgIC8vIHppcC5mb3JFYWNoKGZ1bmN0aW9uIChyZWxhdGl2ZVBhdGgsIGZpbGVPYmplY3QpIHtcbiAgICAgIHppcC5mb3JFYWNoKGZ1bmN0aW9uIChyZWxhdGl2ZVBhdGgpIHtcbiAgICAgICAgLy8gZGVidWdMb2coYHJlbFBhdGg9JHtyZWxhdGl2ZVBhdGh9YClcbiAgICAgICAgLy8gY29uc29sZUxvZ09iamVjdCgnZmlsZU9iamVjdCcsIGZpbGVPYmplY3QpO1xuICAgICAgICBpZiAoIXJlbGF0aXZlUGF0aC5lbmRzV2l0aCgnLycpKSAvLyBpdOKAmXMgbm90IGEgZm9sZGVyXG4gICAgICAgIHtcbiAgICAgICAgICBpZiAocmVsYXRpdmVQYXRoLnN0YXJ0c1dpdGgoYCR7cmVwb3NpdG9yeX0vYCkpIC8vIHJlbW92ZSByZXBvIG5hbWUgcHJlZml4XG4gICAgICAgICAgICByZWxhdGl2ZVBhdGggPSByZWxhdGl2ZVBhdGguc3Vic3RyaW5nKHJlcG9zaXRvcnkubGVuZ3RoICsgMSk7XG4gICAgICAgICAgaWYgKHJlbGF0aXZlUGF0aC5sZW5ndGhcbiAgICAgICAgICAgICYmICFyZWxhdGl2ZVBhdGguc3RhcnRzV2l0aCgnLmdpdCcpIC8vIHNraXBzIGZpbGVzIGluIHRoZXNlIGZvbGRlcnNcbiAgICAgICAgICAgICYmICFyZWxhdGl2ZVBhdGguc3RhcnRzV2l0aCgnLmFwcHMnKSAvLyBza2lwcyBmaWxlcyBpbiB0aGlzIGZvbGRlclxuICAgICAgICAgICAgJiYgKCFvcHRpb25hbFByZWZpeCB8fCByZWxhdGl2ZVBhdGguc3RhcnRzV2l0aChvcHRpb25hbFByZWZpeCkpKSAvLyBpdOKAmXMgdGhlIGNvcnJlY3QgcHJlZml4XG4gICAgICAgICAgICBwYXRoTGlzdC5wdXNoKHJlbGF0aXZlUGF0aCk7XG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfVxuICAgIC8vIGVsc2UgdXNlckxvZyhcIiAgZ2V0RmlsZUxpc3RGcm9tWmlwOiBObyB6aXBCbG9iXCIpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoYGdldEZpbGVMaXN0RnJvbVppcCBnb3Q6ICR7ZXJyb3IubWVzc2FnZX1gKTtcbiAgfVxuXG4gIC8vIGRlYnVnTG9nKGBnZXRGaWxlTGlzdEZyb21aaXAgaXMgcmV0dXJuaW5nICgke3BhdGhMaXN0Lmxlbmd0aH0pIGVudHJpZXM6ICR7cGF0aExpc3R9YCk7XG4gIHJldHVybiBwYXRoTGlzdDtcbn1cblxuXG4vKipcbiAqIHRyeSB0byBnZXQgemlwIGZpbGUgZnJvbSBjYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IHVzZXJuYW1lXG4gKiBAcGFyYW0ge3N0cmluZ30gcmVwb3NpdG9yeVxuICogQHBhcmFtIHtzdHJpbmd9IGJyYW5jaE9yUmVsZWFzZVxuICogQHJldHVybiB7UHJvbWlzZTx1bmtub3duPn0gcmVzb2x2ZXMgdG8gbnVsbCBpZiBub3QgZm91bmRcbiAqL1xuYXN5bmMgZnVuY3Rpb24gZ2V0WmlwRnJvbVN0b3JlKHVzZXJuYW1lLCByZXBvc2l0b3J5LCBicmFuY2hPclJlbGVhc2UpIHtcbiAgLy8gZnVuY3Rpb25Mb2coYGdldFppcEZyb21TdG9yZSgke3VzZXJuYW1lfSwgJHtyZXBvc2l0b3J5fSwgJHticmFuY2hPclJlbGVhc2V9KeKApmApO1xuICBjb25zdCB1cmkgPSB6aXBVcmkoeyB1c2VybmFtZSwgcmVwb3NpdG9yeSwgYnJhbmNoT3JSZWxlYXNlIH0pO1xuICAvLyBkZWJ1Z0xvZyhgICB1cmk9JHt1cml9YCk7XG4gIGNvbnN0IHppcEJsb2IgPSBhd2FpdCB6aXBTdG9yZS5nZXRJdGVtKHVyaS50b0xvd2VyQ2FzZSgpKTtcbiAgLy8gZGVidWdMb2coYCAgZ2V0WmlwRnJvbVN0b3JlKCR7dXJpfSAtLSBlbXB0eTogJHshemlwQmxvYn1gKTtcbiAgcmV0dXJuIHppcEJsb2I7XG59XG5cblxuLyoqXG4gKiBwdWxsIHJlcG8gZnJvbSB6aXBzdG9yZSBhbmQgZ2V0IHRoZSB1bnppcHBlZCBmaWxlXG4gKiBAcGFyYW0ge3N0cmluZ30gdXNlcm5hbWVcbiAqIEBwYXJhbSB7c3RyaW5nfSByZXBvc2l0b3J5XG4gKiBAcGFyYW0ge3N0cmluZ30gYnJhbmNoT3JSZWxlYXNlXG4gKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uYWxQcmVmaXhcbiAqIEByZXR1cm4ge1Byb21pc2U8W118KltdPn0gcmVzb2x2ZXMgdG8gdW56aXBwZWQgZmlsZSBpZiBmb3VuZCBvciBudWxsXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGdldEZpbGVGcm9tWmlwKHsgdXNlcm5hbWUsIHJlcG9zaXRvcnksIHBhdGgsIGJyYW5jaE9yUmVsZWFzZSB9KSB7XG4gIC8vIGZ1bmN0aW9uTG9nKGBnZXRGaWxlRnJvbVppcCgke3VzZXJuYW1lfSwgJHtyZXBvc2l0b3J5fSwgJHtwYXRofSwgJHticmFuY2hPclJlbGVhc2V9KeKApmApO1xuICBsZXQgZmlsZTtcbiAgY29uc3QgemlwQmxvYiA9IGF3YWl0IGdldFppcEZyb21TdG9yZSh1c2VybmFtZSwgcmVwb3NpdG9yeSwgYnJhbmNoT3JSZWxlYXNlKTtcbiAgdHJ5IHtcbiAgICBpZiAoemlwQmxvYikge1xuICAgICAgLy8gZGVidWdMb2coYCAgR290IHppcEJsb2IgZm9yIHVyaT0ke3VyaX1gKTtcbiAgICAgIGNvbnN0IHppcCA9IGF3YWl0IEpTWmlwLmxvYWRBc3luYyh6aXBCbG9iKTtcbiAgICAgIGNvbnN0IHppcFBhdGggPSBQYXRoLmpvaW4ocmVwb3NpdG9yeS50b0xvd2VyQ2FzZSgpLCBwYXRoKTtcbiAgICAgIC8vIGRlYnVnTG9nKGAgIHppcFBhdGg9JHt6aXBQYXRofWApO1xuICAgICAgZmlsZSA9IGF3YWl0IHppcC5maWxlKHppcFBhdGgpLmFzeW5jKCdzdHJpbmcnKTtcbiAgICAgIC8vIGRlYnVnTG9nKGAgICAgR290IHppcEJsb2IgJHtmaWxlLmxlbmd0aH0gYnl0ZXNgKTtcbiAgICB9XG4gICAgLy8gZWxzZSB1c2VyTG9nKFwiICBObyB6aXBCbG9iXCIpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGlmIChlcnJvci5tZXNzYWdlLmluZGV4T2YoJyBpcyBudWxsJykgPCAwKVxuICAgICAgY29uc29sZS5lcnJvcihgZ2V0RmlsZUZyb21aaXAgZm9yICR7dXNlcm5hbWV9ICR7cmVwb3NpdG9yeX0gJHtwYXRofSAke2JyYW5jaE9yUmVsZWFzZX0gZ290OiAke2Vycm9yLm1lc3NhZ2V9YCk7XG4gICAgZmlsZSA9IG51bGw7XG4gIH1cbiAgcmV0dXJuIGZpbGU7XG59O1xuXG5cbmZ1bmN0aW9uIHppcFVyaSh7IHVzZXJuYW1lLCByZXBvc2l0b3J5LCBicmFuY2hPclJlbGVhc2UgPSAnbWFzdGVyJyB9KSB7XG4gIC8vIGZ1bmN0aW9uTG9nKGB6aXBVcmkoJHt1c2VybmFtZX0sICR7cmVwb3NpdG9yeX0sICR7YnJhbmNoT3JSZWxlYXNlfSnigKZgKTtcbiAgY29uc3QgemlwUGF0aCA9IFBhdGguam9pbih1c2VybmFtZSwgcmVwb3NpdG9yeSwgJ2FyY2hpdmUnLCBgJHticmFuY2hPclJlbGVhc2V9LnppcGApO1xuICBjb25zdCB6aXBVcmkgPSBET09SNDNfQkFTRV9VUkwgKyB6aXBQYXRoO1xuICByZXR1cm4gemlwVXJpO1xufTtcblxuXG4vLyBhc3luYyBmdW5jdGlvbiBmZXRjaFRyZWUoeyB1c2VybmFtZSwgcmVwb3NpdG9yeSwgc2hhID0gJ21hc3RlcicgfSkge1xuLy8gICAvLyBmdW5jdGlvbkxvZyhgZmV0Y2hUcmVlKCR7dXNlcm5hbWV9LCAke3JlcG9zaXRvcnl9LCAke3NoYX0p4oCmYCk7XG4vLyAgIGxldCBkYXRhO1xuLy8gICB0cnkge1xuLy8gICAgIGNvbnN0IHVyaSA9IFBhdGguam9pbignYXBpL3YxL3JlcG9zJywgdXNlcm5hbWUsIHJlcG9zaXRvcnksICdnaXQvdHJlZXMnLCBzaGEpO1xuLy8gICAgIC8vIGRlYnVnTG9nKGAgIHVyaT0nJHt1cml9J2ApO1xuLy8gICAgIGRhdGEgPSBhd2FpdCBjYWNoZWRHZXRGaWxlVXNpbmdQYXJ0aWFsVVJMKHsgdXJpIH0pO1xuLy8gICAgIC8vIGRlYnVnTG9nKGAgIGRhdGEgKCR7dHlwZW9mIGRhdGF9KWApO1xuLy8gICAgIHJldHVybiBkYXRhO1xuLy8gICAgIC8vIGNvbnN0IHRyZWUgPSBKU09OLnBhcnNlKGRhdGEpOyAvLyBSSkg6IFdoeSB3YXMgdGhpcyBoZXJlPz8/XG4vLyAgICAgLy8gZGVidWdMb2coYCAgdHJlZSAoJHt0eXBlb2YgdHJlZX0pYCk7XG4vLyAgICAgLy8gcmV0dXJuIHRyZWU7XG4vLyAgIH0gY2F0Y2ggKGVycm9yKSB7XG4vLyAgICAgY29uc29sZS5lcnJvcihgZmV0Y2hUcmVlIGdvdDogJHtlcnJvci5tZXNzYWdlfWApO1xuLy8gICAgIHVzZXJMb2coYCAgRGF0YSB3YXM6ICR7SlNPTi5zdHJpbmdpZnkoZGF0YSl9YCk7XG4vLyAgICAgcmV0dXJuIG51bGw7XG4vLyAgIH1cbi8vIH07XG5cblxuLypcbmFzeW5jIGZ1bmN0aW9uIHJlY3Vyc2l2ZVRyZWUoe3VzZXJuYW1lLCByZXBvc2l0b3J5LCBwYXRoLCBzaGF9KSB7XG4gIHVzZXJMb2coXCJyZWN1cnNlIHRyZWUgYXJnczpcIix1c2VybmFtZSxyZXBvc2l0b3J5LHBhdGgsc2hhKVxuICBsZXQgdHJlZSA9IHt9O1xuICBjb25zdCBwYXRoQXJyYXkgPSBwYXRoLnNwbGl0KCk7XG4gIGNvbnN0IHJlc3VsdHMgPSBmZXRjaFRyZWUoe3VzZXJuYW1lLCByZXBvc2l0b3J5LCBzaGF9KTtcbiAgY29uc3QgcmVzdWx0ID0gcmVzdWx0cy50cmVlLmZpbHRlcihpdGVtID0+IGl0ZW0ucGF0aCA9PT0gcGF0aEFycmF5WzBdKVswXTtcbiAgaWYgKHJlc3VsdCkge1xuICAgIGlmIChyZXN1bHQudHlwZSA9PT0gJ3RyZWUnKSB7XG4gICAgICBjb25zdCBjaGlsZFBhdGggPSBwYXRoQXJyYXkuc2xpY2UoMSkuam9pbignLycpO1xuICAgICAgY29uc3QgY2hpbGRyZW4gPSByZWN1cnNpdmVUcmVlKHt1c2VybmFtZSwgcmVwb3NpdG9yeSwgcGF0aDogY2hpbGRQYXRoLCBzaGE6IHJlc3VsdC5zaGF9KTtcbiAgICAgIHRyZWVbcmVzdWx0LnBhdGhdID0gY2hpbGRyZW47XG4gICAgfSBlbHNlIGlmIChyZXN1bHQudHlwZSA9PT0gJ2Jsb2InKSB7XG4gICAgICB0cmVlW3Jlc3VsdC5wYXRoXSA9IHRydWU7XG4gICAgfVxuICB9XG59O1xuXG5hc3luYyBmdW5jdGlvbiBmaWxlRXhpc3RzKHt1c2VybmFtZSwgcmVwb3NpdG9yeSwgcGF0aCwgYnJhbmNofSkge1xuICAvLyBnZXQgcm9vdCBsaXN0aW5nXG4gIHJlY3Vyc2l2ZVRyZWUoKVxuICAvLyBnZXQgcmVjdXJzaXZlIHBhdGggbGlzdGluZ1xufVxuKi9cbiJdfQ==