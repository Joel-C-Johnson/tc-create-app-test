"use strict";var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");Object.defineProperty(exports, "__esModule", { value: true });exports.checkPlainText = checkPlainText;var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
var _defaults = require("./defaults");
var _textHandlingFunctions = require("./text-handling-functions");
var _fieldTextCheck = require("./field-text-check");
var _disabledNotices = require("./disabled-notices");

var _utilities = require("./utilities");function ownKeys(object, enumerableOnly) {var keys = Object.keys(object);if (Object.getOwnPropertySymbols) {var symbols = Object.getOwnPropertySymbols(object);if (enumerableOnly) {symbols = symbols.filter(function (sym) {return Object.getOwnPropertyDescriptor(object, sym).enumerable;});}keys.push.apply(keys, symbols);}return keys;}function _objectSpread(target) {for (var i = 1; i < arguments.length; i++) {var source = arguments[i] != null ? arguments[i] : {};if (i % 2) {ownKeys(Object(source), true).forEach(function (key) {(0, _defineProperty2.default)(target, key, source[key]);});} else if (Object.getOwnPropertyDescriptors) {Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));} else {ownKeys(Object(source)).forEach(function (key) {Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));});}}return target;}function _createForOfIteratorHelper(o, allowArrayLike) {var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];if (!it) {if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {if (it) o = it;var i = 0;var F = function F() {};return { s: F, n: function n() {if (i >= o.length) return { done: true };return { done: false, value: o[i++] };}, e: function e(_e) {throw _e;}, f: F };}throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");}var normalCompletion = true,didErr = false,err;return { s: function s() {it = it.call(o);}, n: function n() {var step = it.next();normalCompletion = step.done;return step;}, e: function e(_e2) {didErr = true;err = _e2;}, f: function f() {try {if (!normalCompletion && it.return != null) it.return();} finally {if (didErr) throw err;}} };}function _unsupportedIterableToArray(o, minLen) {if (!o) return;if (typeof o === "string") return _arrayLikeToArray(o, minLen);var n = Object.prototype.toString.call(o).slice(8, -1);if (n === "Object" && o.constructor) n = o.constructor.name;if (n === "Map" || n === "Set") return Array.from(o);if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);}function _arrayLikeToArray(arr, len) {if (len == null || len > arr.length) len = arr.length;for (var i = 0, arr2 = new Array(len); i < len; i++) {arr2[i] = arr[i];}return arr2;}


var PLAIN_TEXT_VALIDATOR_VERSION_STRING = '0.4.0';


/**
 *
 * @param {string} textType 'markdown', 'USFM', 'YAML', 'text', or 'raw'
 * @param {string} repoCode -- e.g., 'TN' or 'TQ2', etc.
 * @param {string} textName
 * @param {string} plainText -- text to be checked
 * @param {string} givenLocation
 * @param {Object} checkingOptions
 */
function checkPlainText(languageCode, repoCode, textType, textName, plainText, givenLocation, checkingOptions) {
  /* This function is optimised for checking the entire text, i.e., all lines.
      It is used in checkFileContents() in book-package-check.js
   TODO: Should languageCode also be a parameter here? (affects other programs using the API)
    Returns a result object containing a successList and a noticeList
   */


  // functionLog(`checkPlainText(${textName}, (${plainText.length} chars), ${givenLocation}, ${JSON.stringify(checkingOptions)})…`);
  //parameterAssert(languageCode !== undefined, "checkPlainText: 'languageCode' parameter should be defined");
  //parameterAssert(typeof languageCode === 'string', `checkPlainText: 'languageCode' parameter should be a string not a '${typeof languageCode}': ${languageCode}`);
  //parameterAssert(languageCode !== 'markdown' && languageCode !== 'USFM' && languageCode !== 'YAML' && languageCode !== 'text' && languageCode !== 'raw' && languageCode !== 'unfoldingWord', `checkPlainText: 'languageCode' ${languageCode} parameter should be not be '${languageCode}'`);
  //parameterAssert(repoCode !== undefined, "checkPlainText: 'repoCode' parameter should be defined");
  //parameterAssert(typeof repoCode === 'string', `checkPlainText: 'repoCode' parameter should be a string not a '${typeof repoCode}': ${repoCode}`);
  //parameterAssert(REPO_CODES_LIST.includes(repoCode), `checkPlainText: 'repoCode' parameter should not be '${repoCode}'`);
  //parameterAssert(textType !== undefined, "checkPlainText: 'textType' parameter should be defined");
  //parameterAssert(typeof textType === 'string', `checkPlainText: 'textType' parameter should be a string not a '${typeof textType}': ${textType}`);
  //parameterAssert(textType === 'markdown' || textType === 'USFM' || textType === 'YAML' || textType === 'text' || textType === 'raw', `checkPlainText: unrecognised 'textType' parameter: '${textType}'`);
  //parameterAssert(textName !== undefined, "checkPlainText: 'textName' parameter should be defined");
  //parameterAssert(typeof textName === 'string', `checkPlainText: 'textName' parameter should be a string not a '${typeof textName}': ${textName}`);
  //parameterAssert(plainText !== undefined, "checkPlainText: 'plainText' parameter should be defined");
  //parameterAssert(typeof plainText === 'string', `checkPlainText: 'plainText' parameter should be a string not a '${typeof plainText}': ${plainText}`);
  //parameterAssert(checkingOptions !== undefined, "checkPlainText: 'checkingOptions' parameter should be defined");

  var ourLocation = givenLocation;
  if (ourLocation && ourLocation[0] !== ' ') ourLocation = " ".concat(ourLocation);

  var excerptLength;
  try {
    excerptLength = checkingOptions === null || checkingOptions === void 0 ? void 0 : checkingOptions.excerptLength;
  } catch (ptcError) {}
  if (typeof excerptLength !== 'number' || isNaN(excerptLength)) {
    excerptLength = _defaults.DEFAULT_EXCERPT_LENGTH;
    // debugLog(`Using default excerptLength=${excerptLength}`);
  }
  // else
  // debugLog(`Using supplied excerptLength=${excerptLength}`, `cf. default=${DEFAULT_EXCERPT_LENGTH}`);
  var excerptHalfLength = Math.floor(excerptLength / 2); // rounded down
  var excerptHalfLengthPlus = Math.floor((excerptLength + 1) / 2); // rounded up
  // debugLog(`Using excerptHalfLength=${excerptHalfLength}`, `excerptHalfLengthPlus=${excerptHalfLengthPlus}`);

  var cptResult = { successList: [], noticeList: [] };

  function addSuccessMessage(successString) {
    // functionLog(`checkPlainText success: ${successString}`);
    cptResult.successList.push(successString);
  }
  function addNotice(noticeObject) {
    // bookID is a three-character UPPERCASE USFM book identifier or 'OBS'.
    // functionLog(`checkPlainText notice: (priority=${priority}) ${message}${characterIndex > 0 ? ` (at character ${characterIndex})` : ""}${excerpt ? ` ${excerpt}` : ""}${location}`);
    //parameterAssert(noticeObject.priority !== undefined, "cPT addNotice: 'priority' parameter should be defined");
    //parameterAssert(typeof noticeObject.priority === 'number', `cPT addNotice: 'priority' parameter should be a number not a '${typeof noticeObject.priority}': ${noticeObject.priority}`);
    //parameterAssert(noticeObject.message !== undefined, "cPT addNotice: 'message' parameter should be defined");
    //parameterAssert(typeof noticeObject.message === 'string', `cPT addNotice: 'message' parameter should be a string not a '${typeof noticeObject.message}': ${noticeObject.message}`);
    if (noticeObject.characterIndex) {//parameterAssert(typeof noticeObject.characterIndex === 'number', `cPT addNotice: 'characterIndex' parameter should be a number not a '${typeof noticeObject.characterIndex}': ${noticeObject.characterIndex}`);
    }
    // //parameterAssert(excerpt!==undefined, "cPT addNotice: 'excerpt' parameter should be defined");
    if (noticeObject.excerpt) {//parameterAssert(typeof noticeObject.excerpt === 'string', `cPT addNotice: 'excerpt' parameter should be a string not a '${typeof noticeObject.excerpt}': ${noticeObject.excerpt}`);
    }
    //parameterAssert(noticeObject.location !== undefined, "cPT addNotice: 'location' parameter should be defined");
    //parameterAssert(typeof noticeObject.location === 'string', `cPT addNotice: 'location' parameter should be a string not a '${typeof noticeObject.location}': ${noticeObject.location}`);

    // noticeObject.debugChain = noticeObject.debugChain ? `checkPlainText(${textType}, ${textName}) ${noticeObject.debugChain}` : `checkPlainText(${textType}, ${textName})`;
    cptResult.noticeList.push(noticeObject);
  }

  function ourCheckTextField(lineNumber, fieldText, allowedLinks, optionalFieldLocation, checkingOptions) {
    /**
    * @description - checks the given text field and processes the returned results
    * @param {string} fieldName - name of the field being checked
    * @param {string} fieldText - the actual text of the field being checked
    * @param {boolean} allowedLinks - true if links are allowed in the field, otherwise false
    * @param {string} optionalFieldLocation - description of where the field is located
    * @param {Object} checkingOptions - parameters that might affect the check
    */
    // Does basic checks for small errors like leading/trailing spaces, etc.

    // We assume that checking for compulsory fields is done elsewhere

    // Updates the global list of notices
    // debugLog(`cPT ourCheckTextField(${fieldName}, (${fieldText.length}), ${allowedLinks}, ${fieldLocation}, …)`);
    //parameterAssert(lineNumber !== undefined, "cPT ourCheckTextField: 'lineNumber' parameter should be defined");
    //parameterAssert(typeof lineNumber === 'number', `cPT ourCheckTextField: 'fieldName' parameter should be a number not a '${typeof lineNumber}'`);
    //parameterAssert(fieldText !== undefined, "cPT ourCheckTextField: 'fieldText' parameter should be defined");
    //parameterAssert(typeof fieldText === 'string', `cPT ourCheckTextField: 'fieldText' parameter should be a string not a '${typeof fieldText}'`);
    //parameterAssert(allowedLinks === true || allowedLinks === false, "cPT ourCheckTextField: allowedLinks parameter must be either true or false");
    //parameterAssert(optionalFieldLocation !== undefined, "cPT ourCheckTextField: 'optionalFieldLocation' parameter should be defined");
    //parameterAssert(typeof optionalFieldLocation === 'string', `cPT ourCheckTextField: 'optionalFieldLocation' parameter should be a string not a '${typeof optionalFieldLocation}'`);

    var resultObject = (0, _fieldTextCheck.checkTextField)(languageCode, repoCode, textType, '', fieldText, allowedLinks, optionalFieldLocation, checkingOptions);

    // Choose only ONE of the following
    // This is the fast way of append the results from this field
    // cptResult.noticeList = cptResult.noticeList.concat(resultObject.noticeList);
    // If we need to put everything through addNotice, e.g., for debugging or filtering
    //  process results line by line
    var _iterator = _createForOfIteratorHelper(resultObject.noticeList),_step;try {for (_iterator.s(); !(_step = _iterator.n()).done;) {var noticeEntry = _step.value;
        addNotice(_objectSpread(_objectSpread({}, noticeEntry), {}, { lineNumber: lineNumber }));}} catch (err) {_iterator.e(err);} finally {_iterator.f();}
  }
  // end of ourCheckTextField function

  function checkPlainLineContents(lineNumber, lineText, lineLocation) {

    // functionLog(`checkPlainLineContents for '${lineName}', '${lineText}' at${lineLocation}`);
    var thisText = lineText.trimStart(); // So we don’t get "leading space" AND "doubled spaces" errors

    if (thisText)
      // Allow links as that’s more general
      ourCheckTextField(lineNumber, thisText, true, lineLocation, checkingOptions);
  }
  // end of checkPlainLineContents function


  // Main code for checkPlainText function
  if ((0, _textHandlingFunctions.isWhitespace)(plainText)) {
    addNotice({ priority: 638, message: "Only found whitespace", location: ourLocation });
    return cptResult;
  }

  var characterIndex;
  if ((characterIndex = plainText.indexOf('<<<<<<<')) >= 0) {
    var iy = characterIndex + excerptHalfLength; // Want excerpt to focus more on what follows
    var excerpt = (iy > excerptHalfLength ? '…' : '') + plainText.substring(iy - excerptHalfLength, iy + excerptHalfLengthPlus).replace(/ /g, '␣') + (iy + excerptHalfLengthPlus < plainText.length ? '…' : '');
    addNotice({ priority: 993, message: "Unresolved GIT conflict", characterIndex: characterIndex, excerpt: excerpt, location: ourLocation });
  } else if ((characterIndex = plainText.indexOf('=======')) >= 0) {
    var _iy = characterIndex + excerptHalfLength; // Want excerpt to focus more on what follows
    var _excerpt = (_iy > excerptHalfLength ? '…' : '') + plainText.substring(_iy - excerptHalfLength, _iy + excerptHalfLengthPlus).replace(/ /g, '␣') + (_iy + excerptHalfLengthPlus < plainText.length ? '…' : '');
    addNotice({ priority: 992, message: "Unresolved GIT conflict", characterIndex: characterIndex, excerpt: _excerpt, location: ourLocation });
  } else if ((characterIndex = plainText.indexOf('>>>>>>>>')) >= 0) {
    var _iy2 = characterIndex + excerptHalfLength; // Want excerpt to focus more on what follows
    var _excerpt2 = (_iy2 > excerptHalfLength ? '…' : '') + plainText.substring(_iy2 - excerptHalfLength, _iy2 + excerptHalfLengthPlus).replace(/ /g, '␣') + (_iy2 + excerptHalfLengthPlus < plainText.length ? '…' : '');
    addNotice({ priority: 991, message: "Unresolved GIT conflict", characterIndex: characterIndex, excerpt: _excerpt2, location: ourLocation });
  }

  if (plainText[0] === '\n') {
    characterIndex = 0;
    var _excerpt3 = (plainText.length > excerptLength ? '…' : '') + plainText.slice(-excerptLength).replace(/ /g, '␣').replace(/\n/g, '\\n');
    addNotice({ priority: 539, message: "File starts with empty line", characterIndex: characterIndex, excerpt: _excerpt3, location: ourLocation });
  }
  if (!plainText.endsWith('\n') && !textName.endsWith('title.md')) {
    characterIndex = plainText.length - 1;
    var _excerpt4 = (plainText.length > excerptLength ? '…' : '') + plainText.slice(-excerptLength).replace(/ /g, '␣').replace(/\n/g, '\\n');
    addNotice({ priority: 538, message: "File ends without newline character", characterIndex: characterIndex, excerpt: _excerpt4, location: ourLocation });
  } else
  if (plainText.endsWith('\n\n')) {
    characterIndex = plainText.length - 2;
    var _excerpt5 = (plainText.length > excerptLength ? '…' : '') + plainText.slice(-excerptLength).replace(/ /g, '␣').replace(/\n/g, '\\n');
    addNotice({ priority: 138, message: "File ends with additional blank line(s)", characterIndex: characterIndex, excerpt: _excerpt5, location: ourLocation });
  }

  var lines = plainText.split('\n');
  // debugLog(`  '${location}' has ${lines.length.toLocaleString()} total lines`);
  //  checking nested markers (so that we can give the line number in the notice)
  // let headerLevel = 0;
  // let lastNumLeadingSpaces = 0;
  // let lastLineContents;
  // While checking individual lines,
  var openMarkers = [];
  for (var n = 1; n <= lines.length; n++) {

    var line = lines[n - 1];
    if (line) {
      if (textType === 'text' || textType === 'raw') // other file-types do these checks themselves
        checkPlainLineContents(n, line, ourLocation);

      // Check for nested brackets and quotes, etc.
      for (var _characterIndex = 0; _characterIndex < line.length; _characterIndex++) {
        var char = line[_characterIndex];
        var closeCharacterIndex = void 0;
        if (_textHandlingFunctions.PAIRED_PUNCTUATION_OPENERS.indexOf(char) >= 0) {
          // debugLog(`Saving ${openMarkers.length} '${char}' ${n} ${x}`);
          openMarkers.push({ char: char, n: n, x: _characterIndex });
        } else if ((closeCharacterIndex = _textHandlingFunctions.PAIRED_PUNCTUATION_CLOSERS.indexOf(char)) >= 0) {
          // debugLog(`Found '${char}' ${n} ${x}`);
          // debugLog(`Which: ${which} '${openers.charAt(which)}'`)
          if (openMarkers.length) {
            var _openMarkers$slice = openMarkers.slice(-1),_openMarkers$slice2 = (0, _slicedToArray2.default)(_openMarkers$slice, 1),lastEntry = _openMarkers$slice2[0];
            // debugLog(`  Recovered lastEntry=${JSON.stringify(lastEntry)}`);
            // debugLog(`  Comparing found '${char}' with (${which}) '${openers.charAt(which)}' from '${lastEntry.char}'`);
            if (lastEntry.char === _textHandlingFunctions.PAIRED_PUNCTUATION_OPENERS.charAt(closeCharacterIndex)) {
              // debugLog(`  Matched '${char}' with  '${openers.charAt(which)}' ${n} ${x}`);
              openMarkers.pop();
            } else // something is still open and this isn’t a match -- might just be consequential error
              if (char !== '’' // Closing single quote is also used as apostrophe in English
              && (textType !== 'markdown' || char !== '>' || _characterIndex > 4)) {// Markdown uses > or >> or > > or > > > for block indents so ignore these -- might just be consequential error
                var _excerpt6 = (_characterIndex > excerptHalfLength ? '…' : '') + line.substring(_characterIndex - excerptHalfLength, _characterIndex + excerptHalfLengthPlus).replace(/ /g, '␣') + (_characterIndex + excerptHalfLengthPlus < line.length ? '…' : '');
                var details = "'".concat(lastEntry.char, "' opened on line ").concat(lastEntry.n, " character ").concat(lastEntry.x + 1);
                addNotice({ priority: 777, message: "Bad punctuation nesting: ".concat(char, " closing character doesn\u2019t match"), details: details, lineNumber: n, characterIndex: _characterIndex, excerpt: _excerpt6, location: ourLocation });
                // debugLog(`  ERROR 777: mismatched characters: ${details}`);
              }
          } else // Closed something unexpectedly without an opener
            if (char !== '’' // Closing single quote is also used as apostrophe in English
            && (textType !== 'markdown' || char !== '>')) {// Markdown uses > for block indents so ignore these
              var _excerpt7 = (_characterIndex > excerptHalfLength ? '…' : '') + line.substring(_characterIndex - excerptHalfLength, _characterIndex + excerptHalfLengthPlus).replace(/ /g, '␣') + (_characterIndex + excerptHalfLengthPlus < line.length ? '…' : '');
              addNotice({ priority: 774, message: "Unexpected ".concat(char, " closing character (no matching opener)"), lineNumber: n, characterIndex: _characterIndex, excerpt: _excerpt7, location: ourLocation });
              // debugLog(`  ERROR 774: closed with nothing open: ${char}`);
            }
        }

      }
    } else {
        // This is a blank line
      }

    // lastLineContents = line;
  }
  //  At the end of the text -- check for left-over opening characters (unclosed)
  if (openMarkers.length) {
    var _openMarkers$slice3 = openMarkers.slice(-1),_openMarkers$slice4 = (0, _slicedToArray2.default)(_openMarkers$slice3, 1),_openMarkers$slice4$ = _openMarkers$slice4[0],_char = _openMarkers$slice4$.char,_n = _openMarkers$slice4$.n,x = _openMarkers$slice4$.x;
    var _line = lines[_n - 1];
    var _excerpt8 = (x > excerptHalfLength ? '…' : '') + _line.substring(x - excerptHalfLength, x + excerptHalfLengthPlus).replace(/ /g, '␣') + (x + excerptHalfLengthPlus < _line.length ? '…' : '');
    var _details = openMarkers.length > 1 ? "".concat(openMarkers.length, " unclosed set").concat(openMarkers.length === 1 ? '' : 's') : null;
    addNotice({ priority: 768, message: "At end of text with unclosed ".concat(_char, " opening character"), details: _details, lineNumber: _n, characterIndex: x, excerpt: _excerpt8, location: ourLocation });
  }

  // TODO: Is this a duplicate of the above section about nesting?
  // Check matched pairs in the entire file
  var _iterator2 = _createForOfIteratorHelper(_textHandlingFunctions.OPEN_CLOSE_PUNCTUATION_PAIRS),_step2;try {for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {var punctSet = _step2.value;
      // Can’t check '‘’' coz they might be used as apostrophe
      var leftChar = punctSet[0],rightChar = punctSet[1];
      var leftCount = (0, _textHandlingFunctions.countOccurrences)(plainText, leftChar),
      rightCount = (0, _textHandlingFunctions.countOccurrences)(plainText, rightChar);
      if (leftCount !== rightCount && (
      rightChar !== '’' || leftCount > rightCount) // Closing single quote is also used as apostrophe in English
      && (textType !== 'markdown' || rightChar !== '>')) // markdown uses > as a block quote character
        // NOTE: These are lower priority than similar checks in a field
        //          since they occur only within the entire file
        addNotice({ priority: leftChar === '“' ? 162 : 462, message: "Mismatched ".concat(leftChar).concat(rightChar, " characters"), details: "left=".concat(leftCount.toLocaleString(), ", right=").concat(rightCount.toLocaleString()), location: ourLocation });
    }} catch (err) {_iterator2.e(err);} finally {_iterator2.f();}

  if (!(checkingOptions !== null && checkingOptions !== void 0 && checkingOptions.suppressNoticeDisablingFlag)) {
    // functionLog(`checkPlainText: calling removeDisabledNotices(${cptResult.noticeList.length}) having ${JSON.stringify(checkingOptions)}`);
    cptResult.noticeList = (0, _disabledNotices.removeDisabledNotices)(cptResult.noticeList);
  }

  addSuccessMessage("Checked all ".concat(lines.length.toLocaleString(), " line").concat(lines.length === 1 ? '' : 's').concat(ourLocation, "."));
  if (cptResult.noticeList.length)
  addSuccessMessage("checkPlainText v".concat(PLAIN_TEXT_VALIDATOR_VERSION_STRING, " finished with ").concat(cptResult.noticeList.length ? cptResult.noticeList.length.toLocaleString() : "zero", " notice").concat(cptResult.noticeList.length === 1 ? '' : 's'));else

  addSuccessMessage("No errors or warnings found by checkPlainText v".concat(PLAIN_TEXT_VALIDATOR_VERSION_STRING));
  // debugLog(`  checkPlainText returning with ${result.successList.length.toLocaleString()} success(es), ${result.noticeList.length.toLocaleString()} notice(s).`);
  // debugLog("checkPlainText result is", JSON.stringify(result));
  return cptResult;
}
// end of checkPlainText function
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9jb3JlL3BsYWluLXRleHQtY2hlY2suanMiXSwibmFtZXMiOlsiUExBSU5fVEVYVF9WQUxJREFUT1JfVkVSU0lPTl9TVFJJTkciLCJjaGVja1BsYWluVGV4dCIsImxhbmd1YWdlQ29kZSIsInJlcG9Db2RlIiwidGV4dFR5cGUiLCJ0ZXh0TmFtZSIsInBsYWluVGV4dCIsImdpdmVuTG9jYXRpb24iLCJjaGVja2luZ09wdGlvbnMiLCJvdXJMb2NhdGlvbiIsImV4Y2VycHRMZW5ndGgiLCJwdGNFcnJvciIsImlzTmFOIiwiREVGQVVMVF9FWENFUlBUX0xFTkdUSCIsImV4Y2VycHRIYWxmTGVuZ3RoIiwiTWF0aCIsImZsb29yIiwiZXhjZXJwdEhhbGZMZW5ndGhQbHVzIiwiY3B0UmVzdWx0Iiwic3VjY2Vzc0xpc3QiLCJub3RpY2VMaXN0IiwiYWRkU3VjY2Vzc01lc3NhZ2UiLCJzdWNjZXNzU3RyaW5nIiwicHVzaCIsImFkZE5vdGljZSIsIm5vdGljZU9iamVjdCIsImNoYXJhY3RlckluZGV4IiwiZXhjZXJwdCIsIm91ckNoZWNrVGV4dEZpZWxkIiwibGluZU51bWJlciIsImZpZWxkVGV4dCIsImFsbG93ZWRMaW5rcyIsIm9wdGlvbmFsRmllbGRMb2NhdGlvbiIsInJlc3VsdE9iamVjdCIsIm5vdGljZUVudHJ5IiwiY2hlY2tQbGFpbkxpbmVDb250ZW50cyIsImxpbmVUZXh0IiwibGluZUxvY2F0aW9uIiwidGhpc1RleHQiLCJ0cmltU3RhcnQiLCJwcmlvcml0eSIsIm1lc3NhZ2UiLCJsb2NhdGlvbiIsImluZGV4T2YiLCJpeSIsInN1YnN0cmluZyIsInJlcGxhY2UiLCJsZW5ndGgiLCJzbGljZSIsImVuZHNXaXRoIiwibGluZXMiLCJzcGxpdCIsIm9wZW5NYXJrZXJzIiwibiIsImxpbmUiLCJjaGFyIiwiY2xvc2VDaGFyYWN0ZXJJbmRleCIsIlBBSVJFRF9QVU5DVFVBVElPTl9PUEVORVJTIiwieCIsIlBBSVJFRF9QVU5DVFVBVElPTl9DTE9TRVJTIiwibGFzdEVudHJ5IiwiY2hhckF0IiwicG9wIiwiZGV0YWlscyIsIk9QRU5fQ0xPU0VfUFVOQ1RVQVRJT05fUEFJUlMiLCJwdW5jdFNldCIsImxlZnRDaGFyIiwicmlnaHRDaGFyIiwibGVmdENvdW50IiwicmlnaHRDb3VudCIsInRvTG9jYWxlU3RyaW5nIiwic3VwcHJlc3NOb3RpY2VEaXNhYmxpbmdGbGFnIl0sIm1hcHBpbmdzIjoiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsd0M7OztBQUdBLElBQU1BLG1DQUFtQyxHQUFHLE9BQTVDOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTyxTQUFTQyxjQUFULENBQXdCQyxZQUF4QixFQUFzQ0MsUUFBdEMsRUFBZ0RDLFFBQWhELEVBQTBEQyxRQUExRCxFQUFvRUMsU0FBcEUsRUFBK0VDLGFBQS9FLEVBQThGQyxlQUE5RixFQUErRztBQUNsSDtBQUNKO0FBQ0E7QUFDQTtBQUNBOzs7QUFHSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsTUFBSUMsV0FBVyxHQUFHRixhQUFsQjtBQUNBLE1BQUlFLFdBQVcsSUFBSUEsV0FBVyxDQUFDLENBQUQsQ0FBWCxLQUFtQixHQUF0QyxFQUEyQ0EsV0FBVyxjQUFPQSxXQUFQLENBQVg7O0FBRTNDLE1BQUlDLGFBQUo7QUFDQSxNQUFJO0FBQ0FBLElBQUFBLGFBQWEsR0FBR0YsZUFBSCxhQUFHQSxlQUFILHVCQUFHQSxlQUFlLENBQUVFLGFBQWpDO0FBQ0gsR0FGRCxDQUVFLE9BQU9DLFFBQVAsRUFBaUIsQ0FBRztBQUN0QixNQUFJLE9BQU9ELGFBQVAsS0FBeUIsUUFBekIsSUFBcUNFLEtBQUssQ0FBQ0YsYUFBRCxDQUE5QyxFQUErRDtBQUMzREEsSUFBQUEsYUFBYSxHQUFHRyxnQ0FBaEI7QUFDQTtBQUNIO0FBQ0Q7QUFDQTtBQUNBLE1BQU1DLGlCQUFpQixHQUFHQyxJ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MkIsTUFBckIsR0FBOEI3QixTQUFTLENBQUNFLFVBQVYsQ0FBcUIyQixNQUFyQixDQUE0QnVCLGNBQTVCLEVBQTlCLEdBQTZFLE1BQXRKLG9CQUFzS3BELFNBQVMsQ0FBQ0UsVUFBVixDQUFxQjJCLE1BQXJCLEtBQWdDLENBQWhDLEdBQW9DLEVBQXBDLEdBQXlDLEdBQS9NLEVBQWpCLENBREo7O0FBR0kxQixFQUFBQSxpQkFBaUIsMERBQW1EckIsbUNBQW5ELEVBQWpCO0FBQ0o7QUFDQTtBQUNBLFNBQU9rQixTQUFQO0FBQ0g7QUFDRCIsInNvdXJjZXNDb250ZW50IjpbIi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtdmFyc1xuaW1wb3J0IHsgREVGQVVMVF9FWENFUlBUX0xFTkdUSCwgUkVQT19DT0RFU19MSVNUIH0gZnJvbSAnLi9kZWZhdWx0cydcbmltcG9ydCB7IE9QRU5fQ0xPU0VfUFVOQ1RVQVRJT05fUEFJUlMsIFBBSVJFRF9QVU5DVFVBVElPTl9PUEVORVJTLCBQQUlSRURfUFVOQ1RVQVRJT05fQ0xPU0VSUywgaXNXaGl0ZXNwYWNlLCBjb3VudE9jY3VycmVuY2VzIH0gZnJvbSAnLi90ZXh0LWhhbmRsaW5nLWZ1bmN0aW9ucydcbmltcG9ydCB7IGNoZWNrVGV4dEZpZWxkIH0gZnJvbSAnLi9maWVsZC10ZXh0LWNoZWNrJztcbmltcG9ydCB7IHJlbW92ZURpc2FibGVkTm90aWNlcyB9IGZyb20gJy4vZGlzYWJsZWQtbm90aWNlcyc7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLXZhcnNcbmltcG9ydCB7IHBhcmFtZXRlckFzc2VydCB9IGZyb20gJy4vdXRpbGl0aWVzJztcblxuXG5jb25zdCBQTEFJTl9URVhUX1ZBTElEQVRPUl9WRVJTSU9OX1NUUklORyA9ICcwLjQuMCc7XG5cblxuLyoqXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHRleHRUeXBlICdtYXJrZG93bicsICdVU0ZNJywgJ1lBTUwnLCAndGV4dCcsIG9yICdyYXcnXG4gKiBAcGFyYW0ge3N0cmluZ30gcmVwb0NvZGUgLS0gZS5nLiwgJ1ROJyBvciAnVFEyJywgZXRjLlxuICogQHBhcmFtIHtzdHJpbmd9IHRleHROYW1lXG4gKiBAcGFyYW0ge3N0cmluZ30gcGxhaW5UZXh0IC0tIHRleHQgdG8gYmUgY2hlY2tlZFxuICogQHBhcmFtIHtzdHJpbmd9IGdpdmVuTG9jYXRpb25cbiAqIEBwYXJhbSB7T2JqZWN0fSBjaGVja2luZ09wdGlvbnNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNoZWNrUGxhaW5UZXh0KGxhbmd1YWdlQ29kZSwgcmVwb0NvZGUsIHRleHRUeXBlLCB0ZXh0TmFtZSwgcGxhaW5UZXh0LCBnaXZlbkxvY2F0aW9uLCBjaGVja2luZ09wdGlvbnMpIHtcbiAgICAvKiBUaGlzIGZ1bmN0aW9uIGlzIG9wdGltaXNlZCBmb3IgY2hlY2tpbmcgdGhlIGVudGlyZSB0ZXh0LCBpLmUuLCBhbGwgbGluZXMuXG4gICAgICAgIEl0IGlzIHVzZWQgaW4gY2hlY2tGaWxlQ29udGVudHMoKSBpbiBib29rLXBhY2thZ2UtY2hlY2suanNcblxuICAgIFRPRE86IFNob3VsZCBsYW5ndWFnZUNvZGUgYWxzbyBiZSBhIHBhcmFtZXRlciBoZXJlPyAoYWZmZWN0cyBvdGhlciBwcm9ncmFtcyB1c2luZyB0aGUgQVBJKVxuXG4gICAgIFJldHVybnMgYSByZXN1bHQgb2JqZWN0IGNvbnRhaW5pbmcgYSBzdWNjZXNzTGlzdCBhbmQgYSBub3RpY2VMaXN0XG4gICAgICovXG4gICAgLy8gZnVuY3Rpb25Mb2coYGNoZWNrUGxhaW5UZXh0KCR7dGV4dE5hbWV9LCAoJHtwbGFpblRleHQubGVuZ3RofSBjaGFycyksICR7Z2l2ZW5Mb2NhdGlvbn0sICR7SlNPTi5zdHJpbmdpZnkoY2hlY2tpbmdPcHRpb25zKX0p4oCmYCk7XG4gICAgLy9wYXJhbWV0ZXJBc3NlcnQobGFuZ3VhZ2VDb2RlICE9PSB1bmRlZmluZWQsIFwiY2hlY2tQbGFpblRleHQ6ICdsYW5ndWFnZUNvZGUnIHBhcmFtZXRlciBzaG91bGQgYmUgZGVmaW5lZFwiKTtcbiAgICAvL3BhcmFtZXRlckFzc2VydCh0eXBlb2YgbGFuZ3VhZ2VDb2RlID09PSAnc3RyaW5nJywgYGNoZWNrUGxhaW5UZXh0OiAnbGFuZ3VhZ2VDb2RlJyBwYXJhbWV0ZXIgc2hvdWxkIGJlIGEgc3RyaW5nIG5vdCBhICcke3R5cGVvZiBsYW5ndWFnZUNvZGV9JzogJHtsYW5ndWFnZUNvZGV9YCk7XG4gICAgLy9wYXJhbWV0ZXJBc3NlcnQobGFuZ3VhZ2VDb2RlICE9PSAnbWFya2Rvd24nICYmIGxhbmd1YWdlQ29kZSAhPT0gJ1VTRk0nICYmIGxhbmd1YWdlQ29kZSAhPT0gJ1lBTUwnICYmIGxhbmd1YWdlQ29kZSAhPT0gJ3RleHQnICYmIGxhbmd1YWdlQ29kZSAhPT0gJ3JhdycgJiYgbGFuZ3VhZ2VDb2RlICE9PSAndW5mb2xkaW5nV29yZCcsIGBjaGVja1BsYWluVGV4dDogJ2xhbmd1YWdlQ29kZScgJHtsYW5ndWFnZUNvZGV9IHBhcmFtZXRlciBzaG91bGQgYmUgbm90IGJlICcke2xhbmd1YWdlQ29kZX0nYCk7XG4gICAgLy9wYXJhbWV0ZXJBc3NlcnQocmVwb0NvZGUgIT09IHVuZGVmaW5lZCwgXCJjaGVja1BsYWluVGV4dDogJ3JlcG9Db2RlJyBwYXJhbWV0ZXIgc2hvdWxkIGJlIGRlZmluZWRcIik7XG4gICAgLy9wYXJhbWV0ZXJBc3NlcnQodHlwZW9mIHJlcG9Db2RlID09PSAnc3RyaW5nJywgYGNoZWNrUGxhaW5UZXh0OiAncmVwb0NvZGUnIHBhcmFtZXRlciBzaG91bGQgYmUgYSBzdHJpbmcgbm90IGEgJyR7dHlwZW9mIHJlcG9Db2RlfSc6ICR7cmVwb0NvZGV9YCk7XG4gICAgLy9wYXJhbWV0ZXJBc3NlcnQoUkVQT19DT0RFU19MSVNULmluY2x1ZGVzKHJlcG9Db2RlKSwgYGNoZWNrUGxhaW5UZXh0OiAncmVwb0NvZGUnIHBhcmFtZXRlciBzaG91bGQgbm90IGJlICcke3JlcG9Db2RlfSdgKTtcbiAgICAvL3BhcmFtZXRlckFzc2VydCh0ZXh0VHlwZSAhPT0gdW5kZWZpbmVkLCBcImNoZWNrUGxhaW5UZXh0OiAndGV4dFR5cGUnIHBhcmFtZXRlciBzaG91bGQgYmUgZGVmaW5lZFwiKTtcbiAgICAvL3BhcmFtZXRlckFzc2VydCh0eXBlb2YgdGV4dFR5cGUgPT09ICdzdHJpbmcnLCBgY2hlY2tQbGFpblRleHQ6ICd0ZXh0VHlwZScgcGFyYW1ldGVyIHNob3VsZCBiZSBhIHN0cmluZyBub3QgYSAnJHt0eXBlb2YgdGV4dFR5cGV9JzogJHt0ZXh0VHlwZX1gKTtcbiAgICAvL3BhcmFtZXRlckFzc2VydCh0ZXh0VHlwZSA9PT0gJ21hcmtkb3duJyB8fCB0ZXh0VHlwZSA9PT0gJ1VTRk0nIHx8IHRleHRUeXBlID09PSAnWUFNTCcgfHwgdGV4dFR5cGUgPT09ICd0ZXh0JyB8fCB0ZXh0VHlwZSA9PT0gJ3JhdycsIGBjaGVja1BsYWluVGV4dDogdW5yZWNvZ25pc2VkICd0ZXh0VHlwZScgcGFyYW1ldGVyOiAnJHt0ZXh0VHlwZX0nYCk7XG4gICAgLy9wYXJhbWV0ZXJBc3NlcnQodGV4dE5hbWUgIT09IHVuZGVmaW5lZCwgXCJjaGVja1BsYWluVGV4dDogJ3RleHROYW1lJyBwYXJhbWV0ZXIgc2hvdWxkIGJlIGRlZmluZWRcIik7XG4gICAgLy9wYXJhbWV0ZXJBc3NlcnQodHlwZW9mIHRleHROYW1lID09PSAnc3RyaW5nJywgYGNoZWNrUGxhaW5UZXh0OiAndGV4dE5hbWUnIHBhcmFtZXRlciBzaG91bGQgYmUgYSBzdHJpbmcgbm90IGEgJyR7dHlwZW9mIHRleHROYW1lfSc6ICR7dGV4dE5hbWV9YCk7XG4gICAgLy9wYXJhbWV0ZXJBc3NlcnQocGxhaW5UZXh0ICE9PSB1bmRlZmluZWQsIFwiY2hlY2tQbGFpblRleHQ6ICdwbGFpblRleHQnIHBhcmFtZXRlciBzaG91bGQgYmUgZGVmaW5lZFwiKTtcbiAgICAvL3BhcmFtZXRlckFzc2VydCh0eXBlb2YgcGxhaW5UZXh0ID09PSAnc3RyaW5nJywgYGNoZWNrUGxhaW5UZXh0OiAncGxhaW5UZXh0JyBwYXJhbWV0ZXIgc2hvdWxkIGJlIGEgc3RyaW5nIG5vdCBhICcke3R5cGVvZiBwbGFpblRleHR9JzogJHtwbGFpblRleHR9YCk7XG4gICAgLy9wYXJhbWV0ZXJBc3NlcnQoY2hlY2tpbmdPcHRpb25zICE9PSB1bmRlZmluZWQsIFwiY2hlY2tQbGFpblRleHQ6ICdjaGVja2luZ09wdGlvbnMnIHBhcmFtZXRlciBzaG91bGQgYmUgZGVmaW5lZFwiKTtcblxuICAgIGxldCBvdXJMb2NhdGlvbiA9IGdpdmVuTG9jYXRpb247XG4gICAgaWYgKG91ckxvY2F0aW9uICYmIG91ckxvY2F0aW9uWzBdICE9PSAnICcpIG91ckxvY2F0aW9uID0gYCAke291ckxvY2F0aW9ufWA7XG5cbiAgICBsZXQgZXhjZXJwdExlbmd0aDtcbiAgICB0cnkge1xuICAgICAgICBleGNlcnB0TGVuZ3RoID0gY2hlY2tpbmdPcHRpb25zPy5leGNlcnB0TGVuZ3RoO1xuICAgIH0gY2F0Y2ggKHB0Y0Vycm9yKSB7IH1cbiAgICBpZiAodHlwZW9mIGV4Y2VycHRMZW5ndGggIT09ICdudW1iZXInIHx8IGlzTmFOKGV4Y2VycHRMZW5ndGgpKSB7XG4gICAgICAgIGV4Y2VycHRMZW5ndGggPSBERUZBVUxUX0VYQ0VSUFRfTEVOR1RIO1xuICAgICAgICAvLyBkZWJ1Z0xvZyhgVXNpbmcgZGVmYXVsdCBleGNlcnB0TGVuZ3RoPSR7ZXhjZXJwdExlbmd0aH1gKTtcbiAgICB9XG4gICAgLy8gZWxzZVxuICAgIC8vIGRlYnVnTG9nKGBVc2luZyBzdXBwbGllZCBleGNlcnB0TGVuZ3RoPSR7ZXhjZXJwdExlbmd0aH1gLCBgY2YuIGRlZmF1bHQ9JHtERUZBVUxUX0VYQ0VSUFRfTEVOR1RIfWApO1xuICAgIGNvbnN0IGV4Y2VycHRIYWxmTGVuZ3RoID0gTWF0aC5mbG9vcihleGNlcnB0TGVuZ3RoIC8gMik7IC8vIHJvdW5kZWQgZG93blxuICAgIGNvbnN0IGV4Y2VycHRIYWxmTGVuZ3RoUGx1cyA9IE1hdGguZmxvb3IoKGV4Y2VycHRMZW5ndGggKyAxKSAvIDIpOyAvLyByb3VuZGVkIHVwXG4gICAgLy8gZGVidWdMb2coYFVzaW5nIGV4Y2VycHRIYWxmTGVuZ3RoPSR7ZXhjZXJwdEhhbGZMZW5ndGh9YCwgYGV4Y2VycHRIYWxmTGVuZ3RoUGx1cz0ke2V4Y2VycHRIYWxmTGVuZ3RoUGx1c31gKTtcblxuICAgIGNvbnN0IGNwdFJlc3VsdCA9IHsgc3VjY2Vzc0xpc3Q6IFtdLCBub3RpY2VMaXN0OiBbXSB9O1xuXG4gICAgZnVuY3Rpb24gYWRkU3VjY2Vzc01lc3NhZ2Uoc3VjY2Vzc1N0cmluZykge1xuICAgICAgICAvLyBmdW5jdGlvbkxvZyhgY2hlY2tQbGFpblRleHQgc3VjY2VzczogJHtzdWNjZXNzU3RyaW5nfWApO1xuICAgICAgICBjcHRSZXN1bHQuc3VjY2Vzc0xpc3QucHVzaChzdWNjZXNzU3RyaW5nKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYWRkTm90aWNlKG5vdGljZU9iamVjdCkge1xuICAgICAgICAvLyBib29rSUQgaXMgYSB0aHJlZS1jaGFyYWN0ZXIgVVBQRVJDQVNFIFVTRk0gYm9vayBpZGVudGlmaWVyIG9yICdPQlMnLlxuICAgICAgICAvLyBmdW5jdGlvbkxvZyhgY2hlY2tQbGFpblRleHQgbm90aWNlOiAocHJpb3JpdHk9JHtwcmlvcml0eX0pICR7bWVzc2FnZX0ke2NoYXJhY3RlckluZGV4ID4gMCA/IGAgKGF0IGNoYXJhY3RlciAke2NoYXJhY3RlckluZGV4fSlgIDogXCJcIn0ke2V4Y2VycHQgPyBgICR7ZXhjZXJwdH1gIDogXCJcIn0ke2xvY2F0aW9ufWApO1xuICAgICAgICAvL3BhcmFtZXRlckFzc2VydChub3RpY2VPYmplY3QucHJpb3JpdHkgIT09IHVuZGVmaW5lZCwgXCJjUFQgYWRkTm90aWNlOiAncHJpb3JpdHknIHBhcmFtZXRlciBzaG91bGQgYmUgZGVmaW5lZFwiKTtcbiAgICAgICAgLy9wYXJhbWV0ZXJBc3NlcnQodHlwZW9mIG5vdGljZU9iamVjdC5wcmlvcml0eSA9PT0gJ251bWJlcicsIGBjUFQgYWRkTm90aWNlOiAncHJpb3JpdHknIHBhcmFtZXRlciBzaG91bGQgYmUgYSBudW1iZXIgbm90IGEgJyR7dHlwZW9mIG5vdGljZU9iamVjdC5wcmlvcml0eX0nOiAke25vdGljZU9iamVjdC5wcmlvcml0eX1gKTtcbiAgICAgICAgLy9wYXJhbWV0ZXJBc3NlcnQobm90aWNlT2JqZWN0Lm1lc3NhZ2UgIT09IHVuZGVmaW5lZCwgXCJjUFQgYWRkTm90aWNlOiAnbWVzc2FnZScgcGFyYW1ldGVyIHNob3VsZCBiZSBkZWZpbmVkXCIpO1xuICAgICAgICAvL3BhcmFtZXRlckFzc2VydCh0eXBlb2Ygbm90aWNlT2JqZWN0Lm1lc3NhZ2UgPT09ICdzdHJpbmcnLCBgY1BUIGFkZE5vdGljZTogJ21lc3NhZ2UnIHBhcmFtZXRlciBzaG91bGQgYmUgYSBzdHJpbmcgbm90IGEgJyR7dHlwZW9mIG5vdGljZU9iamVjdC5tZXNzYWdlfSc6ICR7bm90aWNlT2JqZWN0Lm1lc3NhZ2V9YCk7XG4gICAgICAgIGlmIChub3RpY2VPYmplY3QuY2hhcmFjdGVySW5kZXgpIHsgLy9wYXJhbWV0ZXJBc3NlcnQodHlwZW9mIG5vdGljZU9iamVjdC5jaGFyYWN0ZXJJbmRleCA9PT0gJ251bWJlcicsIGBjUFQgYWRkTm90aWNlOiAnY2hhcmFjdGVySW5kZXgnIHBhcmFtZXRlciBzaG91bGQgYmUgYSBudW1iZXIgbm90IGEgJyR7dHlwZW9mIG5vdGljZU9iamVjdC5jaGFyYWN0ZXJJbmRleH0nOiAke25vdGljZU9iamVjdC5jaGFyYWN0ZXJJbmRleH1gKTtcbiAgICAgICAgfVxuICAgICAgICAvLyAvL3BhcmFtZXRlckFzc2VydChleGNlcnB0IT09dW5kZWZpbmVkLCBcImNQVCBhZGROb3RpY2U6ICdleGNlcnB0JyBwYXJhbWV0ZXIgc2hvdWxkIGJlIGRlZmluZWRcIik7XG4gICAgICAgIGlmIChub3RpY2VPYmplY3QuZXhjZXJwdCkgeyAvL3BhcmFtZXRlckFzc2VydCh0eXBlb2Ygbm90aWNlT2JqZWN0LmV4Y2VycHQgPT09ICdzdHJpbmcnLCBgY1BUIGFkZE5vdGljZTogJ2V4Y2VycHQnIHBhcmFtZXRlciBzaG91bGQgYmUgYSBzdHJpbmcgbm90IGEgJyR7dHlwZW9mIG5vdGljZU9iamVjdC5leGNlcnB0fSc6ICR7bm90aWNlT2JqZWN0LmV4Y2VycHR9YCk7XG4gICAgICAgIH1cbiAgICAgICAgLy9wYXJhbWV0ZXJBc3NlcnQobm90aWNlT2JqZWN0LmxvY2F0aW9uICE9PSB1bmRlZmluZWQsIFwiY1BUIGFkZE5vdGljZTogJ2xvY2F0aW9uJyBwYXJhbWV0ZXIgc2hvdWxkIGJlIGRlZmluZWRcIik7XG4gICAgICAgIC8vcGFyYW1ldGVyQXNzZXJ0KHR5cGVvZiBub3RpY2VPYmplY3QubG9jYXRpb24gPT09ICdzdHJpbmcnLCBgY1BUIGFkZE5vdGljZTogJ2xvY2F0aW9uJyBwYXJhbWV0ZXIgc2hvdWxkIGJlIGEgc3RyaW5nIG5vdCBhICcke3R5cGVvZiBub3RpY2VPYmplY3QubG9jYXRpb259JzogJHtub3RpY2VPYmplY3QubG9jYXRpb259YCk7XG5cbiAgICAgICAgLy8gbm90aWNlT2JqZWN0LmRlYnVnQ2hhaW4gPSBub3RpY2VPYmplY3QuZGVidWdDaGFpbiA/IGBjaGVja1BsYWluVGV4dCgke3RleHRUeXBlfSwgJHt0ZXh0TmFtZX0pICR7bm90aWNlT2JqZWN0LmRlYnVnQ2hhaW59YCA6IGBjaGVja1BsYWluVGV4dCgke3RleHRUeXBlfSwgJHt0ZXh0TmFtZX0pYDtcbiAgICAgICAgY3B0UmVzdWx0Lm5vdGljZUxpc3QucHVzaChub3RpY2VPYmplY3QpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG91ckNoZWNrVGV4dEZpZWxkKGxpbmVOdW1iZXIsIGZpZWxkVGV4dCwgYWxsb3dlZExpbmtzLCBvcHRpb25hbEZpZWxkTG9jYXRpb24sIGNoZWNraW5nT3B0aW9ucykge1xuICAgICAgICAvKipcbiAgICAgICAgKiBAZGVzY3JpcHRpb24gLSBjaGVja3MgdGhlIGdpdmVuIHRleHQgZmllbGQgYW5kIHByb2Nlc3NlcyB0aGUgcmV0dXJuZWQgcmVzdWx0c1xuICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBmaWVsZE5hbWUgLSBuYW1lIG9mIHRoZSBmaWVsZCBiZWluZyBjaGVja2VkXG4gICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGZpZWxkVGV4dCAtIHRoZSBhY3R1YWwgdGV4dCBvZiB0aGUgZmllbGQgYmVpbmcgY2hlY2tlZFxuICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gYWxsb3dlZExpbmtzIC0gdHJ1ZSBpZiBsaW5rcyBhcmUgYWxsb3dlZCBpbiB0aGUgZmllbGQsIG90aGVyd2lzZSBmYWxzZVxuICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25hbEZpZWxkTG9jYXRpb24gLSBkZXNjcmlwdGlvbiBvZiB3aGVyZSB0aGUgZmllbGQgaXMgbG9jYXRlZFxuICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjaGVja2luZ09wdGlvbnMgLSBwYXJhbWV0ZXJzIHRoYXQgbWlnaHQgYWZmZWN0IHRoZSBjaGVja1xuICAgICAgICAqL1xuICAgICAgICAvLyBEb2VzIGJhc2ljIGNoZWNrcyBmb3Igc21hbGwgZXJyb3JzIGxpa2UgbGVhZGluZy90cmFpbGluZyBzcGFjZXMsIGV0Yy5cblxuICAgICAgICAvLyBXZSBhc3N1bWUgdGhhdCBjaGVja2luZyBmb3IgY29tcHVsc29yeSBmaWVsZHMgaXMgZG9uZSBlbHNld2hlcmVcblxuICAgICAgICAvLyBVcGRhdGVzIHRoZSBnbG9iYWwgbGlzdCBvZiBub3RpY2VzXG4gICAgICAgIC8vIGRlYnVnTG9nKGBjUFQgb3VyQ2hlY2tUZXh0RmllbGQoJHtmaWVsZE5hbWV9LCAoJHtmaWVsZFRleHQubGVuZ3RofSksICR7YWxsb3dlZExpbmtzfSwgJHtmaWVsZExvY2F0aW9ufSwg4oCmKWApO1xuICAgICAgICAvL3BhcmFtZXRlckFzc2VydChsaW5lTnVtYmVyICE9PSB1bmRlZmluZWQsIFwiY1BUIG91ckNoZWNrVGV4dEZpZWxkOiAnbGluZU51bWJlcicgcGFyYW1ldGVyIHNob3VsZCBiZSBkZWZpbmVkXCIpO1xuICAgICAgICAvL3BhcmFtZXRlckFzc2VydCh0eXBlb2YgbGluZU51bWJlciA9PT0gJ251bWJlcicsIGBjUFQgb3VyQ2hlY2tUZXh0RmllbGQ6ICdmaWVsZE5hbWUnIHBhcmFtZXRlciBzaG91bGQgYmUgYSBudW1iZXIgbm90IGEgJyR7dHlwZW9mIGxpbmVOdW1iZXJ9J2ApO1xuICAgICAgICAvL3BhcmFtZXRlckFzc2VydChmaWVsZFRleHQgIT09IHVuZGVmaW5lZCwgXCJjUFQgb3VyQ2hlY2tUZXh0RmllbGQ6ICdmaWVsZFRleHQnIHBhcmFtZXRlciBzaG91bGQgYmUgZGVmaW5lZFwiKTtcbiAgICAgICAgLy9wYXJhbWV0ZXJBc3NlcnQodHlwZW9mIGZpZWxkVGV4dCA9PT0gJ3N0cmluZycsIGBjUFQgb3VyQ2hlY2tUZXh0RmllbGQ6ICdmaWVsZFRleHQnIHBhcmFtZXRlciBzaG91bGQgYmUgYSBzdHJpbmcgbm90IGEgJyR7dHlwZW9mIGZpZWxkVGV4dH0nYCk7XG4gICAgICAgIC8vcGFyYW1ldGVyQXNzZXJ0KGFsbG93ZWRMaW5rcyA9PT0gdHJ1ZSB8fCBhbGxvd2VkTGlua3MgPT09IGZhbHNlLCBcImNQVCBvdXJDaGVja1RleHRGaWVsZDogYWxsb3dlZExpbmtzIHBhcmFtZXRlciBtdXN0IGJlIGVpdGhlciB0cnVlIG9yIGZhbHNlXCIpO1xuICAgICAgICAvL3BhcmFtZXRlckFzc2VydChvcHRpb25hbEZpZWxkTG9jYXRpb24gIT09IHVuZGVmaW5lZCwgXCJjUFQgb3VyQ2hlY2tUZXh0RmllbGQ6ICdvcHRpb25hbEZpZWxkTG9jYXRpb24nIHBhcmFtZXRlciBzaG91bGQgYmUgZGVmaW5lZFwiKTtcbiAgICAgICAgLy9wYXJhbWV0ZXJBc3NlcnQodHlwZW9mIG9wdGlvbmFsRmllbGRMb2NhdGlvbiA9PT0gJ3N0cmluZycsIGBjUFQgb3VyQ2hlY2tUZXh0RmllbGQ6ICdvcHRpb25hbEZpZWxkTG9jYXRpb24nIHBhcmFtZXRlciBzaG91bGQgYmUgYSBzdHJpbmcgbm90IGEgJyR7dHlwZW9mIG9wdGlvbmFsRmllbGRMb2NhdGlvbn0nYCk7XG5cbiAgICAgICAgY29uc3QgcmVzdWx0T2JqZWN0ID0gY2hlY2tUZXh0RmllbGQobGFuZ3VhZ2VDb2RlLCByZXBvQ29kZSwgdGV4dFR5cGUsICcnLCBmaWVsZFRleHQsIGFsbG93ZWRMaW5rcywgb3B0aW9uYWxGaWVsZExvY2F0aW9uLCBjaGVja2luZ09wdGlvbnMpO1xuXG4gICAgICAgIC8vIENob29zZSBvbmx5IE9ORSBvZiB0aGUgZm9sbG93aW5nXG4gICAgICAgIC8vIFRoaXMgaXMgdGhlIGZhc3Qgd2F5IG9mIGFwcGVuZCB0aGUgcmVzdWx0cyBmcm9tIHRoaXMgZmllbGRcbiAgICAgICAgLy8gY3B0UmVzdWx0Lm5vdGljZUxpc3QgPSBjcHRSZXN1bHQubm90aWNlTGlzdC5jb25jYXQocmVzdWx0T2JqZWN0Lm5vdGljZUxpc3QpO1xuICAgICAgICAvLyBJZiB3ZSBuZWVkIHRvIHB1dCBldmVyeXRoaW5nIHRocm91Z2ggYWRkTm90aWNlLCBlLmcuLCBmb3IgZGVidWdnaW5nIG9yIGZpbHRlcmluZ1xuICAgICAgICAvLyAgcHJvY2VzcyByZXN1bHRzIGxpbmUgYnkgbGluZVxuICAgICAgICBmb3IgKGNvbnN0IG5vdGljZUVudHJ5IG9mIHJlc3VsdE9iamVjdC5ub3RpY2VMaXN0KVxuICAgICAgICAgICAgYWRkTm90aWNlKHsgLi4ubm90aWNlRW50cnksIGxpbmVOdW1iZXIgfSk7XG4gICAgfVxuICAgIC8vIGVuZCBvZiBvdXJDaGVja1RleHRGaWVsZCBmdW5jdGlvblxuXG4gICAgZnVuY3Rpb24gY2hlY2tQbGFpbkxpbmVDb250ZW50cyhsaW5lTnVtYmVyLCBsaW5lVGV4dCwgbGluZUxvY2F0aW9uKSB7XG5cbiAgICAgICAgLy8gZnVuY3Rpb25Mb2coYGNoZWNrUGxhaW5MaW5lQ29udGVudHMgZm9yICcke2xpbmVOYW1lfScsICcke2xpbmVUZXh0fScgYXQke2xpbmVMb2NhdGlvbn1gKTtcbiAgICAgICAgbGV0IHRoaXNUZXh0ID0gbGluZVRleHQudHJpbVN0YXJ0KCk7IC8vIFNvIHdlIGRvbuKAmXQgZ2V0IFwibGVhZGluZyBzcGFjZVwiIEFORCBcImRvdWJsZWQgc3BhY2VzXCIgZXJyb3JzXG5cbiAgICAgICAgaWYgKHRoaXNUZXh0KVxuICAgICAgICAgICAgLy8gQWxsb3cgbGlua3MgYXMgdGhhdOKAmXMgbW9yZSBnZW5lcmFsXG4gICAgICAgICAgICBvdXJDaGVja1RleHRGaWVsZChsaW5lTnVtYmVyLCB0aGlzVGV4dCwgdHJ1ZSwgbGluZUxvY2F0aW9uLCBjaGVja2luZ09wdGlvbnMpO1xuICAgIH1cbiAgICAvLyBlbmQgb2YgY2hlY2tQbGFpbkxpbmVDb250ZW50cyBmdW5jdGlvblxuXG5cbiAgICAvLyBNYWluIGNvZGUgZm9yIGNoZWNrUGxhaW5UZXh0IGZ1bmN0aW9uXG4gICAgaWYgKGlzV2hpdGVzcGFjZShwbGFpblRleHQpKSB7XG4gICAgICAgIGFkZE5vdGljZSh7IHByaW9yaXR5OiA2MzgsIG1lc3NhZ2U6IFwiT25seSBmb3VuZCB3aGl0ZXNwYWNlXCIsIGxvY2F0aW9uOiBvdXJMb2NhdGlvbiB9KTtcbiAgICAgICAgcmV0dXJuIGNwdFJlc3VsdDtcbiAgICB9XG5cbiAgICBsZXQgY2hhcmFjdGVySW5kZXg7XG4gICAgaWYgKChjaGFyYWN0ZXJJbmRleCA9IHBsYWluVGV4dC5pbmRleE9mKCc8PDw8PDw8JykpID49IDApIHtcbiAgICAgICAgY29uc3QgaXkgPSBjaGFyYWN0ZXJJbmRleCArIGV4Y2VycHRIYWxmTGVuZ3RoOyAvLyBXYW50IGV4Y2VycHQgdG8gZm9jdXMgbW9yZSBvbiB3aGF0IGZvbGxvd3NcbiAgICAgICAgY29uc3QgZXhjZXJwdCA9IChpeSA+IGV4Y2VycHRIYWxmTGVuZ3RoID8gJ+KApicgOiAnJykgKyBwbGFpblRleHQuc3Vic3RyaW5nKGl5IC0gZXhjZXJwdEhhbGZMZW5ndGgsIGl5ICsgZXhjZXJwdEhhbGZMZW5ndGhQbHVzKS5yZXBsYWNlKC8gL2csICfikKMnKSArIChpeSArIGV4Y2VycHRIYWxmTGVuZ3RoUGx1cyA8IHBsYWluVGV4dC5sZW5ndGggPyAn4oCmJyA6ICcnKVxuICAgICAgICBhZGROb3RpY2UoeyBwcmlvcml0eTogOTkzLCBtZXNzYWdlOiBcIlVucmVzb2x2ZWQgR0lUIGNvbmZsaWN0XCIsIGNoYXJhY3RlckluZGV4LCBleGNlcnB0LCBsb2NhdGlvbjogb3VyTG9jYXRpb24gfSk7XG4gICAgfSBlbHNlIGlmICgoY2hhcmFjdGVySW5kZXggPSBwbGFpblRleHQuaW5kZXhPZignPT09PT09PScpKSA+PSAwKSB7XG4gICAgICAgIGNvbnN0IGl5ID0gY2hhcmFjdGVySW5kZXggKyBleGNlcnB0SGFsZkxlbmd0aDsgLy8gV2FudCBleGNlcnB0IHRvIGZvY3VzIG1vcmUgb24gd2hhdCBmb2xsb3dzXG4gICAgICAgIGNvbnN0IGV4Y2VycHQgPSAoaXkgPiBleGNlcnB0SGFsZkxlbmd0aCA/ICfigKYnIDogJycpICsgcGxhaW5UZXh0LnN1YnN0cmluZyhpeSAtIGV4Y2VycHRIYWxmTGVuZ3RoLCBpeSArIGV4Y2VycHRIYWxmTGVuZ3RoUGx1cykucmVwbGFjZSgvIC9nLCAn4pCjJykgKyAoaXkgKyBleGNlcnB0SGFsZkxlbmd0aFBsdXMgPCBwbGFpblRleHQubGVuZ3RoID8gJ+KApicgOiAnJylcbiAgICAgICAgYWRkTm90aWNlKHsgcHJpb3JpdHk6IDk5MiwgbWVzc2FnZTogXCJVbnJlc29sdmVkIEdJVCBjb25mbGljdFwiLCBjaGFyYWN0ZXJJbmRleCwgZXhjZXJwdCwgbG9jYXRpb246IG91ckxvY2F0aW9uIH0pO1xuICAgIH0gZWxzZSBpZiAoKGNoYXJhY3RlckluZGV4ID0gcGxhaW5UZXh0LmluZGV4T2YoJz4+Pj4+Pj4+JykpID49IDApIHtcbiAgICAgICAgY29uc3QgaXkgPSBjaGFyYWN0ZXJJbmRleCArIGV4Y2VycHRIYWxmTGVuZ3RoOyAvLyBXYW50IGV4Y2VycHQgdG8gZm9jdXMgbW9yZSBvbiB3aGF0IGZvbGxvd3NcbiAgICAgICAgY29uc3QgZXhjZXJwdCA9IChpeSA+IGV4Y2VycHRIYWxmTGVuZ3RoID8gJ+KApicgOiAnJykgKyBwbGFpblRleHQuc3Vic3RyaW5nKGl5IC0gZXhjZXJwdEhhbGZMZW5ndGgsIGl5ICsgZXhjZXJwdEhhbGZMZW5ndGhQbHVzKS5yZXBsYWNlKC8gL2csICfikKMnKSArIChpeSArIGV4Y2VycHRIYWxmTGVuZ3RoUGx1cyA8IHBsYWluVGV4dC5sZW5ndGggPyAn4oCmJyA6ICcnKVxuICAgICAgICBhZGROb3RpY2UoeyBwcmlvcml0eTogOTkxLCBtZXNzYWdlOiBcIlVucmVzb2x2ZWQgR0lUIGNvbmZsaWN0XCIsIGNoYXJhY3RlckluZGV4LCBleGNlcnB0LCBsb2NhdGlvbjogb3VyTG9jYXRpb24gfSk7XG4gICAgfVxuXG4gICAgaWYgKHBsYWluVGV4dFswXSA9PT0gJ1xcbicpIHtcbiAgICAgICAgY2hhcmFjdGVySW5kZXggPSAwO1xuICAgICAgICBjb25zdCBleGNlcnB0ID0gKHBsYWluVGV4dC5sZW5ndGggPiBleGNlcnB0TGVuZ3RoID8gJ+KApicgOiAnJykgKyBwbGFpblRleHQuc2xpY2UoLWV4Y2VycHRMZW5ndGgpLnJlcGxhY2UoLyAvZywgJ+KQoycpLnJlcGxhY2UoL1xcbi9nLCAnXFxcXG4nKVxuICAgICAgICBhZGROb3RpY2UoeyBwcmlvcml0eTogNTM5LCBtZXNzYWdlOiBcIkZpbGUgc3RhcnRzIHdpdGggZW1wdHkgbGluZVwiLCBjaGFyYWN0ZXJJbmRleCwgZXhjZXJwdCwgbG9jYXRpb246IG91ckxvY2F0aW9uIH0pO1xuICAgIH1cbiAgICBpZiAoIXBsYWluVGV4dC5lbmRzV2l0aCgnXFxuJykgJiYgIXRleHROYW1lLmVuZHNXaXRoKCd0aXRsZS5tZCcpKSB7XG4gICAgICAgIGNoYXJhY3RlckluZGV4ID0gcGxhaW5UZXh0Lmxlbmd0aCAtIDE7XG4gICAgICAgIGNvbnN0IGV4Y2VycHQgPSAocGxhaW5UZXh0Lmxlbmd0aCA+IGV4Y2VycHRMZW5ndGggPyAn4oCmJyA6ICcnKSArIHBsYWluVGV4dC5zbGljZSgtZXhjZXJwdExlbmd0aCkucmVwbGFjZSgvIC9nLCAn4pCjJykucmVwbGFjZSgvXFxuL2csICdcXFxcbicpXG4gICAgICAgIGFkZE5vdGljZSh7IHByaW9yaXR5OiA1MzgsIG1lc3NhZ2U6IFwiRmlsZSBlbmRzIHdpdGhvdXQgbmV3bGluZSBjaGFyYWN0ZXJcIiwgY2hhcmFjdGVySW5kZXgsIGV4Y2VycHQsIGxvY2F0aW9uOiBvdXJMb2NhdGlvbiB9KTtcbiAgICB9XG4gICAgZWxzZSBpZiAocGxhaW5UZXh0LmVuZHNXaXRoKCdcXG5cXG4nKSkge1xuICAgICAgICBjaGFyYWN0ZXJJbmRleCA9IHBsYWluVGV4dC5sZW5ndGggLSAyO1xuICAgICAgICBjb25zdCBleGNlcnB0ID0gKHBsYWluVGV4dC5sZW5ndGggPiBleGNlcnB0TGVuZ3RoID8gJ+KApicgOiAnJykgKyBwbGFpblRleHQuc2xpY2UoLWV4Y2VycHRMZW5ndGgpLnJlcGxhY2UoLyAvZywgJ+KQoycpLnJlcGxhY2UoL1xcbi9nLCAnXFxcXG4nKVxuICAgICAgICBhZGROb3RpY2UoeyBwcmlvcml0eTogMTM4LCBtZXNzYWdlOiBcIkZpbGUgZW5kcyB3aXRoIGFkZGl0aW9uYWwgYmxhbmsgbGluZShzKVwiLCBjaGFyYWN0ZXJJbmRleCwgZXhjZXJwdCwgbG9jYXRpb246IG91ckxvY2F0aW9uIH0pO1xuICAgIH1cblxuICAgIGNvbnN0IGxpbmVzID0gcGxhaW5UZXh0LnNwbGl0KCdcXG4nKTtcbiAgICAvLyBkZWJ1Z0xvZyhgICAnJHtsb2NhdGlvbn0nIGhhcyAke2xpbmVzLmxlbmd0aC50b0xvY2FsZVN0cmluZygpfSB0b3RhbCBsaW5lc2ApO1xuICAgIC8vICBjaGVja2luZyBuZXN0ZWQgbWFya2VycyAoc28gdGhhdCB3ZSBjYW4gZ2l2ZSB0aGUgbGluZSBudW1iZXIgaW4gdGhlIG5vdGljZSlcbiAgICAvLyBsZXQgaGVhZGVyTGV2ZWwgPSAwO1xuICAgIC8vIGxldCBsYXN0TnVtTGVhZGluZ1NwYWNlcyA9IDA7XG4gICAgLy8gbGV0IGxhc3RMaW5lQ29udGVudHM7XG4gICAgLy8gV2hpbGUgY2hlY2tpbmcgaW5kaXZpZHVhbCBsaW5lcyxcbiAgICBjb25zdCBvcGVuTWFya2VycyA9IFtdO1xuICAgIGZvciAobGV0IG4gPSAxOyBuIDw9IGxpbmVzLmxlbmd0aDsgbisrKSB7XG5cbiAgICAgICAgY29uc3QgbGluZSA9IGxpbmVzW24gLSAxXTtcbiAgICAgICAgaWYgKGxpbmUpIHtcbiAgICAgICAgICAgIGlmICh0ZXh0VHlwZSA9PT0gJ3RleHQnIHx8IHRleHRUeXBlID09PSAncmF3JykgLy8gb3RoZXIgZmlsZS10eXBlcyBkbyB0aGVzZSBjaGVja3MgdGhlbXNlbHZlc1xuICAgICAgICAgICAgICAgIGNoZWNrUGxhaW5MaW5lQ29udGVudHMobiwgbGluZSwgb3VyTG9jYXRpb24pO1xuXG4gICAgICAgICAgICAvLyBDaGVjayBmb3IgbmVzdGVkIGJyYWNrZXRzIGFuZCBxdW90ZXMsIGV0Yy5cbiAgICAgICAgICAgIGZvciAobGV0IGNoYXJhY3RlckluZGV4ID0gMDsgY2hhcmFjdGVySW5kZXggPCBsaW5lLmxlbmd0aDsgY2hhcmFjdGVySW5kZXgrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNoYXIgPSBsaW5lW2NoYXJhY3RlckluZGV4XTtcbiAgICAgICAgICAgICAgICBsZXQgY2xvc2VDaGFyYWN0ZXJJbmRleDtcbiAgICAgICAgICAgICAgICBpZiAoUEFJUkVEX1BVTkNUVUFUSU9OX09QRU5FUlMuaW5kZXhPZihjaGFyKSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGRlYnVnTG9nKGBTYXZpbmcgJHtvcGVuTWFya2Vycy5sZW5ndGh9ICcke2NoYXJ9JyAke259ICR7eH1gKTtcbiAgICAgICAgICAgICAgICAgICAgb3Blbk1hcmtlcnMucHVzaCh7IGNoYXIsIG4sIHg6IGNoYXJhY3RlckluZGV4IH0pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoKGNsb3NlQ2hhcmFjdGVySW5kZXggPSBQQUlSRURfUFVOQ1RVQVRJT05fQ0xPU0VSUy5pbmRleE9mKGNoYXIpKSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGRlYnVnTG9nKGBGb3VuZCAnJHtjaGFyfScgJHtufSAke3h9YCk7XG4gICAgICAgICAgICAgICAgICAgIC8vIGRlYnVnTG9nKGBXaGljaDogJHt3aGljaH0gJyR7b3BlbmVycy5jaGFyQXQod2hpY2gpfSdgKVxuICAgICAgICAgICAgICAgICAgICBpZiAob3Blbk1hcmtlcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBbbGFzdEVudHJ5XSA9IG9wZW5NYXJrZXJzLnNsaWNlKC0xKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGRlYnVnTG9nKGAgIFJlY292ZXJlZCBsYXN0RW50cnk9JHtKU09OLnN0cmluZ2lmeShsYXN0RW50cnkpfWApO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZGVidWdMb2coYCAgQ29tcGFyaW5nIGZvdW5kICcke2NoYXJ9JyB3aXRoICgke3doaWNofSkgJyR7b3BlbmVycy5jaGFyQXQod2hpY2gpfScgZnJvbSAnJHtsYXN0RW50cnkuY2hhcn0nYCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobGFzdEVudHJ5LmNoYXIgPT09IFBBSVJFRF9QVU5DVFVBVElPTl9PUEVORVJTLmNoYXJBdChjbG9zZUNoYXJhY3RlckluZGV4KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGRlYnVnTG9nKGAgIE1hdGNoZWQgJyR7Y2hhcn0nIHdpdGggICcke29wZW5lcnMuY2hhckF0KHdoaWNoKX0nICR7bn0gJHt4fWApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wZW5NYXJrZXJzLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIC8vIHNvbWV0aGluZyBpcyBzdGlsbCBvcGVuIGFuZCB0aGlzIGlzbuKAmXQgYSBtYXRjaCAtLSBtaWdodCBqdXN0IGJlIGNvbnNlcXVlbnRpYWwgZXJyb3JcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2hhciAhPT0gJ+KAmScgLy8gQ2xvc2luZyBzaW5nbGUgcXVvdGUgaXMgYWxzbyB1c2VkIGFzIGFwb3N0cm9waGUgaW4gRW5nbGlzaFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAmJiAodGV4dFR5cGUgIT09ICdtYXJrZG93bicgfHwgY2hhciAhPT0gJz4nIHx8IGNoYXJhY3RlckluZGV4ID4gNCkpIHsgLy8gTWFya2Rvd24gdXNlcyA+IG9yID4+IG9yID4gPiBvciA+ID4gPiBmb3IgYmxvY2sgaW5kZW50cyBzbyBpZ25vcmUgdGhlc2UgLS0gbWlnaHQganVzdCBiZSBjb25zZXF1ZW50aWFsIGVycm9yXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGV4Y2VycHQgPSAoY2hhcmFjdGVySW5kZXggPiBleGNlcnB0SGFsZkxlbmd0aCA/ICfigKYnIDogJycpICsgbGluZS5zdWJzdHJpbmcoY2hhcmFjdGVySW5kZXggLSBleGNlcnB0SGFsZkxlbmd0aCwgY2hhcmFjdGVySW5kZXggKyBleGNlcnB0SGFsZkxlbmd0aFBsdXMpLnJlcGxhY2UoLyAvZywgJ+KQoycpICsgKGNoYXJhY3RlckluZGV4ICsgZXhjZXJwdEhhbGZMZW5ndGhQbHVzIDwgbGluZS5sZW5ndGggPyAn4oCmJyA6ICcnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBkZXRhaWxzID0gYCcke2xhc3RFbnRyeS5jaGFyfScgb3BlbmVkIG9uIGxpbmUgJHtsYXN0RW50cnkubn0gY2hhcmFjdGVyICR7bGFzdEVudHJ5LnggKyAxfWA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkZE5vdGljZSh7IHByaW9yaXR5OiA3NzcsIG1lc3NhZ2U6IGBCYWQgcHVuY3R1YXRpb24gbmVzdGluZzogJHtjaGFyfSBjbG9zaW5nIGNoYXJhY3RlciBkb2VzbuKAmXQgbWF0Y2hgLCBkZXRhaWxzLCBsaW5lTnVtYmVyOiBuLCBjaGFyYWN0ZXJJbmRleCwgZXhjZXJwdCwgbG9jYXRpb246IG91ckxvY2F0aW9uIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBkZWJ1Z0xvZyhgICBFUlJPUiA3Nzc6IG1pc21hdGNoZWQgY2hhcmFjdGVyczogJHtkZXRhaWxzfWApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIC8vIENsb3NlZCBzb21ldGhpbmcgdW5leHBlY3RlZGx5IHdpdGhvdXQgYW4gb3BlbmVyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2hhciAhPT0gJ+KAmScgLy8gQ2xvc2luZyBzaW5nbGUgcXVvdGUgaXMgYWxzbyB1c2VkIGFzIGFwb3N0cm9waGUgaW4gRW5nbGlzaFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICYmICh0ZXh0VHlwZSAhPT0gJ21hcmtkb3duJyB8fCBjaGFyICE9PSAnPicpKSB7IC8vIE1hcmtkb3duIHVzZXMgPiBmb3IgYmxvY2sgaW5kZW50cyBzbyBpZ25vcmUgdGhlc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBleGNlcnB0ID0gKGNoYXJhY3RlckluZGV4ID4gZXhjZXJwdEhhbGZMZW5ndGggPyAn4oCmJyA6ICcnKSArIGxpbmUuc3Vic3RyaW5nKGNoYXJhY3RlckluZGV4IC0gZXhjZXJwdEhhbGZMZW5ndGgsIGNoYXJhY3RlckluZGV4ICsgZXhjZXJwdEhhbGZMZW5ndGhQbHVzKS5yZXBsYWNlKC8gL2csICfikKMnKSArIChjaGFyYWN0ZXJJbmRleCArIGV4Y2VycHRIYWxmTGVuZ3RoUGx1cyA8IGxpbmUubGVuZ3RoID8gJ+KApicgOiAnJylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGROb3RpY2UoeyBwcmlvcml0eTogNzc0LCBtZXNzYWdlOiBgVW5leHBlY3RlZCAke2NoYXJ9IGNsb3NpbmcgY2hhcmFjdGVyIChubyBtYXRjaGluZyBvcGVuZXIpYCwgbGluZU51bWJlcjogbiwgY2hhcmFjdGVySW5kZXgsIGV4Y2VycHQsIGxvY2F0aW9uOiBvdXJMb2NhdGlvbiB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBkZWJ1Z0xvZyhgICBFUlJPUiA3NzQ6IGNsb3NlZCB3aXRoIG5vdGhpbmcgb3BlbjogJHtjaGFyfWApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gVGhpcyBpcyBhIGJsYW5rIGxpbmVcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGxhc3RMaW5lQ29udGVudHMgPSBsaW5lO1xuICAgIH1cbiAgICAvLyAgQXQgdGhlIGVuZCBvZiB0aGUgdGV4dCAtLSBjaGVjayBmb3IgbGVmdC1vdmVyIG9wZW5pbmcgY2hhcmFjdGVycyAodW5jbG9zZWQpXG4gICAgaWYgKG9wZW5NYXJrZXJzLmxlbmd0aCkge1xuICAgICAgICBjb25zdCBbeyBjaGFyLCBuLCB4IH1dID0gb3Blbk1hcmtlcnMuc2xpY2UoLTEpO1xuICAgICAgICBjb25zdCBsaW5lID0gbGluZXNbbiAtIDFdO1xuICAgICAgICBjb25zdCBleGNlcnB0ID0gKHggPiBleGNlcnB0SGFsZkxlbmd0aCA/ICfigKYnIDogJycpICsgbGluZS5zdWJzdHJpbmcoeCAtIGV4Y2VycHRIYWxmTGVuZ3RoLCB4ICsgZXhjZXJwdEhhbGZMZW5ndGhQbHVzKS5yZXBsYWNlKC8gL2csICfikKMnKSArICh4ICsgZXhjZXJwdEhhbGZMZW5ndGhQbHVzIDwgbGluZS5sZW5ndGggPyAn4oCmJyA6ICcnKVxuICAgICAgICBjb25zdCBkZXRhaWxzID0gb3Blbk1hcmtlcnMubGVuZ3RoID4gMSA/IGAke29wZW5NYXJrZXJzLmxlbmd0aH0gdW5jbG9zZWQgc2V0JHtvcGVuTWFya2Vycy5sZW5ndGggPT09IDEgPyAnJyA6ICdzJ31gIDogbnVsbDtcbiAgICAgICAgYWRkTm90aWNlKHsgcHJpb3JpdHk6IDc2OCwgbWVzc2FnZTogYEF0IGVuZCBvZiB0ZXh0IHdpdGggdW5jbG9zZWQgJHtjaGFyfSBvcGVuaW5nIGNoYXJhY3RlcmAsIGRldGFpbHMsIGxpbmVOdW1iZXI6IG4sIGNoYXJhY3RlckluZGV4OiB4LCBleGNlcnB0LCBsb2NhdGlvbjogb3VyTG9jYXRpb24gfSk7XG4gICAgfVxuXG4gICAgLy8gVE9ETzogSXMgdGhpcyBhIGR1cGxpY2F0ZSBvZiB0aGUgYWJvdmUgc2VjdGlvbiBhYm91dCBuZXN0aW5nP1xuICAgIC8vIENoZWNrIG1hdGNoZWQgcGFpcnMgaW4gdGhlIGVudGlyZSBmaWxlXG4gICAgZm9yIChjb25zdCBwdW5jdFNldCBvZiBPUEVOX0NMT1NFX1BVTkNUVUFUSU9OX1BBSVJTKSB7XG4gICAgICAgIC8vIENhbuKAmXQgY2hlY2sgJ+KAmOKAmScgY296IHRoZXkgbWlnaHQgYmUgdXNlZCBhcyBhcG9zdHJvcGhlXG4gICAgICAgIGNvbnN0IGxlZnRDaGFyID0gcHVuY3RTZXRbMF0sIHJpZ2h0Q2hhciA9IHB1bmN0U2V0WzFdO1xuICAgICAgICBjb25zdCBsZWZ0Q291bnQgPSBjb3VudE9jY3VycmVuY2VzKHBsYWluVGV4dCwgbGVmdENoYXIpLFxuICAgICAgICAgICAgcmlnaHRDb3VudCA9IGNvdW50T2NjdXJyZW5jZXMocGxhaW5UZXh0LCByaWdodENoYXIpO1xuICAgICAgICBpZiAobGVmdENvdW50ICE9PSByaWdodENvdW50XG4gICAgICAgICAgICAmJiAocmlnaHRDaGFyICE9PSAn4oCZJyB8fCBsZWZ0Q291bnQgPiByaWdodENvdW50KSAvLyBDbG9zaW5nIHNpbmdsZSBxdW90ZSBpcyBhbHNvIHVzZWQgYXMgYXBvc3Ryb3BoZSBpbiBFbmdsaXNoXG4gICAgICAgICAgICAmJiAodGV4dFR5cGUgIT09ICdtYXJrZG93bicgfHwgcmlnaHRDaGFyICE9PSAnPicpKSAvLyBtYXJrZG93biB1c2VzID4gYXMgYSBibG9jayBxdW90ZSBjaGFyYWN0ZXJcbiAgICAgICAgICAgIC8vIE5PVEU6IFRoZXNlIGFyZSBsb3dlciBwcmlvcml0eSB0aGFuIHNpbWlsYXIgY2hlY2tzIGluIGEgZmllbGRcbiAgICAgICAgICAgIC8vICAgICAgICAgIHNpbmNlIHRoZXkgb2NjdXIgb25seSB3aXRoaW4gdGhlIGVudGlyZSBmaWxlXG4gICAgICAgICAgICBhZGROb3RpY2UoeyBwcmlvcml0eTogbGVmdENoYXIgPT09ICfigJwnID8gMTYyIDogNDYyLCBtZXNzYWdlOiBgTWlzbWF0Y2hlZCAke2xlZnRDaGFyfSR7cmlnaHRDaGFyfSBjaGFyYWN0ZXJzYCwgZGV0YWlsczogYGxlZnQ9JHtsZWZ0Q291bnQudG9Mb2NhbGVTdHJpbmcoKX0sIHJpZ2h0PSR7cmlnaHRDb3VudC50b0xvY2FsZVN0cmluZygpfWAsIGxvY2F0aW9uOiBvdXJMb2NhdGlvbiB9KTtcbiAgICB9XG5cbiAgICBpZiAoIWNoZWNraW5nT3B0aW9ucz8uc3VwcHJlc3NOb3RpY2VEaXNhYmxpbmdGbGFnKSB7XG4gICAgICAgIC8vIGZ1bmN0aW9uTG9nKGBjaGVja1BsYWluVGV4dDogY2FsbGluZyByZW1vdmVEaXNhYmxlZE5vdGljZXMoJHtjcHRSZXN1bHQubm90aWNlTGlzdC5sZW5ndGh9KSBoYXZpbmcgJHtKU09OLnN0cmluZ2lmeShjaGVja2luZ09wdGlvbnMpfWApO1xuICAgICAgICBjcHRSZXN1bHQubm90aWNlTGlzdCA9IHJlbW92ZURpc2FibGVkTm90aWNlcyhjcHRSZXN1bHQubm90aWNlTGlzdCk7XG4gICAgfVxuXG4gICAgYWRkU3VjY2Vzc01lc3NhZ2UoYENoZWNrZWQgYWxsICR7bGluZXMubGVuZ3RoLnRvTG9jYWxlU3RyaW5nKCl9IGxpbmUke2xpbmVzLmxlbmd0aCA9PT0gMSA/ICcnIDogJ3MnfSR7b3VyTG9jYXRpb259LmApO1xuICAgIGlmIChjcHRSZXN1bHQubm90aWNlTGlzdC5sZW5ndGgpXG4gICAgICAgIGFkZFN1Y2Nlc3NNZXNzYWdlKGBjaGVja1BsYWluVGV4dCB2JHtQTEFJTl9URVhUX1ZBTElEQVRPUl9WRVJTSU9OX1NUUklOR30gZmluaXNoZWQgd2l0aCAke2NwdFJlc3VsdC5ub3RpY2VMaXN0Lmxlbmd0aCA/IGNwdFJlc3VsdC5ub3RpY2VMaXN0Lmxlbmd0aC50b0xvY2FsZVN0cmluZygpIDogXCJ6ZXJvXCJ9IG5vdGljZSR7Y3B0UmVzdWx0Lm5vdGljZUxpc3QubGVuZ3RoID09PSAxID8gJycgOiAncyd9YCk7XG4gICAgZWxzZVxuICAgICAgICBhZGRTdWNjZXNzTWVzc2FnZShgTm8gZXJyb3JzIG9yIHdhcm5pbmdzIGZvdW5kIGJ5IGNoZWNrUGxhaW5UZXh0IHYke1BMQUlOX1RFWFRfVkFMSURBVE9SX1ZFUlNJT05fU1RSSU5HfWApXG4gICAgLy8gZGVidWdMb2coYCAgY2hlY2tQbGFpblRleHQgcmV0dXJuaW5nIHdpdGggJHtyZXN1bHQuc3VjY2Vzc0xpc3QubGVuZ3RoLnRvTG9jYWxlU3RyaW5nKCl9IHN1Y2Nlc3MoZXMpLCAke3Jlc3VsdC5ub3RpY2VMaXN0Lmxlbmd0aC50b0xvY2FsZVN0cmluZygpfSBub3RpY2UocykuYCk7XG4gICAgLy8gZGVidWdMb2coXCJjaGVja1BsYWluVGV4dCByZXN1bHQgaXNcIiwgSlNPTi5zdHJpbmdpZnkocmVzdWx0KSk7XG4gICAgcmV0dXJuIGNwdFJlc3VsdDtcbn1cbi8vIGVuZCBvZiBjaGVja1BsYWluVGV4dCBmdW5jdGlvblxuIl19