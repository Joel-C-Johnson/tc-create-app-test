"use strict";var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");Object.defineProperty(exports, "__esModule", { value: true });exports.checkMarkdownFileContents = checkMarkdownFileContents;var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));var _defaults = require("./defaults");
var _markdownTextCheck = require("./markdown-text-check");
var _fileTextCheck = require("./file-text-check");

var _utilities = require("./utilities");function _createForOfIteratorHelper(o, allowArrayLike) {var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];if (!it) {if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {if (it) o = it;var i = 0;var F = function F() {};return { s: F, n: function n() {if (i >= o.length) return { done: true };return { done: false, value: o[i++] };}, e: function e(_e) {throw _e;}, f: F };}throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");}var normalCompletion = true,didErr = false,err;return { s: function s() {it = it.call(o);}, n: function n() {var step = it.next();normalCompletion = step.done;return step;}, e: function e(_e2) {didErr = true;err = _e2;}, f: function f() {try {if (!normalCompletion && it.return != null) it.return();} finally {if (didErr) throw err;}} };}function _unsupportedIterableToArray(o, minLen) {if (!o) return;if (typeof o === "string") return _arrayLikeToArray(o, minLen);var n = Object.prototype.toString.call(o).slice(8, -1);if (n === "Object" && o.constructor) n = o.constructor.name;if (n === "Map" || n === "Set") return Array.from(o);if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);}function _arrayLikeToArray(arr, len) {if (len == null || len > arr.length) len = arr.length;for (var i = 0, arr2 = new Array(len); i < len; i++) {arr2[i] = arr[i];}return arr2;}function ownKeys(object, enumerableOnly) {var keys = Object.keys(object);if (Object.getOwnPropertySymbols) {var symbols = Object.getOwnPropertySymbols(object);if (enumerableOnly) {symbols = symbols.filter(function (sym) {return Object.getOwnPropertyDescriptor(object, sym).enumerable;});}keys.push.apply(keys, symbols);}return keys;}function _objectSpread(target) {for (var i = 1; i < arguments.length; i++) {var source = arguments[i] != null ? arguments[i] : {};if (i % 2) {ownKeys(Object(source), true).forEach(function (key) {(0, _defineProperty2.default)(target, key, source[key]);});} else if (Object.getOwnPropertyDescriptors) {Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));} else {ownKeys(Object(source)).forEach(function (key) {Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));});}}return target;}


var MARKDOWN_FILE_VALIDATOR_VERSION_STRING = '0.4.4';


/**
 *
 * @param {string} languageCode
 * @param {string} repoCode -- e.g., 'TW', 'TA', 'TQ', or 'OBS', etc.
 * @param {string} markdownFilename -- used for identification
 * @param {string} markdownText -- the actual text to be checked
 * @param {string} givenLocation
 * @param {Object} checkingOptions
 */function
checkMarkdownFileContents(_x, _x2, _x3, _x4, _x5, _x6) {return _checkMarkdownFileContents.apply(this, arguments);}






































































































































// end of checkMarkdownFileContents function
function _checkMarkdownFileContents() {_checkMarkdownFileContents = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee2(languageCode, repoCode, markdownFilename, markdownText, givenLocation, checkingOptions) {var ourLocation, excerptLength, result, addSuccessMessage, addNoticePartial, ourCheckMarkdownText, _ourCheckMarkdownText, ourFileTextCheck;return _regenerator.default.wrap(function _callee2$(_context2) {while (1) {switch (_context2.prev = _context2.next) {case 0:ourFileTextCheck = function _ourFileTextCheck(markdownText, optionalFieldLocation, checkingOptions) {// Does basic checks for small errors like leading/trailing spaces, etc.
              // We assume that checking for compulsory fields is done elsewhere
              // Updates the global list of notices
              // debugLog(`cMdFC ourFileTextCheck(${markdownText}, (${markdownText.length}), ${optionalFieldLocation}, ${JSON.stringify(checkingOptions)})`);
              //parameterAssert(markdownText !== undefined, "cMdFC ourFileTextCheck: 'markdownText' parameter should be defined");
              //parameterAssert(typeof markdownText === 'string', `cMdFC ourFileTextCheck: 'markdownText' parameter should be a string not a '${typeof markdownText}'`);
              //parameterAssert(checkingOptions !== undefined, "cMdFC ourFileTextCheck: 'checkingOptions' parameter should be defined");
              var ctfcResultObject = (0, _fileTextCheck.checkTextfileContents)(languageCode, repoCode, 'markdown', markdownFilename, markdownText, optionalFieldLocation, checkingOptions); // debugLog(`ctfcResultObject=${JSON.stringify(ctfcResultObject)}`);
              // If we need to put everything through addNoticePartial, e.g., for debugging or filtering
              //  process results line by line
              var _iterator = _createForOfIteratorHelper(ctfcResultObject.noticeList),_step;try {for (_iterator.s(); !(_step = _iterator.n()).done;) {var noticeEntry = _step.value;addNoticePartial(noticeEntry);}} catch (err) {_iterator.e(err);} finally {_iterator.f();}};_ourCheckMarkdownText = function _ourCheckMarkdownText3() {_ourCheckMarkdownText = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee(markdownText, optionalFieldLocation, checkingOptions) {var cmtResultObject, _iterator2, _step2, noticeEntry;return _regenerator.default.wrap(function _callee$(_context) {while (1) {switch (_context.prev = _context.next) {case 0:_context.next = 2;return (0, _markdownTextCheck.checkMarkdownText)(languageCode, repoCode, markdownFilename, markdownText, optionalFieldLocation, checkingOptions);case 2:cmtResultObject = _context.sent; // debugLog(`cmtResultObject=${JSON.stringify(cmtResultObject)}`);
                        // If we need to put everything through addNoticePartial, e.g., for debugging or filtering
                        //  process results line by line
                        _iterator2 = _createForOfIteratorHelper(cmtResultObject.noticeList);try {for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {noticeEntry = _step2.value;addNoticePartial(noticeEntry);}} catch (err) {_iterator2.e(err);} finally {_iterator2.f();}case 5:case "end":return _context.stop();}}}, _callee);}));return _ourCheckMarkdownText.apply(this, arguments);};ourCheckMarkdownText = function _ourCheckMarkdownText2(_x7, _x8, _x9) {return _ourCheckMarkdownText.apply(this, arguments);};addNoticePartial = function _addNoticePartial(noticeObject) {// functionLog(`checkMarkdownFileContents addNoticePartial: (priority=${noticeObject.priority}) ${noticeObject.message}${noticeObject.characterIndex > 0 ? ` (at character ${noticeObject.characterIndex})` : ""}${noticeObject.excerpt ? " " + noticeObject.excerpt : ""}${noticeObject.location}`);
              //parameterAssert(noticeObject.priority !== undefined, "cMdT addNoticePartial: 'priority' parameter should be defined");
              //parameterAssert(typeof noticeObject.priority === 'number', `cMdT addNoticePartial: 'priority' parameter should be a number not a '${typeof noticeObject.priority}': ${noticeObject.priority}`);
              //parameterAssert(noticeObject.message !== undefined, "cMdT addNoticePartial: 'message' parameter should be defined");
              //parameterAssert(typeof noticeObject.message === 'string', `cMdT addNoticePartial: 'message' parameter should be a string not a '${typeof noticeObject.message}': ${noticeObject.message}`);
              // //parameterAssert(characterIndex !== undefined, "cMdT addNoticePartial: 'characterIndex' parameter should be defined");
              if (noticeObject.characterIndex) {//parameterAssert(typeof noticeObject.characterIndex === 'number', `cMdT addNoticePartial: 'characterIndex' parameter should be a number not a '${typeof noticeObject.characterIndex}': ${noticeObject.characterIndex}`);
              } // //parameterAssert(excerpt !== undefined, "cMdT addNoticePartial: 'excerpt' parameter should be defined");
              if (noticeObject.excerpt) {//parameterAssert(typeof noticeObject.excerpt === 'string', `cMdT addNoticePartial: 'excerpt' parameter should be a string not a '${typeof noticeObject.excerpt}': ${noticeObject.excerpt}`);
              } //parameterAssert(noticeObject.location !== undefined, "cMdT addNoticePartial: 'location' parameter should be defined");
              //parameterAssert(typeof noticeObject.location === 'string', `cMdT addNoticePartial: 'location' parameter should be a string not a '${typeof noticeObject.location}': ${noticeObject.location}`);
              if (noticeObject.debugChain) noticeObject.debugChain = "checkMarkdownFileContents ".concat(noticeObject.debugChain); // Prepend our name
              result.noticeList.push(_objectSpread(_objectSpread({}, noticeObject), {}, { filename: markdownFilename }));};addSuccessMessage = function _addSuccessMessage(successString) {// debugLog("checkMarkdownFileContents success: " + successString);
              result.successList.push(successString);}; /* This function is optimised for checking the entire markdown file, i.e., all lines.
              Returns a result object containing a successList and a noticeList
             */ // functionLog(`checkMarkdownFileContents(lC=${languageCode}, rC=${repoCode}, fn=${markdownFilename}, ${markdownText.length}, ${givenLocation})â€¦`);
            //parameterAssert(languageCode !== undefined, "checkMarkdownFileContents: 'languageCode' parameter should be defined");
            //parameterAssert(typeof languageCode === 'string', `checkMarkdownFileContents: 'languageCode' parameter should be a string not a '${typeof languageCode}': ${languageCode}`);
            if (markdownFilename !== 'LICENSE.md' && markdownFilename !== 'README.md') {//parameterAssert(repoCode === 'TW' || repoCode === 'TA' || repoCode === 'TQ' || repoCode === 'OBS' || repoCode === 'OBS-TQ', `checkMarkdownFileContents: 'repoCode' parameter should be 'TW', 'TA', 'TQ', 'OBS', or 'OBS-TQ' not '${repoCode}'`);
            } //parameterAssert(markdownFilename !== undefined, "checkMarkdownFileContents: 'markdownFilename' parameter should be defined");
            //parameterAssert(typeof markdownFilename === 'string', `checkMarkdownFileContents: 'markdownFilename' parameter should be a string not a '${typeof markdownFilename}': ${markdownFilename}`);
            //parameterAssert(markdownText !== undefined, "checkMarkdownFileContents: 'markdownText' parameter should be defined");
            //parameterAssert(typeof markdownText === 'string', `checkMarkdownFileContents: 'markdownText' parameter should be a string not a '${typeof markdownText}': ${markdownText}`);
            //parameterAssert(givenLocation !== undefined, "checkMarkdownFileContents: 'givenLocation' parameter should be defined");
            //parameterAssert(typeof givenLocation === 'string', `checkMarkdownFileContents: 'givenLocation' parameter should be a string not a '${typeof givenLocation}': ${givenLocation}`);
            //parameterAssert(givenLocation.indexOf('true') === -1, `checkMarkdownFileContents: 'givenLocation' parameter should not be '${givenLocation}'`);
            if (checkingOptions !== undefined) {//parameterAssert(typeof checkingOptions === 'object', `checkMarkdownFileContents: 'checkingOptions' parameter should be an object not a '${typeof checkingOptions}': ${JSON.stringify(checkingOptions)}`);
            }ourLocation = givenLocation;if (ourLocation && ourLocation[0] !== ' ') ourLocation = " ".concat(ourLocation);try {excerptLength = checkingOptions === null || checkingOptions === void 0 ? void 0 : checkingOptions.excerptLength;} catch (mdtcError) {}if (typeof excerptLength !== 'number' || isNaN(excerptLength)) {excerptLength = _defaults.DEFAULT_EXCERPT_LENGTH; // debugLog("Using default excerptLength=" + excerptLength);
            } // else
            // debugLog("Using supplied excerptLength=" + excerptLength, `cf. default=${DEFAULT_EXCERPT_LENGTH}`);
            // const excerptHalfLength = Math.floor(excerptLength / 2); // rounded down
            // const excerptHalfLengthPlus = Math.floor((excerptLength + 1) / 2); // rounded up
            // debugLog("Using excerptHalfLength=" + excerptHalfLength, `excerptHalfLengthPlus=${excerptHalfLengthPlus}`);
            result = { successList: [], noticeList: [] };_context2.next = 14;return ourCheckMarkdownText(markdownText, givenLocation, checkingOptions);case 14:ourFileTextCheck(markdownText, givenLocation, checkingOptions);addSuccessMessage("Checked markdown file: ".concat(markdownFilename));if (result.noticeList.length) addSuccessMessage("checkMarkdownFileContents v".concat(MARKDOWN_FILE_VALIDATOR_VERSION_STRING, " finished with ").concat(result.noticeList.length ? result.noticeList.length.toLocaleString() : "zero", " notice").concat(result.noticeList.length === 1 ? '' : 's'));else addSuccessMessage("No errors or warnings found by checkMarkdownFileContents v".concat(MARKDOWN_FILE_VALIDATOR_VERSION_STRING)); // debugLog(`  checkMarkdownFileContents returning with ${result.successList.length.toLocaleString()} success(es), ${result.noticeList.length.toLocaleString()} notice(s).`);
            // userLog(`checkMarkdownFileContents result is ${JSON.stringify(result)}`);
            return _context2.abrupt("return", result);case 18:case "end":return _context2.stop();}}}, _callee2);}));return _checkMarkdownFileContents.apply(this, arguments);}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9jb3JlL21hcmtkb3duLWZpbGUtY29udGVudHMtY2hlY2suanMiXSwibmFtZXMiOlsiTUFSS0RPV05fRklMRV9WQUxJREFUT1JfVkVSU0lPTl9TVFJJTkciLCJjaGVja01hcmtkb3duRmlsZUNvbnRlbnRzIiwibGFuZ3VhZ2VDb2RlIiwicmVwb0NvZGUiLCJtYXJrZG93bkZpbGVuYW1lIiwibWFya2Rvd25UZXh0IiwiZ2l2ZW5Mb2NhdGlvbiIsImNoZWNraW5nT3B0aW9ucyIsImFkZFN1Y2Nlc3NNZXNzYWdlIiwiYWRkTm90aWNlUGFydGlhbCIsIm91ckNoZWNrTWFya2Rvd25UZXh0Iiwib3VyRmlsZVRleHRDaGVjayIsIm9wdGlvbmFsRmllbGRMb2NhdGlvbiIsImN0ZmNSZXN1bHRPYmplY3QiLCJub3RpY2VMaXN0Iiwibm90aWNlRW50cnkiLCJjbXRSZXN1bHRPYmplY3QiLCJub3RpY2VPYmplY3QiLCJjaGFyYWN0ZXJJbmRleCIsImV4Y2VycHQiLCJkZWJ1Z0NoYWluIiwicmVzdWx0IiwicHVzaCIsImZpbGVuYW1lIiwic3VjY2Vzc1N0cmluZyIsInN1Y2Nlc3NMaXN0IiwidW5kZWZpbmVkIiwib3VyTG9jYXRpb24iLCJleGNlcnB0TGVuZ3RoIiwibWR0Y0Vycm9yIiwiaXNOYU4iLCJERUZBVUxUX0VYQ0VSUFRfTEVOR1RIIiwibGVuZ3RoIiwidG9Mb2NhbGVTdHJpbmciXSwibWFwcGluZ3MiOiJtZkFBQTtBQUNBO0FBQ0E7O0FBRUEsd0M7OztBQUdBLElBQU1BLHNDQUFzQyxHQUFHLE9BQS9DOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRztBQUNzQkMseUI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7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LGFBOUJJLENBK0JMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFTVYsWUFBQUEsTUFyQ0QsR0FxQ1UsRUFBRUksV0FBVyxFQUFFLEVBQWYsRUFBbUJYLFVBQVUsRUFBRSxFQUEvQixFQXJDViw0QkEwSENKLG9CQUFvQixDQUFDTCxZQUFELEVBQWVDLGFBQWYsRUFBOEJDLGVBQTlCLENBMUhyQixTQTJITEksZ0JBQWdCLENBQUNOLFlBQUQsRUFBZUMsYUFBZixFQUE4QkMsZUFBOUIsQ0FBaEIsQ0FHQUMsaUJBQWlCLGtDQUEyQkosZ0JBQTNCLEVBQWpCLENBQ0EsSUFBSWlCLE1BQU0sQ0FBQ1AsVUFBUCxDQUFrQmtCLE1BQXRCLEVBQ0V4QixpQkFBaUIsc0NBQStCUixzQ0FBL0IsNEJBQXVGcUIsTUFBTSxDQUFDUCxVQUFQLENBQWtCa0IsTUFBbEIsR0FBMkJYLE1BQU0sQ0FBQ1AsVUFBUCxDQUFrQmtCLE1BQWxCLENBQXlCQyxjQUF6QixFQUEzQixHQUF1RSxNQUE5SixvQkFBOEtaLE1BQU0sQ0FBQ1AsVUFBUCxDQUFrQmtCLE1BQWxCLEtBQTZCLENBQTdCLEdBQWlDLEVBQWpDLEdBQXNDLEdBQXBOLEVBQWpCLENBREYsS0FHRXhCLGlCQUFpQixxRUFBOERSLHNDQUE5RCxFQUFqQixDQWxJRyxDQW1JTDtBQUNBO0FBcElLLDhDQXFJRXFCLE1BcklGLDZEIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgREVGQVVMVF9FWENFUlBUX0xFTkdUSCB9IGZyb20gJy4vZGVmYXVsdHMnXG5pbXBvcnQgeyBjaGVja01hcmtkb3duVGV4dCB9IGZyb20gJy4vbWFya2Rvd24tdGV4dC1jaGVjayc7XG5pbXBvcnQgeyBjaGVja1RleHRmaWxlQ29udGVudHMgfSBmcm9tICcuL2ZpbGUtdGV4dC1jaGVjayc7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLXZhcnNcbmltcG9ydCB7IHVzZXJMb2csIGZ1bmN0aW9uTG9nLCBkZWJ1Z0xvZywgcGFyYW1ldGVyQXNzZXJ0IH0gZnJvbSAnLi91dGlsaXRpZXMnO1xuXG5cbmNvbnN0IE1BUktET1dOX0ZJTEVfVkFMSURBVE9SX1ZFUlNJT05fU1RSSU5HID0gJzAuNC40JztcblxuXG4vKipcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gbGFuZ3VhZ2VDb2RlXG4gKiBAcGFyYW0ge3N0cmluZ30gcmVwb0NvZGUgLS0gZS5nLiwgJ1RXJywgJ1RBJywgJ1RRJywgb3IgJ09CUycsIGV0Yy5cbiAqIEBwYXJhbSB7c3RyaW5nfSBtYXJrZG93bkZpbGVuYW1lIC0tIHVzZWQgZm9yIGlkZW50aWZpY2F0aW9uXG4gKiBAcGFyYW0ge3N0cmluZ30gbWFya2Rvd25UZXh0IC0tIHRoZSBhY3R1YWwgdGV4dCB0byBiZSBjaGVja2VkXG4gKiBAcGFyYW0ge3N0cmluZ30gZ2l2ZW5Mb2NhdGlvblxuICogQHBhcmFtIHtPYmplY3R9IGNoZWNraW5nT3B0aW9uc1xuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gY2hlY2tNYXJrZG93bkZpbGVDb250ZW50cyhsYW5ndWFnZUNvZGUsIHJlcG9Db2RlLCBtYXJrZG93bkZpbGVuYW1lLCBtYXJrZG93blRleHQsIGdpdmVuTG9jYXRpb24sIGNoZWNraW5nT3B0aW9ucykge1xuICAvKiBUaGlzIGZ1bmN0aW9uIGlzIG9wdGltaXNlZCBmb3IgY2hlY2tpbmcgdGhlIGVudGlyZSBtYXJrZG93biBmaWxlLCBpLmUuLCBhbGwgbGluZXMuXG5cbiAgIFJldHVybnMgYSByZXN1bHQgb2JqZWN0IGNvbnRhaW5pbmcgYSBzdWNjZXNzTGlzdCBhbmQgYSBub3RpY2VMaXN0XG4gICAqL1xuICAvLyBmdW5jdGlvbkxvZyhgY2hlY2tNYXJrZG93bkZpbGVDb250ZW50cyhsQz0ke2xhbmd1YWdlQ29kZX0sIHJDPSR7cmVwb0NvZGV9LCBmbj0ke21hcmtkb3duRmlsZW5hbWV9LCAke21hcmtkb3duVGV4dC5sZW5ndGh9LCAke2dpdmVuTG9jYXRpb259KeKApmApO1xuICAvL3BhcmFtZXRlckFzc2VydChsYW5ndWFnZUNvZGUgIT09IHVuZGVmaW5lZCwgXCJjaGVja01hcmtkb3duRmlsZUNvbnRlbnRzOiAnbGFuZ3VhZ2VDb2RlJyBwYXJhbWV0ZXIgc2hvdWxkIGJlIGRlZmluZWRcIik7XG4gIC8vcGFyYW1ldGVyQXNzZXJ0KHR5cGVvZiBsYW5ndWFnZUNvZGUgPT09ICdzdHJpbmcnLCBgY2hlY2tNYXJrZG93bkZpbGVDb250ZW50czogJ2xhbmd1YWdlQ29kZScgcGFyYW1ldGVyIHNob3VsZCBiZSBhIHN0cmluZyBub3QgYSAnJHt0eXBlb2YgbGFuZ3VhZ2VDb2RlfSc6ICR7bGFuZ3VhZ2VDb2RlfWApO1xuICBpZiAobWFya2Rvd25GaWxlbmFtZSAhPT0gJ0xJQ0VOU0UubWQnICYmIG1hcmtkb3duRmlsZW5hbWUgIT09ICdSRUFETUUubWQnKSB7ICAgIC8vcGFyYW1ldGVyQXNzZXJ0KHJlcG9Db2RlID09PSAnVFcnIHx8IHJlcG9Db2RlID09PSAnVEEnIHx8IHJlcG9Db2RlID09PSAnVFEnIHx8IHJlcG9Db2RlID09PSAnT0JTJyB8fCByZXBvQ29kZSA9PT0gJ09CUy1UUScsIGBjaGVja01hcmtkb3duRmlsZUNvbnRlbnRzOiAncmVwb0NvZGUnIHBhcmFtZXRlciBzaG91bGQgYmUgJ1RXJywgJ1RBJywgJ1RRJywgJ09CUycsIG9yICdPQlMtVFEnIG5vdCAnJHtyZXBvQ29kZX0nYCk7XG4gIH1cbiAgLy9wYXJhbWV0ZXJBc3NlcnQobWFya2Rvd25GaWxlbmFtZSAhPT0gdW5kZWZpbmVkLCBcImNoZWNrTWFya2Rvd25GaWxlQ29udGVudHM6ICdtYXJrZG93bkZpbGVuYW1lJyBwYXJhbWV0ZXIgc2hvdWxkIGJlIGRlZmluZWRcIik7XG4gIC8vcGFyYW1ldGVyQXNzZXJ0KHR5cGVvZiBtYXJrZG93bkZpbGVuYW1lID09PSAnc3RyaW5nJywgYGNoZWNrTWFya2Rvd25GaWxlQ29udGVudHM6ICdtYXJrZG93bkZpbGVuYW1lJyBwYXJhbWV0ZXIgc2hvdWxkIGJlIGEgc3RyaW5nIG5vdCBhICcke3R5cGVvZiBtYXJrZG93bkZpbGVuYW1lfSc6ICR7bWFya2Rvd25GaWxlbmFtZX1gKTtcbiAgLy9wYXJhbWV0ZXJBc3NlcnQobWFya2Rvd25UZXh0ICE9PSB1bmRlZmluZWQsIFwiY2hlY2tNYXJrZG93bkZpbGVDb250ZW50czogJ21hcmtkb3duVGV4dCcgcGFyYW1ldGVyIHNob3VsZCBiZSBkZWZpbmVkXCIpO1xuICAvL3BhcmFtZXRlckFzc2VydCh0eXBlb2YgbWFya2Rvd25UZXh0ID09PSAnc3RyaW5nJywgYGNoZWNrTWFya2Rvd25GaWxlQ29udGVudHM6ICdtYXJrZG93blRleHQnIHBhcmFtZXRlciBzaG91bGQgYmUgYSBzdHJpbmcgbm90IGEgJyR7dHlwZW9mIG1hcmtkb3duVGV4dH0nOiAke21hcmtkb3duVGV4dH1gKTtcbiAgLy9wYXJhbWV0ZXJBc3NlcnQoZ2l2ZW5Mb2NhdGlvbiAhPT0gdW5kZWZpbmVkLCBcImNoZWNrTWFya2Rvd25GaWxlQ29udGVudHM6ICdnaXZlbkxvY2F0aW9uJyBwYXJhbWV0ZXIgc2hvdWxkIGJlIGRlZmluZWRcIik7XG4gIC8vcGFyYW1ldGVyQXNzZXJ0KHR5cGVvZiBnaXZlbkxvY2F0aW9uID09PSAnc3RyaW5nJywgYGNoZWNrTWFya2Rvd25GaWxlQ29udGVudHM6ICdnaXZlbkxvY2F0aW9uJyBwYXJhbWV0ZXIgc2hvdWxkIGJlIGEgc3RyaW5nIG5vdCBhICcke3R5cGVvZiBnaXZlbkxvY2F0aW9ufSc6ICR7Z2l2ZW5Mb2NhdGlvbn1gKTtcbiAgLy9wYXJhbWV0ZXJBc3NlcnQoZ2l2ZW5Mb2NhdGlvbi5pbmRleE9mKCd0cnVlJykgPT09IC0xLCBgY2hlY2tNYXJrZG93bkZpbGVDb250ZW50czogJ2dpdmVuTG9jYXRpb24nIHBhcmFtZXRlciBzaG91bGQgbm90IGJlICcke2dpdmVuTG9jYXRpb259J2ApO1xuICBpZiAoY2hlY2tpbmdPcHRpb25zICE9PSB1bmRlZmluZWQpIHsgLy9wYXJhbWV0ZXJBc3NlcnQodHlwZW9mIGNoZWNraW5nT3B0aW9ucyA9PT0gJ29iamVjdCcsIGBjaGVja01hcmtkb3duRmlsZUNvbnRlbnRzOiAnY2hlY2tpbmdPcHRpb25zJyBwYXJhbWV0ZXIgc2hvdWxkIGJlIGFuIG9iamVjdCBub3QgYSAnJHt0eXBlb2YgY2hlY2tpbmdPcHRpb25zfSc6ICR7SlNPTi5zdHJpbmdpZnkoY2hlY2tpbmdPcHRpb25zKX1gKTtcbiAgfVxuXG4gIGxldCBvdXJMb2NhdGlvbiA9IGdpdmVuTG9jYXRpb247XG4gIGlmIChvdXJMb2NhdGlvbiAmJiBvdXJMb2NhdGlvblswXSAhPT0gJyAnKSBvdXJMb2NhdGlvbiA9IGAgJHtvdXJMb2NhdGlvbn1gO1xuXG4gIGxldCBleGNlcnB0TGVuZ3RoO1xuICB0cnkge1xuICAgIGV4Y2VycHRMZW5ndGggPSBjaGVja2luZ09wdGlvbnM/LmV4Y2VycHRMZW5ndGg7XG4gIH0gY2F0Y2ggKG1kdGNFcnJvcikgeyB9XG4gIGlmICh0eXBlb2YgZXhjZXJwdExlbmd0aCAhPT0gJ251bWJlcicgfHwgaXNOYU4oZXhjZXJwdExlbmd0aCkpIHtcbiAgICBleGNlcnB0TGVuZ3RoID0gREVGQVVMVF9FWENFUlBUX0xFTkdUSDtcbiAgICAvLyBkZWJ1Z0xvZyhcIlVzaW5nIGRlZmF1bHQgZXhjZXJwdExlbmd0aD1cIiArIGV4Y2VycHRMZW5ndGgpO1xuICB9XG4gIC8vIGVsc2VcbiAgLy8gZGVidWdMb2coXCJVc2luZyBzdXBwbGllZCBleGNlcnB0TGVuZ3RoPVwiICsgZXhjZXJwdExlbmd0aCwgYGNmLiBkZWZhdWx0PSR7REVGQVVMVF9FWENFUlBUX0xFTkdUSH1gKTtcbiAgLy8gY29uc3QgZXhjZXJwdEhhbGZMZW5ndGggPSBNYXRoLmZsb29yKGV4Y2VycHRMZW5ndGggLyAyKTsgLy8gcm91bmRlZCBkb3duXG4gIC8vIGNvbnN0IGV4Y2VycHRIYWxmTGVuZ3RoUGx1cyA9IE1hdGguZmxvb3IoKGV4Y2VycHRMZW5ndGggKyAxKSAvIDIpOyAvLyByb3VuZGVkIHVwXG4gIC8vIGRlYnVnTG9nKFwiVXNpbmcgZXhjZXJwdEhhbGZMZW5ndGg9XCIgKyBleGNlcnB0SGFsZkxlbmd0aCwgYGV4Y2VycHRIYWxmTGVuZ3RoUGx1cz0ke2V4Y2VycHRIYWxmTGVuZ3RoUGx1c31gKTtcblxuICBjb25zdCByZXN1bHQgPSB7IHN1Y2Nlc3NMaXN0OiBbXSwgbm90aWNlTGlzdDogW10gfTtcblxuICBmdW5jdGlvbiBhZGRTdWNjZXNzTWVzc2FnZShzdWNjZXNzU3RyaW5nKSB7XG4gICAgLy8gZGVidWdMb2coXCJjaGVja01hcmtkb3duRmlsZUNvbnRlbnRzIHN1Y2Nlc3M6IFwiICsgc3VjY2Vzc1N0cmluZyk7XG4gICAgcmVzdWx0LnN1Y2Nlc3NMaXN0LnB1c2goc3VjY2Vzc1N0cmluZyk7XG4gIH1cbiAgZnVuY3Rpb24gYWRkTm90aWNlUGFydGlhbChub3RpY2VPYmplY3QpIHtcbiAgICAvLyBmdW5jdGlvbkxvZyhgY2hlY2tNYXJrZG93bkZpbGVDb250ZW50cyBhZGROb3RpY2VQYXJ0aWFsOiAocHJpb3JpdHk9JHtub3RpY2VPYmplY3QucHJpb3JpdHl9KSAke25vdGljZU9iamVjdC5tZXNzYWdlfSR7bm90aWNlT2JqZWN0LmNoYXJhY3RlckluZGV4ID4gMCA/IGAgKGF0IGNoYXJhY3RlciAke25vdGljZU9iamVjdC5jaGFyYWN0ZXJJbmRleH0pYCA6IFwiXCJ9JHtub3RpY2VPYmplY3QuZXhjZXJwdCA/IFwiIFwiICsgbm90aWNlT2JqZWN0LmV4Y2VycHQgOiBcIlwifSR7bm90aWNlT2JqZWN0LmxvY2F0aW9ufWApO1xuICAgIC8vcGFyYW1ldGVyQXNzZXJ0KG5vdGljZU9iamVjdC5wcmlvcml0eSAhPT0gdW5kZWZpbmVkLCBcImNNZFQgYWRkTm90aWNlUGFydGlhbDogJ3ByaW9yaXR5JyBwYXJhbWV0ZXIgc2hvdWxkIGJlIGRlZmluZWRcIik7XG4gICAgLy9wYXJhbWV0ZXJBc3NlcnQodHlwZW9mIG5vdGljZU9iamVjdC5wcmlvcml0eSA9PT0gJ251bWJlcicsIGBjTWRUIGFkZE5vdGljZVBhcnRpYWw6ICdwcmlvcml0eScgcGFyYW1ldGVyIHNob3VsZCBiZSBhIG51bWJlciBub3QgYSAnJHt0eXBlb2Ygbm90aWNlT2JqZWN0LnByaW9yaXR5fSc6ICR7bm90aWNlT2JqZWN0LnByaW9yaXR5fWApO1xuICAgIC8vcGFyYW1ldGVyQXNzZXJ0KG5vdGljZU9iamVjdC5tZXNzYWdlICE9PSB1bmRlZmluZWQsIFwiY01kVCBhZGROb3RpY2VQYXJ0aWFsOiAnbWVzc2FnZScgcGFyYW1ldGVyIHNob3VsZCBiZSBkZWZpbmVkXCIpO1xuICAgIC8vcGFyYW1ldGVyQXNzZXJ0KHR5cGVvZiBub3RpY2VPYmplY3QubWVzc2FnZSA9PT0gJ3N0cmluZycsIGBjTWRUIGFkZE5vdGljZVBhcnRpYWw6ICdtZXNzYWdlJyBwYXJhbWV0ZXIgc2hvdWxkIGJlIGEgc3RyaW5nIG5vdCBhICcke3R5cGVvZiBub3RpY2VPYmplY3QubWVzc2FnZX0nOiAke25vdGljZU9iamVjdC5tZXNzYWdlfWApO1xuICAgIC8vIC8vcGFyYW1ldGVyQXNzZXJ0KGNoYXJhY3RlckluZGV4ICE9PSB1bmRlZmluZWQsIFwiY01kVCBhZGROb3RpY2VQYXJ0aWFsOiAnY2hhcmFjdGVySW5kZXgnIHBhcmFtZXRlciBzaG91bGQgYmUgZGVmaW5lZFwiKTtcbiAgICBpZiAobm90aWNlT2JqZWN0LmNoYXJhY3RlckluZGV4KSB7IC8vcGFyYW1ldGVyQXNzZXJ0KHR5cGVvZiBub3RpY2VPYmplY3QuY2hhcmFjdGVySW5kZXggPT09ICdudW1iZXInLCBgY01kVCBhZGROb3RpY2VQYXJ0aWFsOiAnY2hhcmFjdGVySW5kZXgnIHBhcmFtZXRlciBzaG91bGQgYmUgYSBudW1iZXIgbm90IGEgJyR7dHlwZW9mIG5vdGljZU9iamVjdC5jaGFyYWN0ZXJJbmRleH0nOiAke25vdGljZU9iamVjdC5jaGFyYWN0ZXJJbmRleH1gKTtcbiAgICB9XG4gICAgLy8gLy9wYXJhbWV0ZXJBc3NlcnQoZXhjZXJwdCAhPT0gdW5kZWZpbmVkLCBcImNNZFQgYWRkTm90aWNlUGFydGlhbDogJ2V4Y2VycHQnIHBhcmFtZXRlciBzaG91bGQgYmUgZGVmaW5lZFwiKTtcbiAgICBpZiAobm90aWNlT2JqZWN0LmV4Y2VycHQpIHsgLy9wYXJhbWV0ZXJBc3NlcnQodHlwZW9mIG5vdGljZU9iamVjdC5leGNlcnB0ID09PSAnc3RyaW5nJywgYGNNZFQgYWRkTm90aWNlUGFydGlhbDogJ2V4Y2VycHQnIHBhcmFtZXRlciBzaG91bGQgYmUgYSBzdHJpbmcgbm90IGEgJyR7dHlwZW9mIG5vdGljZU9iamVjdC5leGNlcnB0fSc6ICR7bm90aWNlT2JqZWN0LmV4Y2VycHR9YCk7XG4gICAgfVxuICAgIC8vcGFyYW1ldGVyQXNzZXJ0KG5vdGljZU9iamVjdC5sb2NhdGlvbiAhPT0gdW5kZWZpbmVkLCBcImNNZFQgYWRkTm90aWNlUGFydGlhbDogJ2xvY2F0aW9uJyBwYXJhbWV0ZXIgc2hvdWxkIGJlIGRlZmluZWRcIik7XG4gICAgLy9wYXJhbWV0ZXJBc3NlcnQodHlwZW9mIG5vdGljZU9iamVjdC5sb2NhdGlvbiA9PT0gJ3N0cmluZycsIGBjTWRUIGFkZE5vdGljZVBhcnRpYWw6ICdsb2NhdGlvbicgcGFyYW1ldGVyIHNob3VsZCBiZSBhIHN0cmluZyBub3QgYSAnJHt0eXBlb2Ygbm90aWNlT2JqZWN0LmxvY2F0aW9ufSc6ICR7bm90aWNlT2JqZWN0LmxvY2F0aW9ufWApO1xuXG4gICAgaWYgKG5vdGljZU9iamVjdC5kZWJ1Z0NoYWluKSBub3RpY2VPYmplY3QuZGVidWdDaGFpbiA9IGBjaGVja01hcmtkb3duRmlsZUNvbnRlbnRzICR7bm90aWNlT2JqZWN0LmRlYnVnQ2hhaW59YDsgLy8gUHJlcGVuZCBvdXIgbmFtZVxuICAgIHJlc3VsdC5ub3RpY2VMaXN0LnB1c2goeyAuLi5ub3RpY2VPYmplY3QsIGZpbGVuYW1lOiBtYXJrZG93bkZpbGVuYW1lIH0pO1xuICB9XG4gIC8vIGVuZCBvZiBhZGROb3RpY2VQYXJ0aWFsIGZ1bmN0aW9uXG5cbiAgLyoqXG4gICogQGRlc2NyaXB0aW9uIC0gY2hlY2tzIHRoZSBnaXZlbiB0ZXh0IGZpZWxkIGFuZCBwcm9jZXNzZXMgdGhlIHJldHVybmVkIHJlc3VsdHNcbiAgKiBAcGFyYW0ge3N0cmluZ30gbWFya2Rvd25UZXh0IC0gdGhlIGFjdHVhbCB0ZXh0IG9mIHRoZSBmaWxlIGJlaW5nIGNoZWNrZWRcbiAgKiBAcGFyYW0ge2Jvb2xlYW59IGFsbG93ZWRMaW5rcyAtIHRydWUgaWYgbGlua3MgYXJlIGFsbG93ZWQgaW4gdGhlIGZpZWxkLCBvdGhlcndpc2UgZmFsc2VcbiAgKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9uYWxGaWVsZExvY2F0aW9uIC0gZGVzY3JpcHRpb24gb2Ygd2hlcmUgdGhlIGZpZWxkIGlzIGxvY2F0ZWRcbiAgKiBAcGFyYW0ge09iamVjdH0gY2hlY2tpbmdPcHRpb25zIC0gcGFyYW1ldGVycyB0aGF0IG1pZ2h0IGFmZmVjdCB0aGUgY2hlY2tcbiAgKi9cbiAgYXN5bmMgZnVuY3Rpb24gb3VyQ2hlY2tNYXJrZG93blRleHQobWFya2Rvd25UZXh0LCBvcHRpb25hbEZpZWxkTG9jYXRpb24sIGNoZWNraW5nT3B0aW9ucykge1xuICAgIC8vIERvZXMgYmFzaWMgY2hlY2tzIGZvciBzbWFsbCBlcnJvcnMgbGlrZSBsZWFkaW5nL3RyYWlsaW5nIHNwYWNlcywgZXRjLlxuXG4gICAgLy8gV2UgYXNzdW1lIHRoYXQgY2hlY2tpbmcgZm9yIGNvbXB1bHNvcnkgZmllbGRzIGlzIGRvbmUgZWxzZXdoZXJlXG5cbiAgICAvLyBVcGRhdGVzIHRoZSBnbG9iYWwgbGlzdCBvZiBub3RpY2VzXG4gICAgLy8gZGVidWdMb2coYGNNZFQgb3VyQ2hlY2tNYXJrZG93blRleHQoJHtmaWVsZE5hbWV9LCAoJHtmaWVsZFRleHQubGVuZ3RofSksICR7YWxsb3dlZExpbmtzfSwgJHtvcHRpb25hbEZpZWxkTG9jYXRpb259LCDigKYpYCk7XG4gICAgLy9wYXJhbWV0ZXJBc3NlcnQobWFya2Rvd25UZXh0ICE9PSB1bmRlZmluZWQsIFwiY01kRkMgb3VyQ2hlY2tNYXJrZG93blRleHQ6ICdtYXJrZG93blRleHQnIHBhcmFtZXRlciBzaG91bGQgYmUgZGVmaW5lZFwiKTtcbiAgICAvL3BhcmFtZXRlckFzc2VydCh0eXBlb2YgbWFya2Rvd25UZXh0ID09PSAnc3RyaW5nJywgYGNNZEZDIG91ckNoZWNrTWFya2Rvd25UZXh0OiAnbWFya2Rvd25UZXh0JyBwYXJhbWV0ZXIgc2hvdWxkIGJlIGEgc3RyaW5nIG5vdCBhICcke3R5cGVvZiBtYXJrZG93blRleHR9J2ApO1xuICAgIC8vcGFyYW1ldGVyQXNzZXJ0KG9wdGlvbmFsRmllbGRMb2NhdGlvbiAhPT0gdW5kZWZpbmVkLCBcImNNZEZDIG91ckNoZWNrTWFya2Rvd25UZXh0OiAnb3B0aW9uYWxGaWVsZExvY2F0aW9uJyBwYXJhbWV0ZXIgc2hvdWxkIGJlIGRlZmluZWRcIik7XG4gICAgLy9wYXJhbWV0ZXJBc3NlcnQodHlwZW9mIG9wdGlvbmFsRmllbGRMb2NhdGlvbiA9PT0gJ3N0cmluZycsIGBjTWRGQyBvdXJDaGVja01hcmtkb3duVGV4dDogJ29wdGlvbmFsRmllbGRMb2NhdGlvbicgcGFyYW1ldGVyIHNob3VsZCBiZSBhIHN0cmluZyBub3QgYSAnJHt0eXBlb2Ygb3B0aW9uYWxGaWVsZExvY2F0aW9ufSdgKTtcblxuICAgIGNvbnN0IGNtdFJlc3VsdE9iamVjdCA9IGF3YWl0IGNoZWNrTWFya2Rvd25UZXh0KGxhbmd1YWdlQ29kZSwgcmVwb0NvZGUsIG1hcmtkb3duRmlsZW5hbWUsIG1hcmtkb3duVGV4dCwgb3B0aW9uYWxGaWVsZExvY2F0aW9uLCBjaGVja2luZ09wdGlvbnMpO1xuICAgIC8vIGRlYnVnTG9nKGBjbXRSZXN1bHRPYmplY3Q9JHtKU09OLnN0cmluZ2lmeShjbXRSZXN1bHRPYmplY3QpfWApO1xuXG4gICAgLy8gSWYgd2UgbmVlZCB0byBwdXQgZXZlcnl0aGluZyB0aHJvdWdoIGFkZE5vdGljZVBhcnRpYWwsIGUuZy4sIGZvciBkZWJ1Z2dpbmcgb3IgZmlsdGVyaW5nXG4gICAgLy8gIHByb2Nlc3MgcmVzdWx0cyBsaW5lIGJ5IGxpbmVcbiAgICBmb3IgKGNvbnN0IG5vdGljZUVudHJ5IG9mIGNtdFJlc3VsdE9iamVjdC5ub3RpY2VMaXN0KVxuICAgICAgYWRkTm90aWNlUGFydGlhbChub3RpY2VFbnRyeSk7XG4gIH1cbiAgLy8gZW5kIG9mIG91ckNoZWNrTWFya2Rvd25UZXh0IGZ1bmN0aW9uXG5cblxuICAvKipcbiAgKiBAZGVzY3JpcHRpb24gLSBjaGVja3MgdGhlIGdpdmVuIHRleHQgZmllbGQgYW5kIHByb2Nlc3NlcyB0aGUgcmV0dXJuZWQgcmVzdWx0c1xuICAqIEBwYXJhbSB7c3RyaW5nfSBtYXJrZG93blRleHQgLSB0aGUgYWN0dWFsIHRleHQgb2YgdGhlIGZpbGUgYmVpbmcgY2hlY2tlZFxuICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25hbEZpZWxkTG9jYXRpb24gLSBkZXNjcmlwdGlvbiBvZiB3aGVyZSB0aGUgZmllbGQgaXMgbG9jYXRlZFxuICAqIEBwYXJhbSB7T2JqZWN0fSBjaGVja2luZ09wdGlvbnMgLSBwYXJhbWV0ZXJzIHRoYXQgbWlnaHQgYWZmZWN0IHRoZSBjaGVja1xuICAqL1xuICBmdW5jdGlvbiBvdXJGaWxlVGV4dENoZWNrKG1hcmtkb3duVGV4dCwgb3B0aW9uYWxGaWVsZExvY2F0aW9uLCBjaGVja2luZ09wdGlvbnMpIHtcbiAgICAvLyBEb2VzIGJhc2ljIGNoZWNrcyBmb3Igc21hbGwgZXJyb3JzIGxpa2UgbGVhZGluZy90cmFpbGluZyBzcGFjZXMsIGV0Yy5cblxuICAgIC8vIFdlIGFzc3VtZSB0aGF0IGNoZWNraW5nIGZvciBjb21wdWxzb3J5IGZpZWxkcyBpcyBkb25lIGVsc2V3aGVyZVxuXG4gICAgLy8gVXBkYXRlcyB0aGUgZ2xvYmFsIGxpc3Qgb2Ygbm90aWNlc1xuICAgIC8vIGRlYnVnTG9nKGBjTWRGQyBvdXJGaWxlVGV4dENoZWNrKCR7bWFya2Rvd25UZXh0fSwgKCR7bWFya2Rvd25UZXh0Lmxlbmd0aH0pLCAke29wdGlvbmFsRmllbGRMb2NhdGlvbn0sICR7SlNPTi5zdHJpbmdpZnkoY2hlY2tpbmdPcHRpb25zKX0pYCk7XG4gICAgLy9wYXJhbWV0ZXJBc3NlcnQobWFya2Rvd25UZXh0ICE9PSB1bmRlZmluZWQsIFwiY01kRkMgb3VyRmlsZVRleHRDaGVjazogJ21hcmtkb3duVGV4dCcgcGFyYW1ldGVyIHNob3VsZCBiZSBkZWZpbmVkXCIpO1xuICAgIC8vcGFyYW1ldGVyQXNzZXJ0KHR5cGVvZiBtYXJrZG93blRleHQgPT09ICdzdHJpbmcnLCBgY01kRkMgb3VyRmlsZVRleHRDaGVjazogJ21hcmtkb3duVGV4dCcgcGFyYW1ldGVyIHNob3VsZCBiZSBhIHN0cmluZyBub3QgYSAnJHt0eXBlb2YgbWFya2Rvd25UZXh0fSdgKTtcbiAgICAvL3BhcmFtZXRlckFzc2VydChjaGVja2luZ09wdGlvbnMgIT09IHVuZGVmaW5lZCwgXCJjTWRGQyBvdXJGaWxlVGV4dENoZWNrOiAnY2hlY2tpbmdPcHRpb25zJyBwYXJhbWV0ZXIgc2hvdWxkIGJlIGRlZmluZWRcIik7XG5cbiAgICBjb25zdCBjdGZjUmVzdWx0T2JqZWN0ID0gY2hlY2tUZXh0ZmlsZUNvbnRlbnRzKGxhbmd1YWdlQ29kZSwgcmVwb0NvZGUsICdtYXJrZG93bicsIG1hcmtkb3duRmlsZW5hbWUsIG1hcmtkb3duVGV4dCwgb3B0aW9uYWxGaWVsZExvY2F0aW9uLCBjaGVja2luZ09wdGlvbnMpO1xuICAgIC8vIGRlYnVnTG9nKGBjdGZjUmVzdWx0T2JqZWN0PSR7SlNPTi5zdHJpbmdpZnkoY3RmY1Jlc3VsdE9iamVjdCl9YCk7XG5cbiAgICAvLyBJZiB3ZSBuZWVkIHRvIHB1dCBldmVyeXRoaW5nIHRocm91Z2ggYWRkTm90aWNlUGFydGlhbCwgZS5nLiwgZm9yIGRlYnVnZ2luZyBvciBmaWx0ZXJpbmdcbiAgICAvLyAgcHJvY2VzcyByZXN1bHRzIGxpbmUgYnkgbGluZVxuICAgIGZvciAoY29uc3Qgbm90aWNlRW50cnkgb2YgY3RmY1Jlc3VsdE9iamVjdC5ub3RpY2VMaXN0KVxuICAgICAgYWRkTm90aWNlUGFydGlhbChub3RpY2VFbnRyeSk7XG4gIH1cbiAgLy8gZW5kIG9mIG91ckZpbGVUZXh0Q2hlY2sgZnVuY3Rpb25cblxuXG4gIC8vIE1haW4gY29kZSBmb3IgY2hlY2tNYXJrZG93bkZpbGVDb250ZW50cyBmdW5jdGlvblxuICBhd2FpdCBvdXJDaGVja01hcmtkb3duVGV4dChtYXJrZG93blRleHQsIGdpdmVuTG9jYXRpb24sIGNoZWNraW5nT3B0aW9ucyk7XG4gIG91ckZpbGVUZXh0Q2hlY2sobWFya2Rvd25UZXh0LCBnaXZlbkxvY2F0aW9uLCBjaGVja2luZ09wdGlvbnMpO1xuXG5cbiAgYWRkU3VjY2Vzc01lc3NhZ2UoYENoZWNrZWQgbWFya2Rvd24gZmlsZTogJHttYXJrZG93bkZpbGVuYW1lfWApO1xuICBpZiAocmVzdWx0Lm5vdGljZUxpc3QubGVuZ3RoKVxuICAgIGFkZFN1Y2Nlc3NNZXNzYWdlKGBjaGVja01hcmtkb3duRmlsZUNvbnRlbnRzIHYke01BUktET1dOX0ZJTEVfVkFMSURBVE9SX1ZFUlNJT05fU1RSSU5HfSBmaW5pc2hlZCB3aXRoICR7cmVzdWx0Lm5vdGljZUxpc3QubGVuZ3RoID8gcmVzdWx0Lm5vdGljZUxpc3QubGVuZ3RoLnRvTG9jYWxlU3RyaW5nKCkgOiBcInplcm9cIn0gbm90aWNlJHtyZXN1bHQubm90aWNlTGlzdC5sZW5ndGggPT09IDEgPyAnJyA6ICdzJ31gKTtcbiAgZWxzZVxuICAgIGFkZFN1Y2Nlc3NNZXNzYWdlKGBObyBlcnJvcnMgb3Igd2FybmluZ3MgZm91bmQgYnkgY2hlY2tNYXJrZG93bkZpbGVDb250ZW50cyB2JHtNQVJLRE9XTl9GSUxFX1ZBTElEQVRPUl9WRVJTSU9OX1NUUklOR31gKVxuICAvLyBkZWJ1Z0xvZyhgICBjaGVja01hcmtkb3duRmlsZUNvbnRlbnRzIHJldHVybmluZyB3aXRoICR7cmVzdWx0LnN1Y2Nlc3NMaXN0Lmxlbmd0aC50b0xvY2FsZVN0cmluZygpfSBzdWNjZXNzKGVzKSwgJHtyZXN1bHQubm90aWNlTGlzdC5sZW5ndGgudG9Mb2NhbGVTdHJpbmcoKX0gbm90aWNlKHMpLmApO1xuICAvLyB1c2VyTG9nKGBjaGVja01hcmtkb3duRmlsZUNvbnRlbnRzIHJlc3VsdCBpcyAke0pTT04uc3RyaW5naWZ5KHJlc3VsdCl9YCk7XG4gIHJldHVybiByZXN1bHQ7XG59XG4vLyBlbmQgb2YgY2hlY2tNYXJrZG93bkZpbGVDb250ZW50cyBmdW5jdGlvblxuIl19