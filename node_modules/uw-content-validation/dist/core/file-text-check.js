"use strict";var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");Object.defineProperty(exports, "__esModule", { value: true });exports.checkTextfileContents = checkTextfileContents;var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
var _defaults = require("./defaults");
var _plainTextCheck = require("./plain-text-check");

var _utilities = require("./utilities");function ownKeys(object, enumerableOnly) {var keys = Object.keys(object);if (Object.getOwnPropertySymbols) {var symbols = Object.getOwnPropertySymbols(object);if (enumerableOnly) {symbols = symbols.filter(function (sym) {return Object.getOwnPropertyDescriptor(object, sym).enumerable;});}keys.push.apply(keys, symbols);}return keys;}function _objectSpread(target) {for (var i = 1; i < arguments.length; i++) {var source = arguments[i] != null ? arguments[i] : {};if (i % 2) {ownKeys(Object(source), true).forEach(function (key) {(0, _defineProperty2.default)(target, key, source[key]);});} else if (Object.getOwnPropertyDescriptors) {Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));} else {ownKeys(Object(source)).forEach(function (key) {Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));});}}return target;}function _createForOfIteratorHelper(o, allowArrayLike) {var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];if (!it) {if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {if (it) o = it;var i = 0;var F = function F() {};return { s: F, n: function n() {if (i >= o.length) return { done: true };return { done: false, value: o[i++] };}, e: function e(_e) {throw _e;}, f: F };}throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");}var normalCompletion = true,didErr = false,err;return { s: function s() {it = it.call(o);}, n: function n() {var step = it.next();normalCompletion = step.done;return step;}, e: function e(_e2) {didErr = true;err = _e2;}, f: function f() {try {if (!normalCompletion && it.return != null) it.return();} finally {if (didErr) throw err;}} };}function _unsupportedIterableToArray(o, minLen) {if (!o) return;if (typeof o === "string") return _arrayLikeToArray(o, minLen);var n = Object.prototype.toString.call(o).slice(8, -1);if (n === "Object" && o.constructor) n = o.constructor.name;if (n === "Map" || n === "Set") return Array.from(o);if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);}function _arrayLikeToArray(arr, len) {if (len == null || len > arr.length) len = arr.length;for (var i = 0, arr2 = new Array(len); i < len; i++) {arr2[i] = arr[i];}return arr2;}

// const FILE_TEXT_VALIDATOR_VERSION_STRING = '0.3.1';


/**
 *
 * @param {string} languageCode
 * @param {string} repoCode -- e.g., 'TN' or 'TQ2', etc.
 * @param {string} fileType
 * @param {string} filename
 * @param {string} fileText
 * @param {string} optionalFileLocation
 * @param {Object} checkingOptions
 */
function checkTextfileContents(languageCode, repoCode, fileType, filename, fileText, optionalFileLocation, checkingOptions) {
  // Does basic checks for small errors like mismatched punctuation pairs, etc.
  //  (Used by ourBasicFileChecks() in checkUSFMText() in usfm-text-check.js)

  // filename (str): Used for identification
  // fileText (str): The field being checked
  // optionalFileLocation (str): Used to inform where this field is located

  // We assume that checking for compulsory fields is done elsewhere

  // Returns a single notice list
  //  The list contains objects with the following fields:
  //      priority (compulsory): the priority number 0..999 (usually 800+ are errors, lower are warnings)
  //      message (compulsory): the error description string
  //      characterIndex: the 0-based index for the position in the string
  //      excerpt: a short excerpt of the string containing the error (or empty-string if irrelevant)
  //  (Returned in this way for more intelligent processing at a higher level)
  // functionLog(`checkTextfileContents(${filename}, ${fileText.length.toLocaleString()} chars, '${optionalFileLocation}')…`);
  //parameterAssert(languageCode !== undefined, "checkTextfileContents: 'languageCode' parameter should be defined");
  //parameterAssert(typeof languageCode === 'string', `checkTextfileContents: 'languageCode' parameter should be a string not a '${typeof languageCode}': ${languageCode}`);
  //parameterAssert(repoCode !== undefined, "checkTextfileContents: 'repoCode' parameter should be defined");
  //parameterAssert(typeof repoCode === 'string', `checkTextfileContents: 'repoCode' parameter should be a string not a '${typeof repoCode}': ${repoCode}`);
  //parameterAssert(REPO_CODES_LIST.includes(repoCode), `checkTextfileContents: 'repoCode' parameter should not be '${repoCode}'`);
  //parameterAssert(fileType !== undefined, "checkTextfileContents: 'fileType' parameter should be defined");
  //parameterAssert(typeof fileType === 'string', `checkTextfileContents: 'fileType' parameter should be a string not a '${typeof fileType}': ${fileType}`);
  //parameterAssert(fileType !== '', `checkTextfileContents: 'fileType' ${fileType} parameter should be not be an empty string`);
  //parameterAssert(fileType === 'markdown' || fileType === 'USFM' || fileType === 'YAML' || fileType === 'text', `checkTextfileContents: unrecognised 'fileType' parameter: '${fileType}'`);
  //parameterAssert(filename !== undefined, "checkTextfileContents: 'filename' parameter should be defined");
  //parameterAssert(typeof filename === 'string', `checkTextfileContents: 'filename' parameter should be a string not a '${typeof filename}': ${filename}`);
  //parameterAssert(fileText !== undefined, "checkTextfileContents: 'fileText' parameter should be defined");
  //parameterAssert(typeof fileText === 'string', `checkTextfileContents: 'fileText' parameter should be a string not a '${typeof fileText}': ${fileText}`);
  //parameterAssert(checkingOptions !== undefined, "checkTextfileContents: 'checkingOptions' parameter should be defined");

  var result = { noticeList: [] };

  function addNotice(noticeObject) {
    // debugLog(`dBTC Notice: (priority=${noticeObject.priority}) ${noticeObject.message}${noticeObject.characterIndex > 0 ? ` (at character ${noticeObject.characterIndex})` : ""}${noticeObject.excerpt ? ` ${noticeObject.excerpt}` : ""}${noticeObject.location}`);
    //parameterAssert(noticeObject.priority !== undefined, "dBTCs addNotice: 'priority' parameter should be defined");
    //parameterAssert(typeof noticeObject.priority === 'number', `dBTCs addNotice: 'priority' parameter should be a number not a '${typeof noticeObject.priority}': ${noticeObject.priority}`);
    //parameterAssert(noticeObject.message !== undefined, "dBTCs addNotice: 'message' parameter should be defined");
    //parameterAssert(typeof noticeObject.message === 'string', `dBTCs addNotice: 'message' parameter should be a string not a '${typeof noticeObject.message}': ${noticeObject.message}`);
    // //parameterAssert(characterIndex !== undefined, "dBTCs addNotice: 'characterIndex' parameter should be defined");
    if (noticeObject.characterIndex) {//parameterAssert(typeof noticeObject.characterIndex === 'number', `dBTCs addNotice: 'characterIndex' parameter should be a number not a '${typeof noticeObject.characterIndex}': ${noticeObject.characterIndex}`);
    }
    // //parameterAssert(excerpt !== undefined, "dBTCs addNotice: 'excerpt' parameter should be defined");
    if (noticeObject.excerpt) {//parameterAssert(typeof noticeObject.excerpt === 'string', `dBTCs addNotice: 'excerpt' parameter should be a string not a '${typeof noticeObject.excerpt}': ${noticeObject.excerpt}`);
    }
    //parameterAssert(noticeObject.location !== undefined, "dBTCs addNotice: 'location' parameter should be defined");
    //parameterAssert(typeof noticeObject.location === 'string', `dBTCs addNotice: 'location' parameter should be a string not a '${typeof noticeObject.location}': ${noticeObject.location}`);
    if (noticeObject.debugChain) noticeObject.debugChain = "checkTextfileContents(".concat(languageCode, ", ").concat(fileType, ", ").concat(filename, ") ").concat(noticeObject.debugChain);
    result.noticeList.push(noticeObject);
  }

  function ourCheckPlainText(textType, textFilename, plainText, givenLocation, checkingOptions) {
    /**
    * @description - checks the given text field and processes the returned results
    * @param {string} plainText - the actual text of the field being checked
    * @param {string} givenLocation - description of where the field is located
    * @param {Object} checkingOptions - parameters that might affect the check
    */
    // Does basic checks for small errors like leading/trailing spaces, etc.

    // We assume that checking for compulsory fields is done elsewhere

    // Updates the global list of notices
    // debugLog(`cPT ourCheckPlainText(${fieldName}, (${fieldText.length}), ${fieldLocation}, …)`);
    // //parameterAssert(textName !== undefined, "cPT ourCheckPlainText: 'textName' parameter should be defined");
    // //parameterAssert(typeof textName === 'string', `cPT ourCheckPlainText: 'fieldName' parameter should be a string not a '${typeof textName}'`);
    //parameterAssert(plainText !== undefined, "cPT ourCheckPlainText: 'plainText' parameter should be defined");
    //parameterAssert(typeof plainText === 'string', `cPT ourCheckPlainText: 'plainText' parameter should be a string not a '${typeof plainText}'`);
    //parameterAssert(checkingOptions !== undefined, "cPT ourCheckPlainText: 'checkingOptions' parameter should be defined");

    var resultObject = (0, _plainTextCheck.checkPlainText)(languageCode, repoCode, textType, textFilename, plainText, givenLocation, checkingOptions);

    // Choose only ONE of the following
    // This is the fast way of append the results from this field
    // cptResult.noticeList = cptResult.noticeList.concat(resultObject.noticeList);
    // If we need to put everything through addNotice, e.g., for debugging or filtering
    //  process results line by line
    var _iterator = _createForOfIteratorHelper(resultObject.noticeList),_step;try {for (_iterator.s(); !(_step = _iterator.n()).done;) {var noticeEntry = _step.value;
        addNotice(_objectSpread(_objectSpread({}, noticeEntry), {}, { filename: textFilename }));}} catch (err) {_iterator.e(err);} finally {_iterator.f();}
  }
  // end of ourCheckTextField function


  // Main code for checkTextfileContents()
  if (!fileText) // Nothing to check
    return result;

  var ourLocation = optionalFileLocation;
  if (ourLocation && ourLocation[0] !== ' ') ourLocation = " ".concat(ourLocation);

  /*
  let excerptLength;
  try {
      excerptLength = checkingOptions?.excerptLength;
  } catch (bfcError) { }
  if (typeof excerptLength !== 'number' || isNaN(excerptLength)) {
      excerptLength = DEFAULT_EXCERPT_LENGTH;
      // debugLog(`Using default excerptLength=${excerptLength}`);
  }
  // else
  // debugLog(`Using supplied excerptLength=${excerptLength}`, `cf. default=${DEFAULT_EXCERPT_LENGTH}`);
  const excerptHalfLength = Math.floor(excerptLength / 2); // rounded down
  const excerptHalfLengthPlus = Math.floor((excerptLength + 1) / 2); // rounded up
  // debugLog(`Using excerptHalfLength=${excerptHalfLength}`, `excerptHalfLengthPlus=${excerptHalfLengthPlus}`);
  */

  /*
  let textType = 'raw';
  const filenameLower = filename.toLowerCase();
  if (filenameLower.endsWith('.usfm')) textType = 'USFM';
  else if (filenameLower.endsWith('.md')) textType = 'markdown';
  else if (filenameLower.endsWith('.yaml') || filenameLower.endsWith('.yml')) textType = 'YAML';
  */
  ourCheckPlainText(fileType, filename, fileText, ourLocation, checkingOptions);

  //     // Simple check that there aren’t any
  //     ix = fileText.indexOf('://');
  //     if (ix === -1) ix = fileText.indexOf('http');
  //     if (ix === -1) ix = fileText.indexOf('ftp');
  //     // The following might have to be removed if text fields can contain email addresses
  //     if (ix === -1) ix = fileText.indexOf('.org');
  //     if (ix === -1) ix = fileText.indexOf('.com');
  //     if (ix === -1) ix = fileText.indexOf('.info');
  //     if (ix === -1) ix = fileText.indexOf('.bible');
  //     if (ix >= 0) {
  //         const excerpt = (ix>excerptHalfLength ? '…' : '') + fileText.substring(ix-excerptHalfLength, ix+excerptHalfLengthPlus) + (ix+excerptHalfLengthPlus < fileText.length ? '…' : '')
  //         addNotice({765, "Unexpected link", ix,excerpt, ourAtString});
  //     }
  // }
  return result;
}
// end of checkTextfileContents function
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9jb3JlL2ZpbGUtdGV4dC1jaGVjay5qcyJdLCJuYW1lcyI6WyJjaGVja1RleHRmaWxlQ29udGVudHMiLCJsYW5ndWFnZUNvZGUiLCJyZXBvQ29kZSIsImZpbGVUeXBlIiwiZmlsZW5hbWUiLCJmaWxlVGV4dCIsIm9wdGlvbmFsRmlsZUxvY2F0aW9uIiwiY2hlY2tpbmdPcHRpb25zIiwicmVzdWx0Iiwibm90aWNlTGlzdCIsImFkZE5vdGljZSIsIm5vdGljZU9iamVjdCIsImNoYXJhY3RlckluZGV4IiwiZXhjZXJwdCIsImRlYnVnQ2hhaW4iLCJwdXNoIiwib3VyQ2hlY2tQbGFpblRleHQiLCJ0ZXh0VHlwZSIsInRleHRGaWxlbmFtZSIsInBsYWluVGV4dCIsImdpdmVuTG9jYXRpb24iLCJyZXN1bHRPYmplY3QiLCJub3RpY2VFbnRyeSIsIm91ckxvY2F0aW9uIl0sIm1hcHBpbmdzIjoiO0FBQ0E7QUFDQTs7QUFFQSx3Qzs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTyxTQUFTQSxxQkFBVCxDQUErQkMsWUFBL0IsRUFBNkNDLFFBQTdDLEVBQXVEQyxRQUF2RCxFQUFpRUMsUUFBakUsRUFBMkVDLFFBQTNFLEVBQXFGQyxvQkFBckYsRUFBMkdDLGVBQTNHLEVBQTRIO0FBQy9IO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE1BQUlDLE1BQU0sR0FBRyxFQUFFQyxVQUFVLEVBQUUsRUFBZCxFQUFiOztBQUVBLFdBQVNDLFNBQVQsQ0FBbUJDLFlBQW5CLEVBQWlDO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQUlBLFlBQVksQ0FBQ0MsY0FBakIsRUFBaUMsQ0FBRTtBQUNsQztBQUNEO0FBQ0EsUUFBSUQsWUFBWSxDQUFDRSxPQUFqQixFQUEwQixDQUFFO0FBQzNCO0FBQ0Q7QUFDQTtBQUNBLFFBQUlGLFlBQVksQ0FBQ0csVUFBakIsRUFBNkJILFlBQVksQ0FBQ0csVUFBYixtQ0FBbURiLFlBQW5ELGVBQW9FRSxRQUFwRSxlQUFpRkMsUUFBakYsZUFBOEZPLFlBQVksQ0FBQ0csVUFBM0c7QUFDN0JOLElBQUFBLE1BQU0sQ0FBQ0MsVUFBUCxDQUFrQk0sSUFBbEIsQ0FBdUJKLFlBQXZCO0FBQ0g7O0FBRUQsV0FBU0ssaUJBQVQsQ0FBMkJDLFFBQTNCLEVBQXFDQyxZQUFyQyxFQUFtREMsU0FBbkQsRUFBOERDLGFBQTlELEVBQTZFYixlQUE3RSxFQUE4RjtBQUMxRjtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDUTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxRQUFNYyxZQUFZLEdBQUcsb0NBQWVwQixZQUFmLEVBQTZCQyxRQUE3QixFQUF1Q2UsUUFBdkMsRUFBaURDLFlBQWpELEVBQStEQyxTQUEvRCxFQUEwRUMsYUFBMUUsRUFBeUZiLGVBQXpGLENBQXJCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUF6QjBGLCtDQTBCaEVjLFlBQVksQ0FBQ1osVUExQm1ELGFBMEIxRix5REFBV2EsV0FBWDtBQUNJWixRQUFBQSxTQUFTLGlDQUFNWSxXQUFOLFNBQW1CbEIsUUFBUSxFQUFFYyxZQUE3QixJQUFULENBREosQ0ExQjBGO0FBNEI3RjtBQUNEOzs7QUFHQTtBQUNBLE1BQUksQ0FBQ2IsUUFBTCxFQUFlO0FBQ1gsV0FBT0csTUFBUDs7QUFFSixNQUFJZSxXQUFXLEdBQUdqQixvQkFBbEI7QUFDQSxNQUFJaUIsV0FBVyxJQUFJQSxXQUFXLENBQUMsQ0FBRCxDQUFYLEtBQW1CLEdBQXRDLEVBQTJDQSxXQUFXLGNBQU9BLFdBQVAsQ0FBWDs7QUFFM0M7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0lQLEVBQUFBLGlCQUFpQixDQUFDYixRQUFELEVBQVdDLFFBQVgsRUFBcUJDLFFBQXJCLEVBQStCa0IsV0FBL0IsRUFBNENoQixlQUE1QyxDQUFqQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBT0MsTUFBUDtBQUNIO0FBQ0QiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLXZhcnNcbmltcG9ydCB7IFJFUE9fQ09ERVNfTElTVCB9IGZyb20gJy4vZGVmYXVsdHMnO1xuaW1wb3J0IHsgY2hlY2tQbGFpblRleHQgfSBmcm9tICcuL3BsYWluLXRleHQtY2hlY2snO1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC12YXJzXG5pbXBvcnQgeyBwYXJhbWV0ZXJBc3NlcnQgfSBmcm9tICcuL3V0aWxpdGllcyc7XG5cbi8vIGNvbnN0IEZJTEVfVEVYVF9WQUxJREFUT1JfVkVSU0lPTl9TVFJJTkcgPSAnMC4zLjEnO1xuXG5cbi8qKlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBsYW5ndWFnZUNvZGVcbiAqIEBwYXJhbSB7c3RyaW5nfSByZXBvQ29kZSAtLSBlLmcuLCAnVE4nIG9yICdUUTInLCBldGMuXG4gKiBAcGFyYW0ge3N0cmluZ30gZmlsZVR5cGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBmaWxlbmFtZVxuICogQHBhcmFtIHtzdHJpbmd9IGZpbGVUZXh0XG4gKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9uYWxGaWxlTG9jYXRpb25cbiAqIEBwYXJhbSB7T2JqZWN0fSBjaGVja2luZ09wdGlvbnNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNoZWNrVGV4dGZpbGVDb250ZW50cyhsYW5ndWFnZUNvZGUsIHJlcG9Db2RlLCBmaWxlVHlwZSwgZmlsZW5hbWUsIGZpbGVUZXh0LCBvcHRpb25hbEZpbGVMb2NhdGlvbiwgY2hlY2tpbmdPcHRpb25zKSB7XG4gICAgLy8gRG9lcyBiYXNpYyBjaGVja3MgZm9yIHNtYWxsIGVycm9ycyBsaWtlIG1pc21hdGNoZWQgcHVuY3R1YXRpb24gcGFpcnMsIGV0Yy5cbiAgICAvLyAgKFVzZWQgYnkgb3VyQmFzaWNGaWxlQ2hlY2tzKCkgaW4gY2hlY2tVU0ZNVGV4dCgpIGluIHVzZm0tdGV4dC1jaGVjay5qcylcblxuICAgIC8vIGZpbGVuYW1lIChzdHIpOiBVc2VkIGZvciBpZGVudGlmaWNhdGlvblxuICAgIC8vIGZpbGVUZXh0IChzdHIpOiBUaGUgZmllbGQgYmVpbmcgY2hlY2tlZFxuICAgIC8vIG9wdGlvbmFsRmlsZUxvY2F0aW9uIChzdHIpOiBVc2VkIHRvIGluZm9ybSB3aGVyZSB0aGlzIGZpZWxkIGlzIGxvY2F0ZWRcblxuICAgIC8vIFdlIGFzc3VtZSB0aGF0IGNoZWNraW5nIGZvciBjb21wdWxzb3J5IGZpZWxkcyBpcyBkb25lIGVsc2V3aGVyZVxuXG4gICAgLy8gUmV0dXJucyBhIHNpbmdsZSBub3RpY2UgbGlzdFxuICAgIC8vICBUaGUgbGlzdCBjb250YWlucyBvYmplY3RzIHdpdGggdGhlIGZvbGxvd2luZyBmaWVsZHM6XG4gICAgLy8gICAgICBwcmlvcml0eSAoY29tcHVsc29yeSk6IHRoZSBwcmlvcml0eSBudW1iZXIgMC4uOTk5ICh1c3VhbGx5IDgwMCsgYXJlIGVycm9ycywgbG93ZXIgYXJlIHdhcm5pbmdzKVxuICAgIC8vICAgICAgbWVzc2FnZSAoY29tcHVsc29yeSk6IHRoZSBlcnJvciBkZXNjcmlwdGlvbiBzdHJpbmdcbiAgICAvLyAgICAgIGNoYXJhY3RlckluZGV4OiB0aGUgMC1iYXNlZCBpbmRleCBmb3IgdGhlIHBvc2l0aW9uIGluIHRoZSBzdHJpbmdcbiAgICAvLyAgICAgIGV4Y2VycHQ6IGEgc2hvcnQgZXhjZXJwdCBvZiB0aGUgc3RyaW5nIGNvbnRhaW5pbmcgdGhlIGVycm9yIChvciBlbXB0eS1zdHJpbmcgaWYgaXJyZWxldmFudClcbiAgICAvLyAgKFJldHVybmVkIGluIHRoaXMgd2F5IGZvciBtb3JlIGludGVsbGlnZW50IHByb2Nlc3NpbmcgYXQgYSBoaWdoZXIgbGV2ZWwpXG4gICAgLy8gZnVuY3Rpb25Mb2coYGNoZWNrVGV4dGZpbGVDb250ZW50cygke2ZpbGVuYW1lfSwgJHtmaWxlVGV4dC5sZW5ndGgudG9Mb2NhbGVTdHJpbmcoKX0gY2hhcnMsICcke29wdGlvbmFsRmlsZUxvY2F0aW9ufScp4oCmYCk7XG4gICAgLy9wYXJhbWV0ZXJBc3NlcnQobGFuZ3VhZ2VDb2RlICE9PSB1bmRlZmluZWQsIFwiY2hlY2tUZXh0ZmlsZUNvbnRlbnRzOiAnbGFuZ3VhZ2VDb2RlJyBwYXJhbWV0ZXIgc2hvdWxkIGJlIGRlZmluZWRcIik7XG4gICAgLy9wYXJhbWV0ZXJBc3NlcnQodHlwZW9mIGxhbmd1YWdlQ29kZSA9PT0gJ3N0cmluZycsIGBjaGVja1RleHRmaWxlQ29udGVudHM6ICdsYW5ndWFnZUNvZGUnIHBhcmFtZXRlciBzaG91bGQgYmUgYSBzdHJpbmcgbm90IGEgJyR7dHlwZW9mIGxhbmd1YWdlQ29kZX0nOiAke2xhbmd1YWdlQ29kZX1gKTtcbiAgICAvL3BhcmFtZXRlckFzc2VydChyZXBvQ29kZSAhPT0gdW5kZWZpbmVkLCBcImNoZWNrVGV4dGZpbGVDb250ZW50czogJ3JlcG9Db2RlJyBwYXJhbWV0ZXIgc2hvdWxkIGJlIGRlZmluZWRcIik7XG4gICAgLy9wYXJhbWV0ZXJBc3NlcnQodHlwZW9mIHJlcG9Db2RlID09PSAnc3RyaW5nJywgYGNoZWNrVGV4dGZpbGVDb250ZW50czogJ3JlcG9Db2RlJyBwYXJhbWV0ZXIgc2hvdWxkIGJlIGEgc3RyaW5nIG5vdCBhICcke3R5cGVvZiByZXBvQ29kZX0nOiAke3JlcG9Db2RlfWApO1xuICAgIC8vcGFyYW1ldGVyQXNzZXJ0KFJFUE9fQ09ERVNfTElTVC5pbmNsdWRlcyhyZXBvQ29kZSksIGBjaGVja1RleHRmaWxlQ29udGVudHM6ICdyZXBvQ29kZScgcGFyYW1ldGVyIHNob3VsZCBub3QgYmUgJyR7cmVwb0NvZGV9J2ApO1xuICAgIC8vcGFyYW1ldGVyQXNzZXJ0KGZpbGVUeXBlICE9PSB1bmRlZmluZWQsIFwiY2hlY2tUZXh0ZmlsZUNvbnRlbnRzOiAnZmlsZVR5cGUnIHBhcmFtZXRlciBzaG91bGQgYmUgZGVmaW5lZFwiKTtcbiAgICAvL3BhcmFtZXRlckFzc2VydCh0eXBlb2YgZmlsZVR5cGUgPT09ICdzdHJpbmcnLCBgY2hlY2tUZXh0ZmlsZUNvbnRlbnRzOiAnZmlsZVR5cGUnIHBhcmFtZXRlciBzaG91bGQgYmUgYSBzdHJpbmcgbm90IGEgJyR7dHlwZW9mIGZpbGVUeXBlfSc6ICR7ZmlsZVR5cGV9YCk7XG4gICAgLy9wYXJhbWV0ZXJBc3NlcnQoZmlsZVR5cGUgIT09ICcnLCBgY2hlY2tUZXh0ZmlsZUNvbnRlbnRzOiAnZmlsZVR5cGUnICR7ZmlsZVR5cGV9IHBhcmFtZXRlciBzaG91bGQgYmUgbm90IGJlIGFuIGVtcHR5IHN0cmluZ2ApO1xuICAgIC8vcGFyYW1ldGVyQXNzZXJ0KGZpbGVUeXBlID09PSAnbWFya2Rvd24nIHx8IGZpbGVUeXBlID09PSAnVVNGTScgfHwgZmlsZVR5cGUgPT09ICdZQU1MJyB8fCBmaWxlVHlwZSA9PT0gJ3RleHQnLCBgY2hlY2tUZXh0ZmlsZUNvbnRlbnRzOiB1bnJlY29nbmlzZWQgJ2ZpbGVUeXBlJyBwYXJhbWV0ZXI6ICcke2ZpbGVUeXBlfSdgKTtcbiAgICAvL3BhcmFtZXRlckFzc2VydChmaWxlbmFtZSAhPT0gdW5kZWZpbmVkLCBcImNoZWNrVGV4dGZpbGVDb250ZW50czogJ2ZpbGVuYW1lJyBwYXJhbWV0ZXIgc2hvdWxkIGJlIGRlZmluZWRcIik7XG4gICAgLy9wYXJhbWV0ZXJBc3NlcnQodHlwZW9mIGZpbGVuYW1lID09PSAnc3RyaW5nJywgYGNoZWNrVGV4dGZpbGVDb250ZW50czogJ2ZpbGVuYW1lJyBwYXJhbWV0ZXIgc2hvdWxkIGJlIGEgc3RyaW5nIG5vdCBhICcke3R5cGVvZiBmaWxlbmFtZX0nOiAke2ZpbGVuYW1lfWApO1xuICAgIC8vcGFyYW1ldGVyQXNzZXJ0KGZpbGVUZXh0ICE9PSB1bmRlZmluZWQsIFwiY2hlY2tUZXh0ZmlsZUNvbnRlbnRzOiAnZmlsZVRleHQnIHBhcmFtZXRlciBzaG91bGQgYmUgZGVmaW5lZFwiKTtcbiAgICAvL3BhcmFtZXRlckFzc2VydCh0eXBlb2YgZmlsZVRleHQgPT09ICdzdHJpbmcnLCBgY2hlY2tUZXh0ZmlsZUNvbnRlbnRzOiAnZmlsZVRleHQnIHBhcmFtZXRlciBzaG91bGQgYmUgYSBzdHJpbmcgbm90IGEgJyR7dHlwZW9mIGZpbGVUZXh0fSc6ICR7ZmlsZVRleHR9YCk7XG4gICAgLy9wYXJhbWV0ZXJBc3NlcnQoY2hlY2tpbmdPcHRpb25zICE9PSB1bmRlZmluZWQsIFwiY2hlY2tUZXh0ZmlsZUNvbnRlbnRzOiAnY2hlY2tpbmdPcHRpb25zJyBwYXJhbWV0ZXIgc2hvdWxkIGJlIGRlZmluZWRcIik7XG5cbiAgICBsZXQgcmVzdWx0ID0geyBub3RpY2VMaXN0OiBbXSB9O1xuXG4gICAgZnVuY3Rpb24gYWRkTm90aWNlKG5vdGljZU9iamVjdCkge1xuICAgICAgICAvLyBkZWJ1Z0xvZyhgZEJUQyBOb3RpY2U6IChwcmlvcml0eT0ke25vdGljZU9iamVjdC5wcmlvcml0eX0pICR7bm90aWNlT2JqZWN0Lm1lc3NhZ2V9JHtub3RpY2VPYmplY3QuY2hhcmFjdGVySW5kZXggPiAwID8gYCAoYXQgY2hhcmFjdGVyICR7bm90aWNlT2JqZWN0LmNoYXJhY3RlckluZGV4fSlgIDogXCJcIn0ke25vdGljZU9iamVjdC5leGNlcnB0ID8gYCAke25vdGljZU9iamVjdC5leGNlcnB0fWAgOiBcIlwifSR7bm90aWNlT2JqZWN0LmxvY2F0aW9ufWApO1xuICAgICAgICAvL3BhcmFtZXRlckFzc2VydChub3RpY2VPYmplY3QucHJpb3JpdHkgIT09IHVuZGVmaW5lZCwgXCJkQlRDcyBhZGROb3RpY2U6ICdwcmlvcml0eScgcGFyYW1ldGVyIHNob3VsZCBiZSBkZWZpbmVkXCIpO1xuICAgICAgICAvL3BhcmFtZXRlckFzc2VydCh0eXBlb2Ygbm90aWNlT2JqZWN0LnByaW9yaXR5ID09PSAnbnVtYmVyJywgYGRCVENzIGFkZE5vdGljZTogJ3ByaW9yaXR5JyBwYXJhbWV0ZXIgc2hvdWxkIGJlIGEgbnVtYmVyIG5vdCBhICcke3R5cGVvZiBub3RpY2VPYmplY3QucHJpb3JpdHl9JzogJHtub3RpY2VPYmplY3QucHJpb3JpdHl9YCk7XG4gICAgICAgIC8vcGFyYW1ldGVyQXNzZXJ0KG5vdGljZU9iamVjdC5tZXNzYWdlICE9PSB1bmRlZmluZWQsIFwiZEJUQ3MgYWRkTm90aWNlOiAnbWVzc2FnZScgcGFyYW1ldGVyIHNob3VsZCBiZSBkZWZpbmVkXCIpO1xuICAgICAgICAvL3BhcmFtZXRlckFzc2VydCh0eXBlb2Ygbm90aWNlT2JqZWN0Lm1lc3NhZ2UgPT09ICdzdHJpbmcnLCBgZEJUQ3MgYWRkTm90aWNlOiAnbWVzc2FnZScgcGFyYW1ldGVyIHNob3VsZCBiZSBhIHN0cmluZyBub3QgYSAnJHt0eXBlb2Ygbm90aWNlT2JqZWN0Lm1lc3NhZ2V9JzogJHtub3RpY2VPYmplY3QubWVzc2FnZX1gKTtcbiAgICAgICAgLy8gLy9wYXJhbWV0ZXJBc3NlcnQoY2hhcmFjdGVySW5kZXggIT09IHVuZGVmaW5lZCwgXCJkQlRDcyBhZGROb3RpY2U6ICdjaGFyYWN0ZXJJbmRleCcgcGFyYW1ldGVyIHNob3VsZCBiZSBkZWZpbmVkXCIpO1xuICAgICAgICBpZiAobm90aWNlT2JqZWN0LmNoYXJhY3RlckluZGV4KSB7IC8vcGFyYW1ldGVyQXNzZXJ0KHR5cGVvZiBub3RpY2VPYmplY3QuY2hhcmFjdGVySW5kZXggPT09ICdudW1iZXInLCBgZEJUQ3MgYWRkTm90aWNlOiAnY2hhcmFjdGVySW5kZXgnIHBhcmFtZXRlciBzaG91bGQgYmUgYSBudW1iZXIgbm90IGEgJyR7dHlwZW9mIG5vdGljZU9iamVjdC5jaGFyYWN0ZXJJbmRleH0nOiAke25vdGljZU9iamVjdC5jaGFyYWN0ZXJJbmRleH1gKTtcbiAgICAgICAgfVxuICAgICAgICAvLyAvL3BhcmFtZXRlckFzc2VydChleGNlcnB0ICE9PSB1bmRlZmluZWQsIFwiZEJUQ3MgYWRkTm90aWNlOiAnZXhjZXJwdCcgcGFyYW1ldGVyIHNob3VsZCBiZSBkZWZpbmVkXCIpO1xuICAgICAgICBpZiAobm90aWNlT2JqZWN0LmV4Y2VycHQpIHsgLy9wYXJhbWV0ZXJBc3NlcnQodHlwZW9mIG5vdGljZU9iamVjdC5leGNlcnB0ID09PSAnc3RyaW5nJywgYGRCVENzIGFkZE5vdGljZTogJ2V4Y2VycHQnIHBhcmFtZXRlciBzaG91bGQgYmUgYSBzdHJpbmcgbm90IGEgJyR7dHlwZW9mIG5vdGljZU9iamVjdC5leGNlcnB0fSc6ICR7bm90aWNlT2JqZWN0LmV4Y2VycHR9YCk7XG4gICAgICAgIH1cbiAgICAgICAgLy9wYXJhbWV0ZXJBc3NlcnQobm90aWNlT2JqZWN0LmxvY2F0aW9uICE9PSB1bmRlZmluZWQsIFwiZEJUQ3MgYWRkTm90aWNlOiAnbG9jYXRpb24nIHBhcmFtZXRlciBzaG91bGQgYmUgZGVmaW5lZFwiKTtcbiAgICAgICAgLy9wYXJhbWV0ZXJBc3NlcnQodHlwZW9mIG5vdGljZU9iamVjdC5sb2NhdGlvbiA9PT0gJ3N0cmluZycsIGBkQlRDcyBhZGROb3RpY2U6ICdsb2NhdGlvbicgcGFyYW1ldGVyIHNob3VsZCBiZSBhIHN0cmluZyBub3QgYSAnJHt0eXBlb2Ygbm90aWNlT2JqZWN0LmxvY2F0aW9ufSc6ICR7bm90aWNlT2JqZWN0LmxvY2F0aW9ufWApO1xuICAgICAgICBpZiAobm90aWNlT2JqZWN0LmRlYnVnQ2hhaW4pIG5vdGljZU9iamVjdC5kZWJ1Z0NoYWluID0gYGNoZWNrVGV4dGZpbGVDb250ZW50cygke2xhbmd1YWdlQ29kZX0sICR7ZmlsZVR5cGV9LCAke2ZpbGVuYW1lfSkgJHtub3RpY2VPYmplY3QuZGVidWdDaGFpbn1gO1xuICAgICAgICByZXN1bHQubm90aWNlTGlzdC5wdXNoKG5vdGljZU9iamVjdCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gb3VyQ2hlY2tQbGFpblRleHQodGV4dFR5cGUsIHRleHRGaWxlbmFtZSwgcGxhaW5UZXh0LCBnaXZlbkxvY2F0aW9uLCBjaGVja2luZ09wdGlvbnMpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICogQGRlc2NyaXB0aW9uIC0gY2hlY2tzIHRoZSBnaXZlbiB0ZXh0IGZpZWxkIGFuZCBwcm9jZXNzZXMgdGhlIHJldHVybmVkIHJlc3VsdHNcbiAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGxhaW5UZXh0IC0gdGhlIGFjdHVhbCB0ZXh0IG9mIHRoZSBmaWVsZCBiZWluZyBjaGVja2VkXG4gICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGdpdmVuTG9jYXRpb24gLSBkZXNjcmlwdGlvbiBvZiB3aGVyZSB0aGUgZmllbGQgaXMgbG9jYXRlZFxuICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjaGVja2luZ09wdGlvbnMgLSBwYXJhbWV0ZXJzIHRoYXQgbWlnaHQgYWZmZWN0IHRoZSBjaGVja1xuICAgICAgICAqL1xuICAgICAgICAvLyBEb2VzIGJhc2ljIGNoZWNrcyBmb3Igc21hbGwgZXJyb3JzIGxpa2UgbGVhZGluZy90cmFpbGluZyBzcGFjZXMsIGV0Yy5cblxuICAgICAgICAvLyBXZSBhc3N1bWUgdGhhdCBjaGVja2luZyBmb3IgY29tcHVsc29yeSBmaWVsZHMgaXMgZG9uZSBlbHNld2hlcmVcblxuICAgICAgICAvLyBVcGRhdGVzIHRoZSBnbG9iYWwgbGlzdCBvZiBub3RpY2VzXG4gICAgICAgIC8vIGRlYnVnTG9nKGBjUFQgb3VyQ2hlY2tQbGFpblRleHQoJHtmaWVsZE5hbWV9LCAoJHtmaWVsZFRleHQubGVuZ3RofSksICR7ZmllbGRMb2NhdGlvbn0sIOKApilgKTtcbiAgICAgICAgLy8gLy9wYXJhbWV0ZXJBc3NlcnQodGV4dE5hbWUgIT09IHVuZGVmaW5lZCwgXCJjUFQgb3VyQ2hlY2tQbGFpblRleHQ6ICd0ZXh0TmFtZScgcGFyYW1ldGVyIHNob3VsZCBiZSBkZWZpbmVkXCIpO1xuICAgICAgICAvLyAvL3BhcmFtZXRlckFzc2VydCh0eXBlb2YgdGV4dE5hbWUgPT09ICdzdHJpbmcnLCBgY1BUIG91ckNoZWNrUGxhaW5UZXh0OiAnZmllbGROYW1lJyBwYXJhbWV0ZXIgc2hvdWxkIGJlIGEgc3RyaW5nIG5vdCBhICcke3R5cGVvZiB0ZXh0TmFtZX0nYCk7XG4gICAgICAgIC8vcGFyYW1ldGVyQXNzZXJ0KHBsYWluVGV4dCAhPT0gdW5kZWZpbmVkLCBcImNQVCBvdXJDaGVja1BsYWluVGV4dDogJ3BsYWluVGV4dCcgcGFyYW1ldGVyIHNob3VsZCBiZSBkZWZpbmVkXCIpO1xuICAgICAgICAvL3BhcmFtZXRlckFzc2VydCh0eXBlb2YgcGxhaW5UZXh0ID09PSAnc3RyaW5nJywgYGNQVCBvdXJDaGVja1BsYWluVGV4dDogJ3BsYWluVGV4dCcgcGFyYW1ldGVyIHNob3VsZCBiZSBhIHN0cmluZyBub3QgYSAnJHt0eXBlb2YgcGxhaW5UZXh0fSdgKTtcbiAgICAgICAgLy9wYXJhbWV0ZXJBc3NlcnQoY2hlY2tpbmdPcHRpb25zICE9PSB1bmRlZmluZWQsIFwiY1BUIG91ckNoZWNrUGxhaW5UZXh0OiAnY2hlY2tpbmdPcHRpb25zJyBwYXJhbWV0ZXIgc2hvdWxkIGJlIGRlZmluZWRcIik7XG5cbiAgICAgICAgY29uc3QgcmVzdWx0T2JqZWN0ID0gY2hlY2tQbGFpblRleHQobGFuZ3VhZ2VDb2RlLCByZXBvQ29kZSwgdGV4dFR5cGUsIHRleHRGaWxlbmFtZSwgcGxhaW5UZXh0LCBnaXZlbkxvY2F0aW9uLCBjaGVja2luZ09wdGlvbnMpO1xuXG4gICAgICAgIC8vIENob29zZSBvbmx5IE9ORSBvZiB0aGUgZm9sbG93aW5nXG4gICAgICAgIC8vIFRoaXMgaXMgdGhlIGZhc3Qgd2F5IG9mIGFwcGVuZCB0aGUgcmVzdWx0cyBmcm9tIHRoaXMgZmllbGRcbiAgICAgICAgLy8gY3B0UmVzdWx0Lm5vdGljZUxpc3QgPSBjcHRSZXN1bHQubm90aWNlTGlzdC5jb25jYXQocmVzdWx0T2JqZWN0Lm5vdGljZUxpc3QpO1xuICAgICAgICAvLyBJZiB3ZSBuZWVkIHRvIHB1dCBldmVyeXRoaW5nIHRocm91Z2ggYWRkTm90aWNlLCBlLmcuLCBmb3IgZGVidWdnaW5nIG9yIGZpbHRlcmluZ1xuICAgICAgICAvLyAgcHJvY2VzcyByZXN1bHRzIGxpbmUgYnkgbGluZVxuICAgICAgICBmb3IgKGNvbnN0IG5vdGljZUVudHJ5IG9mIHJlc3VsdE9iamVjdC5ub3RpY2VMaXN0KVxuICAgICAgICAgICAgYWRkTm90aWNlKHsgLi4ubm90aWNlRW50cnksIGZpbGVuYW1lOiB0ZXh0RmlsZW5hbWUgfSk7XG4gICAgfVxuICAgIC8vIGVuZCBvZiBvdXJDaGVja1RleHRGaWVsZCBmdW5jdGlvblxuXG5cbiAgICAvLyBNYWluIGNvZGUgZm9yIGNoZWNrVGV4dGZpbGVDb250ZW50cygpXG4gICAgaWYgKCFmaWxlVGV4dCkgLy8gTm90aGluZyB0byBjaGVja1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuXG4gICAgbGV0IG91ckxvY2F0aW9uID0gb3B0aW9uYWxGaWxlTG9jYXRpb247XG4gICAgaWYgKG91ckxvY2F0aW9uICYmIG91ckxvY2F0aW9uWzBdICE9PSAnICcpIG91ckxvY2F0aW9uID0gYCAke291ckxvY2F0aW9ufWA7XG5cbiAgICAvKlxuICAgIGxldCBleGNlcnB0TGVuZ3RoO1xuICAgIHRyeSB7XG4gICAgICAgIGV4Y2VycHRMZW5ndGggPSBjaGVja2luZ09wdGlvbnM/LmV4Y2VycHRMZW5ndGg7XG4gICAgfSBjYXRjaCAoYmZjRXJyb3IpIHsgfVxuICAgIGlmICh0eXBlb2YgZXhjZXJwdExlbmd0aCAhPT0gJ251bWJlcicgfHwgaXNOYU4oZXhjZXJwdExlbmd0aCkpIHtcbiAgICAgICAgZXhjZXJwdExlbmd0aCA9IERFRkFVTFRfRVhDRVJQVF9MRU5HVEg7XG4gICAgICAgIC8vIGRlYnVnTG9nKGBVc2luZyBkZWZhdWx0IGV4Y2VycHRMZW5ndGg9JHtleGNlcnB0TGVuZ3RofWApO1xuICAgIH1cbiAgICAvLyBlbHNlXG4gICAgLy8gZGVidWdMb2coYFVzaW5nIHN1cHBsaWVkIGV4Y2VycHRMZW5ndGg9JHtleGNlcnB0TGVuZ3RofWAsIGBjZi4gZGVmYXVsdD0ke0RFRkFVTFRfRVhDRVJQVF9MRU5HVEh9YCk7XG4gICAgY29uc3QgZXhjZXJwdEhhbGZMZW5ndGggPSBNYXRoLmZsb29yKGV4Y2VycHRMZW5ndGggLyAyKTsgLy8gcm91bmRlZCBkb3duXG4gICAgY29uc3QgZXhjZXJwdEhhbGZMZW5ndGhQbHVzID0gTWF0aC5mbG9vcigoZXhjZXJwdExlbmd0aCArIDEpIC8gMik7IC8vIHJvdW5kZWQgdXBcbiAgICAvLyBkZWJ1Z0xvZyhgVXNpbmcgZXhjZXJwdEhhbGZMZW5ndGg9JHtleGNlcnB0SGFsZkxlbmd0aH1gLCBgZXhjZXJwdEhhbGZMZW5ndGhQbHVzPSR7ZXhjZXJwdEhhbGZMZW5ndGhQbHVzfWApO1xuICAgICovXG5cbiAgICAvKlxuICAgIGxldCB0ZXh0VHlwZSA9ICdyYXcnO1xuICAgIGNvbnN0IGZpbGVuYW1lTG93ZXIgPSBmaWxlbmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgIGlmIChmaWxlbmFtZUxvd2VyLmVuZHNXaXRoKCcudXNmbScpKSB0ZXh0VHlwZSA9ICdVU0ZNJztcbiAgICBlbHNlIGlmIChmaWxlbmFtZUxvd2VyLmVuZHNXaXRoKCcubWQnKSkgdGV4dFR5cGUgPSAnbWFya2Rvd24nO1xuICAgIGVsc2UgaWYgKGZpbGVuYW1lTG93ZXIuZW5kc1dpdGgoJy55YW1sJykgfHwgZmlsZW5hbWVMb3dlci5lbmRzV2l0aCgnLnltbCcpKSB0ZXh0VHlwZSA9ICdZQU1MJztcbiAgICAqL1xuICAgIG91ckNoZWNrUGxhaW5UZXh0KGZpbGVUeXBlLCBmaWxlbmFtZSwgZmlsZVRleHQsIG91ckxvY2F0aW9uLCBjaGVja2luZ09wdGlvbnMpO1xuXG4gICAgLy8gICAgIC8vIFNpbXBsZSBjaGVjayB0aGF0IHRoZXJlIGFyZW7igJl0IGFueVxuICAgIC8vICAgICBpeCA9IGZpbGVUZXh0LmluZGV4T2YoJzovLycpO1xuICAgIC8vICAgICBpZiAoaXggPT09IC0xKSBpeCA9IGZpbGVUZXh0LmluZGV4T2YoJ2h0dHAnKTtcbiAgICAvLyAgICAgaWYgKGl4ID09PSAtMSkgaXggPSBmaWxlVGV4dC5pbmRleE9mKCdmdHAnKTtcbiAgICAvLyAgICAgLy8gVGhlIGZvbGxvd2luZyBtaWdodCBoYXZlIHRvIGJlIHJlbW92ZWQgaWYgdGV4dCBmaWVsZHMgY2FuIGNvbnRhaW4gZW1haWwgYWRkcmVzc2VzXG4gICAgLy8gICAgIGlmIChpeCA9PT0gLTEpIGl4ID0gZmlsZVRleHQuaW5kZXhPZignLm9yZycpO1xuICAgIC8vICAgICBpZiAoaXggPT09IC0xKSBpeCA9IGZpbGVUZXh0LmluZGV4T2YoJy5jb20nKTtcbiAgICAvLyAgICAgaWYgKGl4ID09PSAtMSkgaXggPSBmaWxlVGV4dC5pbmRleE9mKCcuaW5mbycpO1xuICAgIC8vICAgICBpZiAoaXggPT09IC0xKSBpeCA9IGZpbGVUZXh0LmluZGV4T2YoJy5iaWJsZScpO1xuICAgIC8vICAgICBpZiAoaXggPj0gMCkge1xuICAgIC8vICAgICAgICAgY29uc3QgZXhjZXJwdCA9IChpeD5leGNlcnB0SGFsZkxlbmd0aCA/ICfigKYnIDogJycpICsgZmlsZVRleHQuc3Vic3RyaW5nKGl4LWV4Y2VycHRIYWxmTGVuZ3RoLCBpeCtleGNlcnB0SGFsZkxlbmd0aFBsdXMpICsgKGl4K2V4Y2VycHRIYWxmTGVuZ3RoUGx1cyA8IGZpbGVUZXh0Lmxlbmd0aCA/ICfigKYnIDogJycpXG4gICAgLy8gICAgICAgICBhZGROb3RpY2Uoezc2NSwgXCJVbmV4cGVjdGVkIGxpbmtcIiwgaXgsZXhjZXJwdCwgb3VyQXRTdHJpbmd9KTtcbiAgICAvLyAgICAgfVxuICAgIC8vIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuLy8gZW5kIG9mIGNoZWNrVGV4dGZpbGVDb250ZW50cyBmdW5jdGlvblxuIl19