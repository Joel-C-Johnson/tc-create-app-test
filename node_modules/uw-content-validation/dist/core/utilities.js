"use strict";var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");Object.defineProperty(exports, "__esModule", { value: true });exports.userLog = userLog;exports.debugLog = debugLog;exports.functionLog = functionLog;exports.parameterAssert = parameterAssert;exports.logicAssert = logicAssert;exports.dataAssert = dataAssert;exports.consoleLogObject = consoleLogObject;exports.displayPropertyNames = displayPropertyNames;exports.ourParseInt = ourParseInt;var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof")); // utilities.js


/**
 *
 * @param {string} logString
 * @param {string} optionalParameter2
 */
function userLog(logString, optionalParameter2) {
  // We can remove them all by disabling the next line
  console.log("uw-content-validation: ".concat(logString));
  if (optionalParameter2) userLog("userLog note: we have a 2nd parameter: '".concat(optionalParameter2, "' after '").concat(logString, "'"));
}


/**
 *
 * @param {string} logString
 * @param {string} optionalParameter2
 */
function debugLog(logString, optionalParameter2) {
  // We can remove them all by disabling the next line
  console.log("uw-content-validation debug: ".concat(logString));
  if (optionalParameter2) debugLog("debugLog note: we have a 2nd parameter: '".concat(optionalParameter2, "' after '").concat(logString, "'"));
}


/**
 *
 * @param {string} logString
 * @param {string} optionalParameter2
 */
function functionLog(logString, optionalParameter2) {
  // We can remove them all by disabling the next line
  console.log("uw-content-validation function call: ".concat(logString));
  if (optionalParameter2) functionLog("functionLog note: we have a 2nd parameter: '".concat(optionalParameter2, "' after '").concat(logString, "'"));
}


/**
 *
 * @param {*} truthStatement
 * @param {string} optionalMessage
 */
function parameterAssert(truthStatement, optionalMessage) {
  // We can remove them all by disabling the next line
  console.assert(truthStatement, "uw-content-validation parameterAssert: ".concat(optionalMessage));
}


/**
 *
 * @param {*} truthStatement
 * @param {string} optionalMessage
 */
function logicAssert(truthStatement, optionalMessage) {
  // We can remove them all by disabling the next line
  console.assert(truthStatement, "uw-content-validation logicAssert: ".concat(optionalMessage));
}


/**
 *
 * @param {*} truthStatement
 * @param {string} optionalMessage
 */
function dataAssert(truthStatement, optionalMessage) {
  // We can remove them all by disabling the next line
  console.assert(truthStatement, "uw-content-validation dataAssert: ".concat(optionalMessage));
}


/**
 *
 * @param {string} clTitle
 * @param {Object} clObject
 */
function consoleLogObject(clTitle, clObject) {
  // Print an object’s componenets to the console
  // Note: the following line succeeds even if length and/or size are undefined
  var clOutput = "cLO: ".concat(clTitle, " ").concat((0, _typeof2.default)(clObject), " (length=").concat(clObject.length, ") (size=").concat(clObject.size, "):\n");
  for (var clPropertyName in clObject) {
    // debugLog("   ", clTitle, clPropertyName); // for debugging only!
    var thisPropertyContents = "" + clObject[clPropertyName];
    if (thisPropertyContents.length > 50)
    thisPropertyContents = "(".concat(thisPropertyContents.length, ") ").concat(thisPropertyContents.substring(0, 50), "\u2026");
    var oType = (0, _typeof2.default)(clObject[clPropertyName]);
    // From https://stackoverflow.com/questions/12996871/why-does-typeof-array-with-objects-return-object-and-not-array#12996879
    if (oType === "object" && Object.prototype.toString.call(clObject[clPropertyName]) === "[object Array]")
    oType = "array";
    clOutput += "  ".concat(clPropertyName, " (type=").concat(oType, ")");
    var oLength = void 0;
    try {oLength = clObject[clPropertyName].length;}
    catch (olError) {oLength = "null";}
    if (oLength !== undefined) clOutput += " (length=".concat(oLength, ")");
    if (thisPropertyContents !== undefined) clOutput += ": ".concat(thisPropertyContents, "\n");

  }
  userLog(clOutput);
}
// end of consoleLogObject function


/**
 *
 * @param {string} givenTitle
 * @param {Object} givenObject
 */
function displayPropertyNames(givenTitle, givenObject) {
  var output = "dPN: ".concat(givenTitle, " ").concat((0, _typeof2.default)(givenObject), ":\n");

  for (var propertyName in givenObject) {
    output += "  ".concat(propertyName, " (type=").concat((0, _typeof2.default)(givenObject[propertyName]), ")\n");}

  userLog(output);
}
// end of displayPropertyNames function


/**
 *
 * @param {string} givenString
 */
function ourParseInt(givenString) {
  /*
  The regular parseInt() function is too forgiving
   See https://stackoverflow.com/questions/1133770/how-to-convert-a-string-to-an-integer-in-javascript
   This one throws an error if the entire field doesn’t give an integer.
  */



  /* First attempt
  const int1 = parseInt(givenString, 10); // Don’t let the function guess the base (if the string has a leading zero)
  const int2 = givenString * 1; // This one is less forgiving it seems
  if (int1!==int2) userLog(`From '${givenString}' we got ${int1} (${typeof int1}) and ${int2} (${typeof int2})`)
  if (isNaN(int2) || isNaN(int1)
  || int2===undefined || int1==undefined
  || int2!==int1)
      throw "String is not a simple integer";
  return int1;
  */
  //parameterAssert(typeof givenString === 'string', `ourParseInt: 'givenString' parameter should be a string not a '${typeof givenString}': ${givenString}`);
  //parameterAssert(givenString.length > 0, "ourParseInt: 'givenString' parameter should be not be an empty string!");
  // eslint-disable-next-line no-throw-literal
  if (givenString.length === 0) throw "String '".concat(givenString, "'is empty");

  // Optimised version
  var int = givenString * 1; // This one is less forgiving it seems
  // eslint-disable-next-line no-throw-literal
  if (isNaN(int)) throw "String '".concat(givenString, "' is not a simple integer");
  return int;
}


/*
 *
 * @param {string} bookID - 3-character UPPERCASE Book Id
 * @requires {number} 0..99
 */
/*
export function getBookNumber(bookID) {
    // debugLog(`getBookNumber(${bookID})…`)
    let numberResult = 99; // default 'unknown' value
    if (bookID==='FRT') numberResult = 0;
    else if (bookID==='BAK') numberResult = 68;
    else if (bookID==='OBS') numberResult = 80;
    else if (bookID==='MANIFEST') numberResult = 81;
    else if (bookID==='MEDIA') numberResult = 82;
    else if (bookID==='LICENSE') numberResult = 83;
    else if (bookID==='README') numberResult = 84;
    else {
        const thisUSFMNumberName = usfmNumberName(bookID);
        numberResult = ourParseInt(thisUSFMNumberName.substring(0, 2)); // 01..67 converted to number
    // } catch {}
    }
    // For everything else
    // debugLog(`getBookNumber(${bookID})) returning ${numberResult}`);
    return numberResult;
}
*/

/*
// function to convert an array to an object
// with keys being 0..n
export const array_to_obj = ( ar => {
  const ob = {};
  Object.assign(ob,ar);
  return ob;
});

// function to convert map to object
export const map_to_obj = ( mp => {
  const ob = {};
  mp.forEach((v,k) => {ob[k]=v});
  return ob;
});

// function to convert object to a map
export const obj_to_map = ( ob => {
  const mp = new Map();
  Object.keys ( ob ).forEach (k => { mp.set(k, ob[k]) });
  return mp;
});

// function to convert word frequency map
// to an object suitable for MaterialTable
export const wf_to_mt = ( ob => {
  const mt = {};
  mt.title = "Word Frequency";
  mt.columns = [
      { title: "Word", field: "word" },
      { title: "Count", field: "check" },
  ];
  mt.data = [];
  Object.keys(ob).forEach ( w => {
      mt.data.push({ word: w, check: ob[w] })
  })

  mt.options = { sorting: true, exportButton: true };

  return mt;
});

// function to convert an array of words to
// an object suitable for MaterialTable
export const aw_to_mt = ( ar => {
  // first convert array to object
  const ob = array_to_obj(ar);
  const mt = {};
  mt.title = "All Words in Text Order";
  mt.columns = [
      { title: "Order", field: "order" , type: "numeric"},
      { title: "Word", field: "word" },
  ];
  mt.data = [];
  Object.keys(ob).forEach ( n => {
      mt.data.push({ order: n, word: ob[n] })
  });

  mt.options = { sorting: true };

  return mt;
});
*/
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9jb3JlL3V0aWxpdGllcy5qcyJdLCJuYW1lcyI6WyJ1c2VyTG9nIiwibG9nU3RyaW5nIiwib3B0aW9uYWxQYXJhbWV0ZXIyIiwiY29uc29sZSIsImxvZyIsImRlYnVnTG9nIiwiZnVuY3Rpb25Mb2ciLCJwYXJhbWV0ZXJBc3NlcnQiLCJ0cnV0aFN0YXRlbWVudCIsIm9wdGlvbmFsTWVzc2FnZSIsImFzc2VydCIsImxvZ2ljQXNzZXJ0IiwiZGF0YUFzc2VydCIsImNvbnNvbGVMb2dPYmplY3QiLCJjbFRpdGxlIiwiY2xPYmplY3QiLCJjbE91dHB1dCIsImxlbmd0aCIsInNpemUiLCJjbFByb3BlcnR5TmFtZSIsInRoaXNQcm9wZXJ0eUNvbnRlbnRzIiwic3Vic3RyaW5nIiwib1R5cGUiLCJPYmplY3QiLCJwcm90b3R5cGUiLCJ0b1N0cmluZyIsImNhbGwiLCJvTGVuZ3RoIiwib2xFcnJvciIsInVuZGVmaW5lZCIsImRpc3BsYXlQcm9wZXJ0eU5hbWVzIiwiZ2l2ZW5UaXRsZSIsImdpdmVuT2JqZWN0Iiwib3V0cHV0IiwicHJvcGVydHlOYW1lIiwib3VyUGFyc2VJbnQiLCJnaXZlblN0cmluZyIsImludCIsImlzTmFOIl0sIm1hcHBpbmdzIjoidWpCQUFBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sU0FBU0EsT0FBVCxDQUFpQkMsU0FBakIsRUFBNEJDLGtCQUE1QixFQUFnRDtBQUNuRDtBQUNBQyxFQUFBQSxPQUFPLENBQUNDLEdBQVIsa0NBQXNDSCxTQUF0QztBQUNBLE1BQUlDLGtCQUFKLEVBQXdCRixPQUFPLG1EQUE0Q0Usa0JBQTVDLHNCQUEwRUQsU0FBMUUsT0FBUDtBQUMzQjs7O0FBR0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLFNBQVNJLFFBQVQsQ0FBa0JKLFNBQWxCLEVBQTZCQyxrQkFBN0IsRUFBaUQ7QUFDcEQ7QUFDQUMsRUFBQUEsT0FBTyxDQUFDQyxHQUFSLHdDQUE0Q0gsU0FBNUM7QUFDQSxNQUFJQyxr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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXNDb250ZW50IjpbIi8vIHV0aWxpdGllcy5qc1xuXG5cbi8qKlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBsb2dTdHJpbmdcbiAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25hbFBhcmFtZXRlcjJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZXJMb2cobG9nU3RyaW5nLCBvcHRpb25hbFBhcmFtZXRlcjIpIHtcbiAgICAvLyBXZSBjYW4gcmVtb3ZlIHRoZW0gYWxsIGJ5IGRpc2FibGluZyB0aGUgbmV4dCBsaW5lXG4gICAgY29uc29sZS5sb2coYHV3LWNvbnRlbnQtdmFsaWRhdGlvbjogJHtsb2dTdHJpbmd9YCk7XG4gICAgaWYgKG9wdGlvbmFsUGFyYW1ldGVyMikgdXNlckxvZyhgdXNlckxvZyBub3RlOiB3ZSBoYXZlIGEgMm5kIHBhcmFtZXRlcjogJyR7b3B0aW9uYWxQYXJhbWV0ZXIyfScgYWZ0ZXIgJyR7bG9nU3RyaW5nfSdgKTtcbn1cblxuXG4vKipcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gbG9nU3RyaW5nXG4gKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9uYWxQYXJhbWV0ZXIyXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZWJ1Z0xvZyhsb2dTdHJpbmcsIG9wdGlvbmFsUGFyYW1ldGVyMikge1xuICAgIC8vIFdlIGNhbiByZW1vdmUgdGhlbSBhbGwgYnkgZGlzYWJsaW5nIHRoZSBuZXh0IGxpbmVcbiAgICBjb25zb2xlLmxvZyhgdXctY29udGVudC12YWxpZGF0aW9uIGRlYnVnOiAke2xvZ1N0cmluZ31gKTtcbiAgICBpZiAob3B0aW9uYWxQYXJhbWV0ZXIyKSBkZWJ1Z0xvZyhgZGVidWdMb2cgbm90ZTogd2UgaGF2ZSBhIDJuZCBwYXJhbWV0ZXI6ICcke29wdGlvbmFsUGFyYW1ldGVyMn0nIGFmdGVyICcke2xvZ1N0cmluZ30nYCk7XG59XG5cblxuLyoqXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGxvZ1N0cmluZ1xuICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbmFsUGFyYW1ldGVyMlxuICovXG5leHBvcnQgZnVuY3Rpb24gZnVuY3Rpb25Mb2cobG9nU3RyaW5nLCBvcHRpb25hbFBhcmFtZXRlcjIpIHtcbiAgICAvLyBXZSBjYW4gcmVtb3ZlIHRoZW0gYWxsIGJ5IGRpc2FibGluZyB0aGUgbmV4dCBsaW5lXG4gICAgY29uc29sZS5sb2coYHV3LWNvbnRlbnQtdmFsaWRhdGlvbiBmdW5jdGlvbiBjYWxsOiAke2xvZ1N0cmluZ31gKTtcbiAgICBpZiAob3B0aW9uYWxQYXJhbWV0ZXIyKSBmdW5jdGlvbkxvZyhgZnVuY3Rpb25Mb2cgbm90ZTogd2UgaGF2ZSBhIDJuZCBwYXJhbWV0ZXI6ICcke29wdGlvbmFsUGFyYW1ldGVyMn0nIGFmdGVyICcke2xvZ1N0cmluZ30nYCk7XG59XG5cblxuLyoqXG4gKlxuICogQHBhcmFtIHsqfSB0cnV0aFN0YXRlbWVudFxuICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbmFsTWVzc2FnZVxuICovXG5leHBvcnQgZnVuY3Rpb24gcGFyYW1ldGVyQXNzZXJ0KHRydXRoU3RhdGVtZW50LCBvcHRpb25hbE1lc3NhZ2UpIHtcbiAgICAvLyBXZSBjYW4gcmVtb3ZlIHRoZW0gYWxsIGJ5IGRpc2FibGluZyB0aGUgbmV4dCBsaW5lXG4gICAgY29uc29sZS5hc3NlcnQodHJ1dGhTdGF0ZW1lbnQsIGB1dy1jb250ZW50LXZhbGlkYXRpb24gcGFyYW1ldGVyQXNzZXJ0OiAke29wdGlvbmFsTWVzc2FnZX1gKTtcbn1cblxuXG4vKipcbiAqXG4gKiBAcGFyYW0geyp9IHRydXRoU3RhdGVtZW50XG4gKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9uYWxNZXNzYWdlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBsb2dpY0Fzc2VydCh0cnV0aFN0YXRlbWVudCwgb3B0aW9uYWxNZXNzYWdlKSB7XG4gICAgLy8gV2UgY2FuIHJlbW92ZSB0aGVtIGFsbCBieSBkaXNhYmxpbmcgdGhlIG5leHQgbGluZVxuICAgIGNvbnNvbGUuYXNzZXJ0KHRydXRoU3RhdGVtZW50LCBgdXctY29udGVudC12YWxpZGF0aW9uIGxvZ2ljQXNzZXJ0OiAke29wdGlvbmFsTWVzc2FnZX1gKTtcbn1cblxuXG4vKipcbiAqXG4gKiBAcGFyYW0geyp9IHRydXRoU3RhdGVtZW50XG4gKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9uYWxNZXNzYWdlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkYXRhQXNzZXJ0KHRydXRoU3RhdGVtZW50LCBvcHRpb25hbE1lc3NhZ2UpIHtcbiAgICAvLyBXZSBjYW4gcmVtb3ZlIHRoZW0gYWxsIGJ5IGRpc2FibGluZyB0aGUgbmV4dCBsaW5lXG4gICAgY29uc29sZS5hc3NlcnQodHJ1dGhTdGF0ZW1lbnQsIGB1dy1jb250ZW50LXZhbGlkYXRpb24gZGF0YUFzc2VydDogJHtvcHRpb25hbE1lc3NhZ2V9YCk7XG59XG5cblxuLyoqXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGNsVGl0bGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBjbE9iamVjdFxuICovXG5leHBvcnQgZnVuY3Rpb24gY29uc29sZUxvZ09iamVjdChjbFRpdGxlLCBjbE9iamVjdCkge1xuICAgIC8vIFByaW50IGFuIG9iamVjdOKAmXMgY29tcG9uZW5ldHMgdG8gdGhlIGNvbnNvbGVcbiAgICAvLyBOb3RlOiB0aGUgZm9sbG93aW5nIGxpbmUgc3VjY2VlZHMgZXZlbiBpZiBsZW5ndGggYW5kL29yIHNpemUgYXJlIHVuZGVmaW5lZFxuICAgIGxldCBjbE91dHB1dCA9IGBjTE86ICR7Y2xUaXRsZX0gJHt0eXBlb2YgY2xPYmplY3R9IChsZW5ndGg9JHtjbE9iamVjdC5sZW5ndGh9KSAoc2l6ZT0ke2NsT2JqZWN0LnNpemV9KTpcXG5gO1xuICAgIGZvciAoY29uc3QgY2xQcm9wZXJ0eU5hbWUgaW4gY2xPYmplY3QpIHtcbiAgICAgICAgLy8gZGVidWdMb2coXCIgICBcIiwgY2xUaXRsZSwgY2xQcm9wZXJ0eU5hbWUpOyAvLyBmb3IgZGVidWdnaW5nIG9ubHkhXG4gICAgICAgIGxldCB0aGlzUHJvcGVydHlDb250ZW50cyA9IFwiXCIgKyBjbE9iamVjdFtjbFByb3BlcnR5TmFtZV07XG4gICAgICAgIGlmICh0aGlzUHJvcGVydHlDb250ZW50cy5sZW5ndGggPiA1MClcbiAgICAgICAgICAgIHRoaXNQcm9wZXJ0eUNvbnRlbnRzID0gYCgke3RoaXNQcm9wZXJ0eUNvbnRlbnRzLmxlbmd0aH0pICR7dGhpc1Byb3BlcnR5Q29udGVudHMuc3Vic3RyaW5nKDAsIDUwKX3igKZgO1xuICAgICAgICBsZXQgb1R5cGUgPSB0eXBlb2YgY2xPYmplY3RbY2xQcm9wZXJ0eU5hbWVdO1xuICAgICAgICAvLyBGcm9tIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzEyOTk2ODcxL3doeS1kb2VzLXR5cGVvZi1hcnJheS13aXRoLW9iamVjdHMtcmV0dXJuLW9iamVjdC1hbmQtbm90LWFycmF5IzEyOTk2ODc5XG4gICAgICAgIGlmIChvVHlwZSA9PT0gXCJvYmplY3RcIiAmJiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoY2xPYmplY3RbY2xQcm9wZXJ0eU5hbWVdKSA9PT0gXCJbb2JqZWN0IEFycmF5XVwiKVxuICAgICAgICAgICAgb1R5cGUgPSBcImFycmF5XCI7XG4gICAgICAgIGNsT3V0cHV0ICs9IGAgICR7Y2xQcm9wZXJ0eU5hbWV9ICh0eXBlPSR7b1R5cGV9KWA7XG4gICAgICAgIGxldCBvTGVuZ3RoO1xuICAgICAgICB0cnkgeyBvTGVuZ3RoID0gY2xPYmplY3RbY2xQcm9wZXJ0eU5hbWVdLmxlbmd0aDsgfVxuICAgICAgICBjYXRjaCAob2xFcnJvcikgeyBvTGVuZ3RoID0gXCJudWxsXCIgfVxuICAgICAgICBpZiAob0xlbmd0aCAhPT0gdW5kZWZpbmVkKSBjbE91dHB1dCArPSBgIChsZW5ndGg9JHtvTGVuZ3RofSlgO1xuICAgICAgICBpZiAodGhpc1Byb3BlcnR5Q29udGVudHMgIT09IHVuZGVmaW5lZCkgY2xPdXRwdXQgKz0gYDogJHt0aGlzUHJvcGVydHlDb250ZW50c31cbmA7XG4gICAgfVxuICAgIHVzZXJMb2coY2xPdXRwdXQpO1xufVxuLy8gZW5kIG9mIGNvbnNvbGVMb2dPYmplY3QgZnVuY3Rpb25cblxuXG4vKipcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gZ2l2ZW5UaXRsZVxuICogQHBhcmFtIHtPYmplY3R9IGdpdmVuT2JqZWN0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkaXNwbGF5UHJvcGVydHlOYW1lcyhnaXZlblRpdGxlLCBnaXZlbk9iamVjdCkge1xuICAgIGxldCBvdXRwdXQgPSBgZFBOOiAke2dpdmVuVGl0bGV9ICR7dHlwZW9mIGdpdmVuT2JqZWN0fTpcbmA7XG4gICAgZm9yIChjb25zdCBwcm9wZXJ0eU5hbWUgaW4gZ2l2ZW5PYmplY3QpXG4gICAgICAgIG91dHB1dCArPSBgICAke3Byb3BlcnR5TmFtZX0gKHR5cGU9JHt0eXBlb2YgZ2l2ZW5PYmplY3RbcHJvcGVydHlOYW1lXX0pXG5gO1xuICAgIHVzZXJMb2cob3V0cHV0KTtcbn1cbi8vIGVuZCBvZiBkaXNwbGF5UHJvcGVydHlOYW1lcyBmdW5jdGlvblxuXG5cbi8qKlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBnaXZlblN0cmluZ1xuICovXG5leHBvcnQgZnVuY3Rpb24gb3VyUGFyc2VJbnQoZ2l2ZW5TdHJpbmcpIHtcbiAgICAvKlxuICAgIFRoZSByZWd1bGFyIHBhcnNlSW50KCkgZnVuY3Rpb24gaXMgdG9vIGZvcmdpdmluZ1xuXG4gICAgU2VlIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzExMzM3NzAvaG93LXRvLWNvbnZlcnQtYS1zdHJpbmctdG8tYW4taW50ZWdlci1pbi1qYXZhc2NyaXB0XG5cbiAgICBUaGlzIG9uZSB0aHJvd3MgYW4gZXJyb3IgaWYgdGhlIGVudGlyZSBmaWVsZCBkb2VzbuKAmXQgZ2l2ZSBhbiBpbnRlZ2VyLlxuICAgICovXG5cbiAgICAvKiBGaXJzdCBhdHRlbXB0XG4gICAgY29uc3QgaW50MSA9IHBhcnNlSW50KGdpdmVuU3RyaW5nLCAxMCk7IC8vIERvbuKAmXQgbGV0IHRoZSBmdW5jdGlvbiBndWVzcyB0aGUgYmFzZSAoaWYgdGhlIHN0cmluZyBoYXMgYSBsZWFkaW5nIHplcm8pXG4gICAgY29uc3QgaW50MiA9IGdpdmVuU3RyaW5nICogMTsgLy8gVGhpcyBvbmUgaXMgbGVzcyBmb3JnaXZpbmcgaXQgc2VlbXNcbiAgICBpZiAoaW50MSE9PWludDIpIHVzZXJMb2coYEZyb20gJyR7Z2l2ZW5TdHJpbmd9JyB3ZSBnb3QgJHtpbnQxfSAoJHt0eXBlb2YgaW50MX0pIGFuZCAke2ludDJ9ICgke3R5cGVvZiBpbnQyfSlgKVxuICAgIGlmIChpc05hTihpbnQyKSB8fCBpc05hTihpbnQxKVxuICAgIHx8IGludDI9PT11bmRlZmluZWQgfHwgaW50MT09dW5kZWZpbmVkXG4gICAgfHwgaW50MiE9PWludDEpXG4gICAgICAgIHRocm93IFwiU3RyaW5nIGlzIG5vdCBhIHNpbXBsZSBpbnRlZ2VyXCI7XG4gICAgcmV0dXJuIGludDE7XG4gICAgKi9cbiAgICAvL3BhcmFtZXRlckFzc2VydCh0eXBlb2YgZ2l2ZW5TdHJpbmcgPT09ICdzdHJpbmcnLCBgb3VyUGFyc2VJbnQ6ICdnaXZlblN0cmluZycgcGFyYW1ldGVyIHNob3VsZCBiZSBhIHN0cmluZyBub3QgYSAnJHt0eXBlb2YgZ2l2ZW5TdHJpbmd9JzogJHtnaXZlblN0cmluZ31gKTtcbiAgICAvL3BhcmFtZXRlckFzc2VydChnaXZlblN0cmluZy5sZW5ndGggPiAwLCBcIm91clBhcnNlSW50OiAnZ2l2ZW5TdHJpbmcnIHBhcmFtZXRlciBzaG91bGQgYmUgbm90IGJlIGFuIGVtcHR5IHN0cmluZyFcIik7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXRocm93LWxpdGVyYWxcbiAgICBpZiAoZ2l2ZW5TdHJpbmcubGVuZ3RoID09PSAwKSB0aHJvdyBgU3RyaW5nICcke2dpdmVuU3RyaW5nfSdpcyBlbXB0eWA7XG5cbiAgICAvLyBPcHRpbWlzZWQgdmVyc2lvblxuICAgIGNvbnN0IGludCA9IGdpdmVuU3RyaW5nICogMTsgLy8gVGhpcyBvbmUgaXMgbGVzcyBmb3JnaXZpbmcgaXQgc2VlbXNcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdGhyb3ctbGl0ZXJhbFxuICAgIGlmIChpc05hTihpbnQpKSB0aHJvdyBgU3RyaW5nICcke2dpdmVuU3RyaW5nfScgaXMgbm90IGEgc2ltcGxlIGludGVnZXJgO1xuICAgIHJldHVybiBpbnQ7XG59XG5cblxuLypcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gYm9va0lEIC0gMy1jaGFyYWN0ZXIgVVBQRVJDQVNFIEJvb2sgSWRcbiAqIEByZXF1aXJlcyB7bnVtYmVyfSAwLi45OVxuICovXG4vKlxuZXhwb3J0IGZ1bmN0aW9uIGdldEJvb2tOdW1iZXIoYm9va0lEKSB7XG4gICAgLy8gZGVidWdMb2coYGdldEJvb2tOdW1iZXIoJHtib29rSUR9KeKApmApXG4gICAgbGV0IG51bWJlclJlc3VsdCA9IDk5OyAvLyBkZWZhdWx0ICd1bmtub3duJyB2YWx1ZVxuICAgIGlmIChib29rSUQ9PT0nRlJUJykgbnVtYmVyUmVzdWx0ID0gMDtcbiAgICBlbHNlIGlmIChib29rSUQ9PT0nQkFLJykgbnVtYmVyUmVzdWx0ID0gNjg7XG4gICAgZWxzZSBpZiAoYm9va0lEPT09J09CUycpIG51bWJlclJlc3VsdCA9IDgwO1xuICAgIGVsc2UgaWYgKGJvb2tJRD09PSdNQU5JRkVTVCcpIG51bWJlclJlc3VsdCA9IDgxO1xuICAgIGVsc2UgaWYgKGJvb2tJRD09PSdNRURJQScpIG51bWJlclJlc3VsdCA9IDgyO1xuICAgIGVsc2UgaWYgKGJvb2tJRD09PSdMSUNFTlNFJykgbnVtYmVyUmVzdWx0ID0gODM7XG4gICAgZWxzZSBpZiAoYm9va0lEPT09J1JFQURNRScpIG51bWJlclJlc3VsdCA9IDg0O1xuICAgIGVsc2Uge1xuICAgICAgICBjb25zdCB0aGlzVVNGTU51bWJlck5hbWUgPSB1c2ZtTnVtYmVyTmFtZShib29rSUQpO1xuICAgICAgICBudW1iZXJSZXN1bHQgPSBvdXJQYXJzZUludCh0aGlzVVNGTU51bWJlck5hbWUuc3Vic3RyaW5nKDAsIDIpKTsgLy8gMDEuLjY3IGNvbnZlcnRlZCB0byBudW1iZXJcbiAgICAvLyB9IGNhdGNoIHt9XG4gICAgfVxuICAgIC8vIEZvciBldmVyeXRoaW5nIGVsc2VcbiAgICAvLyBkZWJ1Z0xvZyhgZ2V0Qm9va051bWJlcigke2Jvb2tJRH0pKSByZXR1cm5pbmcgJHtudW1iZXJSZXN1bHR9YCk7XG4gICAgcmV0dXJuIG51bWJlclJlc3VsdDtcbn1cbiovXG5cbi8qXG4vLyBmdW5jdGlvbiB0byBjb252ZXJ0IGFuIGFycmF5IHRvIGFuIG9iamVjdFxuLy8gd2l0aCBrZXlzIGJlaW5nIDAuLm5cbmV4cG9ydCBjb25zdCBhcnJheV90b19vYmogPSAoIGFyID0+IHtcbiAgY29uc3Qgb2IgPSB7fTtcbiAgT2JqZWN0LmFzc2lnbihvYixhcik7XG4gIHJldHVybiBvYjtcbn0pO1xuXG4vLyBmdW5jdGlvbiB0byBjb252ZXJ0IG1hcCB0byBvYmplY3RcbmV4cG9ydCBjb25zdCBtYXBfdG9fb2JqID0gKCBtcCA9PiB7XG4gIGNvbnN0IG9iID0ge307XG4gIG1wLmZvckVhY2goKHYsaykgPT4ge29iW2tdPXZ9KTtcbiAgcmV0dXJuIG9iO1xufSk7XG5cbi8vIGZ1bmN0aW9uIHRvIGNvbnZlcnQgb2JqZWN0IHRvIGEgbWFwXG5leHBvcnQgY29uc3Qgb2JqX3RvX21hcCA9ICggb2IgPT4ge1xuICBjb25zdCBtcCA9IG5ldyBNYXAoKTtcbiAgT2JqZWN0LmtleXMgKCBvYiApLmZvckVhY2ggKGsgPT4geyBtcC5zZXQoaywgb2Jba10pIH0pO1xuICByZXR1cm4gbXA7XG59KTtcblxuLy8gZnVuY3Rpb24gdG8gY29udmVydCB3b3JkIGZyZXF1ZW5jeSBtYXBcbi8vIHRvIGFuIG9iamVjdCBzdWl0YWJsZSBmb3IgTWF0ZXJpYWxUYWJsZVxuZXhwb3J0IGNvbnN0IHdmX3RvX210ID0gKCBvYiA9PiB7XG4gIGNvbnN0IG10ID0ge307XG4gIG10LnRpdGxlID0gXCJXb3JkIEZyZXF1ZW5jeVwiO1xuICBtdC5jb2x1bW5zID0gW1xuICAgICAgeyB0aXRsZTogXCJXb3JkXCIsIGZpZWxkOiBcIndvcmRcIiB9LFxuICAgICAgeyB0aXRsZTogXCJDb3VudFwiLCBmaWVsZDogXCJjaGVja1wiIH0sXG4gIF07XG4gIG10LmRhdGEgPSBbXTtcbiAgT2JqZWN0LmtleXMob2IpLmZvckVhY2ggKCB3ID0+IHtcbiAgICAgIG10LmRhdGEucHVzaCh7IHdvcmQ6IHcsIGNoZWNrOiBvYlt3XSB9KVxuICB9KVxuXG4gIG10Lm9wdGlvbnMgPSB7IHNvcnRpbmc6IHRydWUsIGV4cG9ydEJ1dHRvbjogdHJ1ZSB9O1xuXG4gIHJldHVybiBtdDtcbn0pO1xuXG4vLyBmdW5jdGlvbiB0byBjb252ZXJ0IGFuIGFycmF5IG9mIHdvcmRzIHRvXG4vLyBhbiBvYmplY3Qgc3VpdGFibGUgZm9yIE1hdGVyaWFsVGFibGVcbmV4cG9ydCBjb25zdCBhd190b19tdCA9ICggYXIgPT4ge1xuICAvLyBmaXJzdCBjb252ZXJ0IGFycmF5IHRvIG9iamVjdFxuICBjb25zdCBvYiA9IGFycmF5X3RvX29iaihhcik7XG4gIGNvbnN0IG10ID0ge307XG4gIG10LnRpdGxlID0gXCJBbGwgV29yZHMgaW4gVGV4dCBPcmRlclwiO1xuICBtdC5jb2x1bW5zID0gW1xuICAgICAgeyB0aXRsZTogXCJPcmRlclwiLCBmaWVsZDogXCJvcmRlclwiICwgdHlwZTogXCJudW1lcmljXCJ9LFxuICAgICAgeyB0aXRsZTogXCJXb3JkXCIsIGZpZWxkOiBcIndvcmRcIiB9LFxuICBdO1xuICBtdC5kYXRhID0gW107XG4gIE9iamVjdC5rZXlzKG9iKS5mb3JFYWNoICggbiA9PiB7XG4gICAgICBtdC5kYXRhLnB1c2goeyBvcmRlcjogbiwgd29yZDogb2Jbbl0gfSlcbiAgfSk7XG5cbiAgbXQub3B0aW9ucyA9IHsgc29ydGluZzogdHJ1ZSB9O1xuXG4gIHJldHVybiBtdDtcbn0pO1xuKi9cbiJdfQ==