"use strict";var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");Object.defineProperty(exports, "__esModule", { value: true });exports.checkMarkdownText = checkMarkdownText;var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));
var _defaults = require("./defaults");
var _fieldTextCheck = require("./field-text-check");
var _notesLinksCheck = require("./notes-links-check");

var _disabledNotices = require("./disabled-notices");

var _utilities = require("./utilities");function ownKeys(object, enumerableOnly) {var keys = Object.keys(object);if (Object.getOwnPropertySymbols) {var symbols = Object.getOwnPropertySymbols(object);if (enumerableOnly) {symbols = symbols.filter(function (sym) {return Object.getOwnPropertyDescriptor(object, sym).enumerable;});}keys.push.apply(keys, symbols);}return keys;}function _objectSpread(target) {for (var i = 1; i < arguments.length; i++) {var source = arguments[i] != null ? arguments[i] : {};if (i % 2) {ownKeys(Object(source), true).forEach(function (key) {(0, _defineProperty2.default)(target, key, source[key]);});} else if (Object.getOwnPropertyDescriptors) {Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));} else {ownKeys(Object(source)).forEach(function (key) {Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));});}}return target;}function _createForOfIteratorHelper(o, allowArrayLike) {var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];if (!it) {if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {if (it) o = it;var i = 0;var F = function F() {};return { s: F, n: function n() {if (i >= o.length) return { done: true };return { done: false, value: o[i++] };}, e: function e(_e) {throw _e;}, f: F };}throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");}var normalCompletion = true,didErr = false,err;return { s: function s() {it = it.call(o);}, n: function n() {var step = it.next();normalCompletion = step.done;return step;}, e: function e(_e2) {didErr = true;err = _e2;}, f: function f() {try {if (!normalCompletion && it.return != null) it.return();} finally {if (didErr) throw err;}} };}function _unsupportedIterableToArray(o, minLen) {if (!o) return;if (typeof o === "string") return _arrayLikeToArray(o, minLen);var n = Object.prototype.toString.call(o).slice(8, -1);if (n === "Object" && o.constructor) n = o.constructor.name;if (n === "Map" || n === "Set") return Array.from(o);if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);}function _arrayLikeToArray(arr, len) {if (len == null || len > arr.length) len = arr.length;for (var i = 0, arr2 = new Array(len); i < len; i++) {arr2[i] = arr[i];}return arr2;}


var MARKDOWN_TEXT_VALIDATOR_VERSION_STRING = '0.7.3';


/**
 *
 * @param {string} languageCode, e.g., 'en'
 * @param {string} repoCode -- e.g., 'TN' or 'TQ2', etc.
 * @param {string} textOrFileName -- used for identification
 * @param {string} markdownText -- the actual text to be checked
 * @param {string} givenLocation
 * @param {Object} checkingOptions
 */function
checkMarkdownText(_x, _x2, _x3, _x4, _x5, _x6) {return _checkMarkdownText.apply(this, arguments);}







































































































































































































































































































































































































// end of checkMarkdownText function
function _checkMarkdownText() {_checkMarkdownText = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee3(languageCode, repoCode, textOrFileName, markdownText, givenLocation, checkingOptions) {var ourLocation, excerptLength, excerptHalfLength, excerptHalfLengthPlus, result, addSuccessMessage, addNotice, ourCheckTextField, ourCheckNotesLinksToOutside, _ourCheckNotesLinksToOutside, checkMarkdownLineContents, _checkMarkdownLineContents, lines, headerLevel, lastLine, indentLevels, suggestedLines, notifiedBlankLines, n, line, nextLine, notice, _notice, numLeadingSpaces, thisHeaderLevel, _notice2, previousIndentLevel, foundPreviousLevel, z, _notice3, suggestedLine, _notice4, _i, _arr, thisSet, thisField, thisRegex, count, characterIndex, iy, excerpt, suggestion;return _regenerator.default.wrap(function _callee3$(_context3) {while (1) {switch (_context3.prev = _context3.next) {case 0:_checkMarkdownLineContents = function _checkMarkdownLineCon2() {_checkMarkdownLineContents = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee2(lineNumber, lineText, lineLocation) {var thisText, suggestion;return _regenerator.default.wrap(function _callee2$(_context2) {while (1) {switch (_context2.prev = _context2.next) {case 0:if (!(lineText.indexOf('[') >= 0)) {_context2.next = 3;break;}_context2.next = 3;return ourCheckNotesLinksToOutside(lineNumber, lineText, givenLocation, checkingOptions);case 3:thisText = lineText; // so we can adjust it
                        // Remove leading and trailing hash signs #
                        thisText = thisText.replace(/^#+|#+$/g, ''); // debugLog(`After removing hashes have '${thisText}'`);
                        // Remove leading spaces
                        thisText = thisText.replace(/^ +/g, ''); // Remove leading block text markers >
                        while (thisText.startsWith('>')) {thisText = thisText.replace(/^>+ */g, '');} // if (thisText.indexOf('>') >= 0) userLog(`After removing leading block text markers from '${lineText}' still have '${thisText}'`);
                        // Remove leading spaces again
                        // thisText = thisText.replace(/^ +/g, '');
                        // debugLog(`After removing leading spaces have '${thisText}'`);
                        // // Remove leading asterisks
                        // thisText = thisText.replace(/^\*/g,'')
                        // debugLog(`After removing asterisks have '${thisText}'`);
                        // // Remove leading spaces again now
                        // thisText = thisText.replace(/^ +/g,'')
                        // debugLog(`After removing more leading spaces have '${thisText}'`);
                        if (thisText && lineText[0] !== '|') // Doesn’t really make sense to check table line entries
                          suggestion = ourCheckTextField(textOrFileName, lineNumber, thisText, true, lineLocation, checkingOptions);if (!(thisText === lineText)) {_context2.next = 10;break;}return _context2.abrupt("return", suggestion);case 10:case "end":return _context2.stop();}}}, _callee2);}));return _checkMarkdownLineContents.apply(this, arguments);};checkMarkdownLineContents = function _checkMarkdownLineCon(_x11, _x12, _x13) {return _checkMarkdownLineContents.apply(this, arguments);};_ourCheckNotesLinksToOutside = function _ourCheckNotesLinksTo2() {_ourCheckNotesLinksToOutside = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee(lineNumber, lineText, location, checkingOptions) {var adjustedTextOrFileName, adjustedLanguageCode, coTNlResultObject, _iterator2, _step2, coqNoticeEntry, _iterator3, _step3, checkedRepoName, _iterator4, _step4, checkedFilenameExtension;return _regenerator.default.wrap(function _callee$(_context) {while (1) {switch (_context.prev = _context.next) {case 0: // Checks that the TA/TW/Bible reference can be found
                        // Updates the global list of notices
                        // functionLog(`checkUSFMText ourCheckNotesLinksToOutside(${lineNumber}, ${C}:${V}, ${marker}, (${twLinkText.length}) '${twLinkText}', ${location}, ${JSON.stringify(checkingOptions)})`);
                        //parameterAssert(lineNumber !== undefined, "checkUSFMText ourCheckNotesLinksToOutside: 'lineNumber' parameter should be defined");
                        //parameterAssert(typeof lineNumber === 'number', `checkUSFMText ourCheckNotesLinksToOutside: 'lineNumber' parameter should be a number not a '${typeof lineNumber}': ${lineNumber}`);
                        //parameterAssert(lineText !== undefined, "checkUSFMText ourCheckNotesLinksToOutside: 'lineText' parameter should be defined");
                        //parameterAssert(typeof lineText === 'string', `checkUSFMText ourCheckNotesLinksToOutside: 'lineText' parameter should be a string not a '${typeof lineText}': ${lineText}`);
                        //parameterAssert(location !== undefined, "checkUSFMText ourCheckNotesLinksToOutside: 'location' parameter should be defined");
                        //parameterAssert(typeof location === 'string', `checkUSFMText ourCheckNotesLinksToOutside: 'location' parameter should be a string not a '${typeof location}': ${location}`);
                        // Empty fields on the next line are bookID, C, V (as we don't have that information here)
                        adjustedTextOrFileName = textOrFileName;if (textOrFileName === 'README.md' || textOrFileName === 'LICENSE.md') adjustedTextOrFileName = textOrFileName.substring(0, textOrFileName.length - 3);adjustedLanguageCode = languageCode; // This is the language code of the resource with the link
                        if (languageCode === 'hbo' || languageCode === 'el-x-koine') adjustedLanguageCode = 'en'; // This is a guess (and won't be needed for TWs when we switch to TWLs)
                        _context.next = 6;return (0, _notesLinksCheck.checkNotesLinksToOutside)(languageCode, repoCode, '', '', '', adjustedTextOrFileName, lineText, location, _objectSpread(_objectSpread({}, checkingOptions), {}, { defaultLanguageCode: adjustedLanguageCode }));case 6:coTNlResultObject = _context.sent; // debugLog(`coTNlResultObject=${JSON.stringify(coTNlResultObject)}`);
                        // Choose only ONE of the following
                        // This is the fast way of append the results from this field
                        // result.noticeList = result.noticeList.concat(coTNlResultObject.noticeList);
                        // If we need to put everything through addNoticePartial, e.g., for debugging or filtering
                        //  process results line by line
                        _iterator2 = _createForOfIteratorHelper(coTNlResultObject.noticeList);try {for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {coqNoticeEntry = _step2.value;if (coqNoticeEntry.extra) // it must be an indirect check on a TA or TW article from a TN2 check
                              result.noticeList.push(coqNoticeEntry); // Just copy the complete notice as is -- would be confusing to have this lineNumber
                            else // For our direct checks, we add the repoCode as an extra value
                              addNotice(_objectSpread(_objectSpread({}, coqNoticeEntry), {}, { lineNumber: lineNumber }));} // The following is needed coz we might be checking the linked TA and/or TW articles
                        } catch (err) {_iterator2.e(err);} finally {_iterator2.f();}if (coTNlResultObject.checkedFileCount && coTNlResultObject.checkedFileCount > 0) if (typeof result.checkedFileCount === 'number') result.checkedFileCount += coTNlResultObject.checkedFileCount;else result.checkedFileCount = coTNlResultObject.checkedFileCount;if (coTNlResultObject.checkedFilesizes && coTNlResultObject.checkedFilesizes > 0) if (typeof result.checkedFilesizes === 'number') result.checkedFilesizes += coTNlResultObject.checkedFilesizes;else result.checkedFilesizes = coTNlResultObject.checkedFilesizes;if (coTNlResultObject.checkedRepoNames && coTNlResultObject.checkedRepoNames.length > 0) {_iterator3 = _createForOfIteratorHelper(coTNlResultObject.checkedRepoNames);try {for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {checkedRepoName = _step3.value;try {if (result.checkedRepoNames.indexOf(checkedRepoName) < 0) result.checkedRepoNames.push(checkedRepoName);} catch (_unused) {result.checkedRepoNames = [checkedRepoName];}}} catch (err) {_iterator3.e(err);} finally {_iterator3.f();}}if (coTNlResultObject.checkedFilenameExtensions && coTNlResultObject.checkedFilenameExtensions.length > 0) {_iterator4 = _createForOfIteratorHelper(coTNlResultObject.checkedFilenameExtensions);try {for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {checkedFilenameExtension = _step4.value;try {if (result.checkedFilenameExtensions.indexOf(checkedFilenameExtension) < 0) result.checkedFilenameExtensions.push(checkedFilenameExtension);} catch (_unused2) {result.checkedFilenameExtensions = [checkedFilenameExtension];}}} catch (err) {_iterator4.e(err);} finally {_iterator4.f();}} // if (result.checkedFilenameExtensions) userLog("result", JSON.stringify(result));
                      case 13:case "end":return _context.stop();}}}, _callee);}));return _ourCheckNotesLinksToOutside.apply(this, arguments);};ourCheckNotesLinksToOutside = function _ourCheckNotesLinksTo(_x7, _x8, _x9, _x10) {return _ourCheckNotesLinksToOutside.apply(this, arguments);};ourCheckTextField = function _ourCheckTextField(fieldName, lineNumber, fieldText, allowedLinks, optionalFieldLocation, checkingOptions) {/**
              * @description - checks the given text field and processes the returned results
              * @param {string} fieldName - name of the field being checked
              * @param {string} fieldText - the actual text of the field being checked
              * @param {boolean} allowedLinks - true if links are allowed in the field, otherwise false
              * @param {string} optionalFieldLocation - description of where the field is located
              * @param {Object} checkingOptions - parameters that might affect the check
              */ // Does basic checks for small errors like leading/trailing spaces, etc.
              // We assume that checking for compulsory fields is done elsewhere
              // Updates the global list of notices
              // functionLog(`cMdT ourCheckTextField(${fieldName}, (${fieldText.length}), ${allowedLinks}, ${optionalFieldLocation}, …)`);
              //parameterAssert(fieldName !== undefined, "cMdT ourCheckTextField: 'fieldName' parameter should be defined");
              //parameterAssert(typeof fieldName === 'string', `cMdT ourCheckTextField: 'fieldName' parameter should be a string not a '${typeof fieldName}'`);
              //parameterAssert(lineNumber !== undefined, "cMdT ourCheckTextField: 'lineNumber' parameter should be defined");
              //parameterAssert(typeof lineNumber === 'number', `cMdT ourCheckTextField: 'lineNumber' parameter should be a number not a '${typeof lineNumber}'`);
              //parameterAssert(fieldText !== undefined, "cMdT ourCheckTextField: 'fieldText' parameter should be defined");
              //parameterAssert(typeof fieldText === 'string', `cMdT ourCheckTextField: 'fieldText' parameter should be a string not a '${typeof fieldText}'`);
              //parameterAssert(allowedLinks === true || allowedLinks === false, "cMdT ourCheckTextField: allowedLinks parameter must be either true or false");
              //parameterAssert(optionalFieldLocation !== undefined, "cMdT ourCheckTextField: 'optionalFieldLocation' parameter should be defined");
              //parameterAssert(typeof optionalFieldLocation === 'string', `cMdT ourCheckTextField: 'optionalFieldLocation' parameter should be a string not a '${typeof optionalFieldLocation}'`);
              var dbtcResultObject = (0, _fieldTextCheck.checkTextField)(languageCode, repoCode, 'markdown', fieldName, fieldText, allowedLinks, optionalFieldLocation, checkingOptions); // If we need to put everything through addNotice, e.g., for debugging or filtering
              //  process results line by line
              var _iterator = _createForOfIteratorHelper(dbtcResultObject.noticeList),_step;try {for (_iterator.s(); !(_step = _iterator.n()).done;) {var noticeEntry = _step.value;addNotice(_objectSpread(_objectSpread({}, noticeEntry), {}, { lineNumber: lineNumber }));}} catch (err) {_iterator.e(err);} finally {_iterator.f();}return dbtcResultObject.suggestion; // There may or may not be one!
            };addNotice = function _addNotice(noticeObject) {// functionLog(`checkMarkdownText addNotice: (priority=${noticeObject.priority}) ${noticeObject.message}${noticeObject.characterIndex > 0 ? ` (at character ${noticeObject.characterIndex})` : ""}${noticeObject.excerpt ? " " + excerpt : ""}${noticeObject.location}`);
              //parameterAssert(noticeObject.priority !== undefined, "cMdT addNotice: 'priority' parameter should be defined");
              //parameterAssert(typeof noticeObject.priority === 'number', `cMdT addNotice: 'priority' parameter should be a number not a '${typeof noticeObject.priority}': ${noticeObject.priority}`);
              //parameterAssert(noticeObject.message !== undefined, "cMdT addNotice: 'message' parameter should be defined");
              //parameterAssert(typeof noticeObject.message === 'string', `cMdT addNotice: 'message' parameter should be a string not a '${typeof noticeObject.message}': ${noticeObject.message}`);
              // //parameterAssert(characterIndex !== undefined, "cMdT addNotice: 'characterIndex' parameter should be defined");
              if (noticeObject.characterIndex) {//parameterAssert(typeof noticeObject.characterIndex === 'number', `cMdT addNotice: 'characterIndex' parameter should be a number not a '${typeof noticeObject.characterIndex}': ${noticeObject.characterIndex}`);
              } // //parameterAssert(excerpt !== undefined, "cMdT addNotice: 'excerpt' parameter should be defined");
              if (noticeObject.excerpt) {//parameterAssert(typeof noticeObject.excerpt === 'string', `cMdT addNotice: 'excerpt' parameter should be a string not a '${typeof noticeObject.excerpt}': ${noticeObject.excerpt}`);
              } //parameterAssert(noticeObject.location !== undefined, "cMdT addNotice: 'location' parameter should be defined");
              //parameterAssert(typeof noticeObject.location === 'string', `cMdT addNotice: 'location' parameter should be a string not a '${typeof noticeObject.location}': ${noticeObject.location}`);
              // noticeObject.debugChain = noticeObject.debugChain ? `checkMarkdownText(${languageCode}, ${textOrFileName}) ${noticeObject.debugChain}` : `checkMarkdownText(${languageCode}, ${textOrFileName})`;
              result.noticeList.push(noticeObject); // Used to have filename: textName, but that isn’t always a filename !!!
            };addSuccessMessage = function _addSuccessMessage(successString) {// debugLog("checkMarkdownText success: " + successString);
              result.successList.push(successString);}; /* This function is optimised for checking the entire markdown text, i.e., all lines.
             This text may not necessarily be from a file -- it may be from a (multiline) field within a file
              Returns a result object containing a successList and a noticeList
             */ // functionLog(`checkMarkdownText(${languageCode}, ${repoCode}, ${textOrFileName}, ${markdownText.length}, ${givenLocation}, …)…`);
            //parameterAssert(languageCode !== undefined, "checkMarkdownText: 'languageCode' parameter should be defined");
            //parameterAssert(typeof languageCode === 'string', `checkMarkdownText: 'languageCode' parameter should be a string not a '${typeof languageCode}': ${languageCode}`);
            //parameterAssert(languageCode !== 'unfoldingWord', `checkMarkdownText: 'languageCode' ${languageCode} parameter should be not be 'unfoldingWord'`);
            //parameterAssert(repoCode !== undefined, "checkMarkdownText: 'repoCode' parameter should be defined");
            //parameterAssert(typeof repoCode === 'string', `checkMarkdownText: 'repoCode' parameter should be a string not a '${typeof repoCode}': ${repoCode}`);
            //parameterAssert(REPO_CODES_LIST.includes(repoCode), `checkMarkdownText: 'repoCode' parameter should not be '${repoCode}'`);
            //parameterAssert(textOrFileName !== undefined, "checkMarkdownText: 'textOrFileName' parameter should be defined");
            //parameterAssert(typeof textOrFileName === 'string', `checkMarkdownText: 'textOrFileName' parameter should be a string not a '${typeof textOrFileName}': ${textOrFileName}`);
            //parameterAssert(textOrFileName !== `${languageCode}_${repoCode.toLowerCase()}`, `checkMarkdownText: 'textOrFileName' parameter should not be the repoName: '${textOrFileName}'`);
            if (textOrFileName === "".concat(languageCode, "_").concat(repoCode.toLowerCase())) {console.trace('checkMarkdownText()');} //parameterAssert(markdownText !== undefined, "checkMarkdownText: 'markdownText' parameter should be defined");
            //parameterAssert(typeof markdownText === 'string', `checkMarkdownText: 'markdownText' parameter should be a string not a '${typeof markdownText}': ${markdownText}`);
            //parameterAssert(givenLocation !== undefined, "checkMarkdownText: 'optionalFieldLocation' parameter should be defined");
            //parameterAssert(typeof givenLocation === 'string', `checkMarkdownText: 'optionalFieldLocation' parameter should be a string not a '${typeof givenLocation}': ${givenLocation}`);
            //parameterAssert(givenLocation.indexOf('true') === -1, `checkMarkdownText: 'optionalFieldLocation' parameter should not be '${givenLocation}'`);
            //parameterAssert(checkingOptions !== undefined, "checkMarkdownText: 'checkingOptions' parameter should be defined");
            if (checkingOptions !== undefined) {//parameterAssert(typeof checkingOptions === 'object', `checkMarkdownText: 'checkingOptions' parameter should be an object not a '${typeof checkingOptions}': ${JSON.stringify(checkingOptions)}`);
            }ourLocation = givenLocation;if (ourLocation && ourLocation[0] !== ' ') ourLocation = " ".concat(ourLocation);try {excerptLength = checkingOptions === null || checkingOptions === void 0 ? void 0 : checkingOptions.excerptLength;} catch (mdtcError) {}if (typeof excerptLength !== 'number' || isNaN(excerptLength)) {excerptLength = _defaults.DEFAULT_EXCERPT_LENGTH; // debugLog("Using default excerptLength=" + excerptLength);
            } // else
            // debugLog("Using supplied excerptLength=" + excerptLength, `cf. default=${DEFAULT_EXCERPT_LENGTH}`);
            excerptHalfLength = Math.floor(excerptLength / 2); // rounded down
            excerptHalfLengthPlus = Math.floor((excerptLength + 1) / 2); // rounded up
            // debugLog("Using excerptHalfLength=" + excerptHalfLength, `excerptHalfLengthPlus=${excerptHalfLengthPlus}`);
            result = { successList: [], noticeList: [] }; // end of checkMarkdownLineContents function
            // Main code for checkMarkdownText function
            lines = markdownText.split('\n'); // debugLog(`  '${location}' has ${lines.length.toLocaleString()} total lines`);
            headerLevel = 0;indentLevels = [];suggestedLines = [];notifiedBlankLines = false;n = 1;case 22:if (!(n <= lines.length)) {_context3.next = 66;break;}line = lines[n - 1];nextLine = n < lines.length - 1 ? lines[n] : undefined; // Markdown headers should be preceded and followed by a blank line
            if (line.startsWith('#')) {if (n > 1 && lastLine.length !== 0) {notice = { priority: 252, message: "Markdown headers should be preceded by a blank line", lineNumber: n, location: ourLocation };if (textOrFileName === 'Note' || textOrFileName === 'OccurrenceNote') notice.details = "markdown line ".concat(n);addNotice(notice);}if ((nextLine === null || nextLine === void 0 ? void 0 : nextLine.length) !== 0) {_notice = { priority: 251, message: "Markdown headers should be followed by a blank line", lineNumber: n, location: ourLocation };if (textOrFileName === 'Note' || textOrFileName === 'OccurrenceNote') _notice.details = "markdown line ".concat(n);addNotice(_notice);}}numLeadingSpaces = void 0;if (!line) {_context3.next = 59;break;}thisHeaderLevel = line.match(/^#*/)[0].length; // debugLog(`Got thisHeaderLevel=${thisHeaderLevel} for ${line}${atString}`);
            if (thisHeaderLevel > headerLevel + 1 && !textOrFileName.startsWith('TA ')) {// Suppress this notice for translationAcademy subsections
              _notice2 = { priority: 172, message: "Header levels should only increment by one", lineNumber: n, characterIndex: 0, location: ourLocation };if (textOrFileName === 'Note' || textOrFileName === 'OccurrenceNote') _notice2.details = "markdown line ".concat(n);addNotice(_notice2);}if (thisHeaderLevel > 0) {headerLevel = thisHeaderLevel;indentLevels = []; // reset
            }numLeadingSpaces = line.match(/^ */)[0].length; // debugLog(`Got numLeadingSpaces=${numLeadingSpaces} with indentLevels=${JSON.stringify(indentLevels)} for ${line}${ourLocation}`);
            previousIndentLevel = indentLevels.length > 0 ? indentLevels[indentLevels.length - 1] : 0;if (!(numLeadingSpaces > previousIndentLevel || // We have an indent level increase
            numLeadingSpaces === 0 && line.length > 0 && indentLevels.length === 0)) {_context3.next = 37;break;} // we have our first zero-level indent
            indentLevels.push(numLeadingSpaces);_context3.next = 53;break;case 37:if (!(numLeadingSpaces < previousIndentLevel)) {_context3.next = 53;break;}if (!(indentLevels.length > 1 && indentLevels[indentLevels.length - 2] === numLeadingSpaces)) {_context3.next = 42;break;} // We went back to the previous level
            indentLevels.pop();_context3.next = 53;break;case 42: // seems we didn't go back to the previous level ???
            foundPreviousLevel = false;z = indentLevels.length - 1;case 44:if (!(z >= 0)) {_context3.next = 52;break;}if (!(indentLevels[z] === numLeadingSpaces)) {_context3.next = 49;break;} // debugLog(`After finding ${numLeadingSpaces} spaces, reducing length of ${JSON.stringify(indentLevels)} to ${z+1}`);
            indentLevels.length = z + 1;foundPreviousLevel = true;return _context3.abrupt("break", 52);case 49:z--;_context3.next = 44;break;case 52:if (!foundPreviousLevel) {_notice3 = { priority: 282, message: "Nesting of header levels seems confused", details: "recent indent levels=".concat(JSON.stringify(indentLevels), " but now ").concat(numLeadingSpaces), lineNumber: n, characterIndex: 0, location: ourLocation };if (textOrFileName === 'Note' || textOrFileName === 'OccurrenceNote') _notice3.details = "markdown line ".concat(n);addNotice(_notice3);}case 53:_context3.next = 55;return checkMarkdownLineContents(n, line, ourLocation);case 55:suggestedLine = _context3.sent;suggestedLines.push(suggestedLine === undefined ? line : suggestedLine);_context3.next = 62;break;case 59: // This is a blank line
            numLeadingSpaces = 0;suggestedLines.push(''); // Should only ever have single blank lines in markdown
            if (n > 1 && lastLine.length === 0 && (nextLine === null || nextLine === void 0 ? void 0 : nextLine.length) === 0 && !notifiedBlankLines) {_notice4 = { priority: 250, message: "Multiple blank lines are not expected in markdown", lineNumber: n, location: ourLocation };if (textOrFileName === 'Note' || textOrFileName === 'OccurrenceNote') _notice4.details = "markdown line ".concat(n);addNotice(_notice4);notifiedBlankLines = true;}case 62:lastLine = line; // lastNumLeadingSpaces = numLeadingSpaces;
          case 63:n++;_context3.next = 22;break;case 66:_i = 0, _arr = [// Put longest ones first
            // Seems that the fancy ones (commented out) don't find occurrences at the start (or end?) of the text
            ['___', /___/g], // ['___', r'[^_]___[^_]'], // three underlines
            ['***', /\*\*\*/g], // ['***', r'[^\*]\*\*\*[^\*]'], // three asterisks
            ['__', /__/g], // ['__', r'[^_]__[^_]'], // two underlines
            ['**', /\*\*/g] // ['**', r'[^\*]\*\*[^\*]'], // two asterisks
            ];case 67:if (!(_i < _arr.length)) {_context3.next = 80;break;}thisSet = _arr[_i];thisField = thisSet[0], thisRegex = thisSet[1];count = ((markdownText || '').match(thisRegex) || []).length; // Finds only NON-OVERLAPPING matches hopefully
            if (!(count && count % 2 !== 0)) {_context3.next = 77;break;}characterIndex = markdownText.indexOf(thisField);iy = characterIndex + excerptHalfLength; // Want excerpt to focus more on what follows
            excerpt = /*(iy > excerptHalfLength ? '…' : '') +*/markdownText.substring(iy - excerptHalfLength, iy + excerptHalfLengthPlus) + (iy + excerptHalfLengthPlus < markdownText.length ? '…' : '');addNotice({ priority: 378, message: "Possible mismatched '".concat(thisField, "' markdown formatting pairs"), details: "".concat(count.toLocaleString(), " total occurrence").concat(count === 1 ? '' : 's'), characterIndex: characterIndex, excerpt: excerpt, location: ourLocation });return _context3.abrupt("break", 80);case 77:_i++;_context3.next = 67;break;case 80:suggestion = suggestedLines.join('\n');if (suggestion !== markdownText) {// debugLog(`Had markdown ${markdownText}`);
              // debugLog(`Sug markdown ${suggestion}`);
              result.suggestion = suggestion;}if (!(checkingOptions !== null && checkingOptions !== void 0 && checkingOptions.suppressNoticeDisablingFlag)) {// functionLog(`checkMarkdownText: calling removeDisabledNotices(${result.noticeList.length}) having ${JSON.stringify(checkingOptions)}`);
              result.noticeList = (0, _disabledNotices.removeDisabledNotices)(result.noticeList);}addSuccessMessage("Checked all ".concat(lines.length.toLocaleString(), " line").concat(lines.length === 1 ? '' : 's').concat(ourLocation, "."));if (result.noticeList.length) addSuccessMessage("checkMarkdownText v".concat(MARKDOWN_TEXT_VALIDATOR_VERSION_STRING, " finished with ").concat(result.noticeList.length ? result.noticeList.length.toLocaleString() : "zero", " notice").concat(result.noticeList.length === 1 ? '' : 's'));else addSuccessMessage("No errors or warnings found by checkMarkdownText v".concat(MARKDOWN_TEXT_VALIDATOR_VERSION_STRING)); // debugLog(`  checkMarkdownText returning with ${result.successList.length.toLocaleString()} success(es), ${result.noticeList.length.toLocaleString()} notice(s).`);
            return _context3.abrupt("return", result);case 86:case "end":return _context3.stop();}}}, _callee3);}));return _checkMarkdownText.apply(this, arguments);}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9jb3JlL21hcmtkb3duLXRleHQtY2hlY2suanMiXSwibmFtZXMiOlsiTUFSS0RPV05fVEVYVF9WQUxJREFUT1JfVkVSU0lPTl9TVFJJTkciLCJjaGVja01hcmtkb3duVGV4dCIsImxhbmd1YWdlQ29kZSIsInJlcG9Db2RlIiwidGV4dE9yRmlsZU5hbWUiLCJtYXJrZG93blRleHQiLCJnaXZlbkxvY2F0aW9uIiwiY2hlY2tpbmdPcHRpb25zIiwiYWRkU3VjY2Vzc01lc3NhZ2UiLCJhZGROb3RpY2UiLCJvdXJDaGVja1RleHRGaWVsZCIsIm91ckNoZWNrTm90ZXNMaW5rc1RvT3V0c2lkZSIsImNoZWNrTWFya2Rvd25MaW5lQ29udGVudHMiLCJsaW5lTnVtYmVyIiwibGluZVRleHQiLCJsaW5lTG9jYXRpb24iLCJpbmRleE9mIiwidGhpc1RleHQiLCJyZXBsYWNlIiwic3RhcnRzV2l0aCIsInN1Z2dlc3Rpb24iLCJsb2NhdGlvbiIsImFkanVzdGVkVGV4dE9yRmlsZU5hbWUiLCJzdWJzdHJpbmciLCJsZW5ndGgiLCJhZGp1c3RlZExhbmd1YWdlQ29kZSIsImRlZmF1bHRMYW5ndWFnZUNvZGUiLCJjb1RObFJlc3VsdE9iamVjdCIsIm5vdGljZUxpc3QiLCJjb3FOb3RpY2VFbnRyeSIsImV4dHJhIiwicmVzdWx0IiwicHVzaCIsImNoZWNrZWRGaWxlQ291bnQiLCJjaGVja2VkRmlsZXNpemVzIiwiY2hlY2tlZFJlcG9OYW1lcyIsImNoZWNrZWRSZXBvTmFtZSIsImNoZWNrZWRGaWxlbmFtZUV4dGVuc2lvbnMiLCJjaGVja2VkRmlsZW5hbWVFeHRlbnNpb24iLCJmaWVsZE5hbWUiLCJmaWVsZFRleHQiLCJhbGxvd2VkTGlua3MiLCJvcHRpb25hbEZpZWxkTG9jYXRpb24iLCJkYnRjUmVzdWx0T2JqZWN0Iiwibm90aWNlRW50cnkiLCJub3RpY2VPYmplY3QiLCJjaGFyYWN0ZXJJbmRleCIsImV4Y2VycHQiLCJzdWNjZXNzU3RyaW5nIiwic3VjY2Vzc0xpc3QiLCJ0b0xvd2VyQ2FzZSIsImNvbnNvbGUiLCJ0cmFjZSIsInVuZGVmaW5lZCIsIm91ckxvY2F0aW9uIiwiZXhjZXJwdExlbmd0aCIsIm1kdGNFcnJvciIsImlzTmFOIiwiREVGQVVMVF9FWENFUlBUX0xFTkdUSCIsImV4Y2VycHRIYWxmTGVuZ3RoIiwiTWF0aCIsImZsb29yIiwiZXhjZXJwdEhhbGZMZW5ndGhQbHVzIiwibGluZXMiLCJzcGxpdCIsImhlYWRlckxldmVsIiwiaW5kZW50TGV2ZWxzIiwic3VnZ2VzdGVkTGluZXMiLCJub3RpZmllZEJsYW5rTGluZXMiLCJuIiwibGluZSIsIm5leHRMaW5lIiwibGFzdExpbmUiLCJub3RpY2UiLCJwcmlvcml0eSIsIm1lc3NhZ2UiLCJkZXRhaWxzIiwibnVtTGVhZGluZ1NwYWNlcyIsInRoaXNIZWFkZXJMZXZlbCIsIm1hdGNoIiwicHJldmlvdXNJbmRlbnRMZXZlbCIsInBvcCIsImZvdW5kUHJldmlvdXNMZXZlbCIsInoiLCJKU09OIiwic3RyaW5naWZ5Iiwic3VnZ2VzdGVkTGluZSIsInRoaXNTZXQiLCJ0aGlzRmllbGQiLCJ0aGlzUmVnZXgiLCJjb3VudCIsIml5IiwidG9Mb2NhbGVTdHJpbmciLCJqb2luIiwic3VwcHJlc3NOb3RpY2VEaXNhYmxpbmdGbGFnIl0sIm1hcHBpbmdzIjoiO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLHdDOzs7QUFHQSxJQUFNQSxzQ0FBc0MsR0FBRyxPQUEvQzs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEc7QUFDc0JDLGlCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7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Q2IsZUFBRCxhQUFDQSxlQUFELGVBQUNBLGVBQWUsQ0FBRXVGLDJCQUFsQixDQUFKLEVBQW1ELENBQy9DO0FBQ0EvRCxjQUFBQSxNQUFNLENBQUNILFVBQVAsR0FBb0IsNENBQXNCRyxNQUFNLENBQUNILFVBQTdCLENBQXBCLENBQ0gsQ0FFRHBCLGlCQUFpQix1QkFBZ0J1RCxLQUFLLENBQUN2QyxNQUFOLENBQWFvRSxjQUFiLEVBQWhCLGtCQUFxRDdCLEtBQUssQ0FBQ3ZDLE1BQU4sS0FBaUIsQ0FBakIsR0FBcUIsRUFBckIsR0FBMEIsR0FBL0UsU0FBcUY4QixXQUFyRixPQUFqQixDQUNBLElBQUl2QixNQUFNLENBQUNILFVBQVAsQ0FBa0JKLE1BQXRCLEVBQ0loQixpQkFBaUIsOEJBQXVCUixzQ0FBdkIsNEJBQStFK0IsTUFBTSxDQUFDSCxVQUFQLENBQWtCSixNQUFsQixHQUEyQk8sTUFBTSxDQUFDSCxVQUFQLENBQWtCSixNQUFsQixDQUF5Qm9FLGNBQXpCLEVBQTNCLEdBQXVFLE1BQXRKLG9CQUFzSzdELE1BQU0sQ0FBQ0gsVUFBUCxDQUFrQkosTUFBbEIsS0FBNkIsQ0FBN0IsR0FBaUMsRUFBakMsR0FBc0MsR0FBNU0sRUFBakIsQ0FESixLQUdJaEIsaUJBQWlCLDZEQUFzRFIsc0NBQXRELEVBQWpCLENBcFlELENBcVlIO0FBcllHLDhDQXNZSStCLE1BdFlKLDZEIiwic291cmNlc0NvbnRlbnQiOlsiLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC12YXJzXG5pbXBvcnQgeyBERUZBVUxUX0VYQ0VSUFRfTEVOR1RILCBSRVBPX0NPREVTX0xJU1QgfSBmcm9tICcuL2RlZmF1bHRzJ1xuaW1wb3J0IHsgY2hlY2tUZXh0RmllbGQgfSBmcm9tICcuL2ZpZWxkLXRleHQtY2hlY2snO1xuaW1wb3J0IHsgY2hlY2tOb3Rlc0xpbmtzVG9PdXRzaWRlIH0gZnJvbSAnLi9ub3Rlcy1saW5rcy1jaGVjayc7XG4vLyBpbXBvcnQgeyBjYWNoZWRHZXRGaWxlVXNpbmdGdWxsVVJMIH0gZnJvbSAnLi4vY29yZS9nZXRBcGknO1xuaW1wb3J0IHsgcmVtb3ZlRGlzYWJsZWROb3RpY2VzIH0gZnJvbSAnLi9kaXNhYmxlZC1ub3RpY2VzJztcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtdmFyc1xuaW1wb3J0IHsgcGFyYW1ldGVyQXNzZXJ0LCBkYXRhQXNzZXJ0LCBkZWJ1Z0xvZyB9IGZyb20gJy4vdXRpbGl0aWVzJztcblxuXG5jb25zdCBNQVJLRE9XTl9URVhUX1ZBTElEQVRPUl9WRVJTSU9OX1NUUklORyA9ICcwLjcuMyc7XG5cblxuLyoqXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGxhbmd1YWdlQ29kZSwgZS5nLiwgJ2VuJ1xuICogQHBhcmFtIHtzdHJpbmd9IHJlcG9Db2RlIC0tIGUuZy4sICdUTicgb3IgJ1RRMicsIGV0Yy5cbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0T3JGaWxlTmFtZSAtLSB1c2VkIGZvciBpZGVudGlmaWNhdGlvblxuICogQHBhcmFtIHtzdHJpbmd9IG1hcmtkb3duVGV4dCAtLSB0aGUgYWN0dWFsIHRleHQgdG8gYmUgY2hlY2tlZFxuICogQHBhcmFtIHtzdHJpbmd9IGdpdmVuTG9jYXRpb25cbiAqIEBwYXJhbSB7T2JqZWN0fSBjaGVja2luZ09wdGlvbnNcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGNoZWNrTWFya2Rvd25UZXh0KGxhbmd1YWdlQ29kZSwgcmVwb0NvZGUsIHRleHRPckZpbGVOYW1lLCBtYXJrZG93blRleHQsIGdpdmVuTG9jYXRpb24sIGNoZWNraW5nT3B0aW9ucykge1xuICAgIC8qIFRoaXMgZnVuY3Rpb24gaXMgb3B0aW1pc2VkIGZvciBjaGVja2luZyB0aGUgZW50aXJlIG1hcmtkb3duIHRleHQsIGkuZS4sIGFsbCBsaW5lcy5cblxuICAgIFRoaXMgdGV4dCBtYXkgbm90IG5lY2Vzc2FyaWx5IGJlIGZyb20gYSBmaWxlIC0tIGl0IG1heSBiZSBmcm9tIGEgKG11bHRpbGluZSkgZmllbGQgd2l0aGluIGEgZmlsZVxuXG4gICAgIFJldHVybnMgYSByZXN1bHQgb2JqZWN0IGNvbnRhaW5pbmcgYSBzdWNjZXNzTGlzdCBhbmQgYSBub3RpY2VMaXN0XG4gICAgICovXG4gICAgLy8gZnVuY3Rpb25Mb2coYGNoZWNrTWFya2Rvd25UZXh0KCR7bGFuZ3VhZ2VDb2RlfSwgJHtyZXBvQ29kZX0sICR7dGV4dE9yRmlsZU5hbWV9LCAke21hcmtkb3duVGV4dC5sZW5ndGh9LCAke2dpdmVuTG9jYXRpb259LCDigKYp4oCmYCk7XG4gICAgLy9wYXJhbWV0ZXJBc3NlcnQobGFuZ3VhZ2VDb2RlICE9PSB1bmRlZmluZWQsIFwiY2hlY2tNYXJrZG93blRleHQ6ICdsYW5ndWFnZUNvZGUnIHBhcmFtZXRlciBzaG91bGQgYmUgZGVmaW5lZFwiKTtcbiAgICAvL3BhcmFtZXRlckFzc2VydCh0eXBlb2YgbGFuZ3VhZ2VDb2RlID09PSAnc3RyaW5nJywgYGNoZWNrTWFya2Rvd25UZXh0OiAnbGFuZ3VhZ2VDb2RlJyBwYXJhbWV0ZXIgc2hvdWxkIGJlIGEgc3RyaW5nIG5vdCBhICcke3R5cGVvZiBsYW5ndWFnZUNvZGV9JzogJHtsYW5ndWFnZUNvZGV9YCk7XG4gICAgLy9wYXJhbWV0ZXJBc3NlcnQobGFuZ3VhZ2VDb2RlICE9PSAndW5mb2xkaW5nV29yZCcsIGBjaGVja01hcmtkb3duVGV4dDogJ2xhbmd1YWdlQ29kZScgJHtsYW5ndWFnZUNvZGV9IHBhcmFtZXRlciBzaG91bGQgYmUgbm90IGJlICd1bmZvbGRpbmdXb3JkJ2ApO1xuICAgIC8vcGFyYW1ldGVyQXNzZXJ0KHJlcG9Db2RlICE9PSB1bmRlZmluZWQsIFwiY2hlY2tNYXJrZG93blRleHQ6ICdyZXBvQ29kZScgcGFyYW1ldGVyIHNob3VsZCBiZSBkZWZpbmVkXCIpO1xuICAgIC8vcGFyYW1ldGVyQXNzZXJ0KHR5cGVvZiByZXBvQ29kZSA9PT0gJ3N0cmluZycsIGBjaGVja01hcmtkb3duVGV4dDogJ3JlcG9Db2RlJyBwYXJhbWV0ZXIgc2hvdWxkIGJlIGEgc3RyaW5nIG5vdCBhICcke3R5cGVvZiByZXBvQ29kZX0nOiAke3JlcG9Db2RlfWApO1xuICAgIC8vcGFyYW1ldGVyQXNzZXJ0KFJFUE9fQ09ERVNfTElTVC5pbmNsdWRlcyhyZXBvQ29kZSksIGBjaGVja01hcmtkb3duVGV4dDogJ3JlcG9Db2RlJyBwYXJhbWV0ZXIgc2hvdWxkIG5vdCBiZSAnJHtyZXBvQ29kZX0nYCk7XG4gICAgLy9wYXJhbWV0ZXJBc3NlcnQodGV4dE9yRmlsZU5hbWUgIT09IHVuZGVmaW5lZCwgXCJjaGVja01hcmtkb3duVGV4dDogJ3RleHRPckZpbGVOYW1lJyBwYXJhbWV0ZXIgc2hvdWxkIGJlIGRlZmluZWRcIik7XG4gICAgLy9wYXJhbWV0ZXJBc3NlcnQodHlwZW9mIHRleHRPckZpbGVOYW1lID09PSAnc3RyaW5nJywgYGNoZWNrTWFya2Rvd25UZXh0OiAndGV4dE9yRmlsZU5hbWUnIHBhcmFtZXRlciBzaG91bGQgYmUgYSBzdHJpbmcgbm90IGEgJyR7dHlwZW9mIHRleHRPckZpbGVOYW1lfSc6ICR7dGV4dE9yRmlsZU5hbWV9YCk7XG4gICAgLy9wYXJhbWV0ZXJBc3NlcnQodGV4dE9yRmlsZU5hbWUgIT09IGAke2xhbmd1YWdlQ29kZX1fJHtyZXBvQ29kZS50b0xvd2VyQ2FzZSgpfWAsIGBjaGVja01hcmtkb3duVGV4dDogJ3RleHRPckZpbGVOYW1lJyBwYXJhbWV0ZXIgc2hvdWxkIG5vdCBiZSB0aGUgcmVwb05hbWU6ICcke3RleHRPckZpbGVOYW1lfSdgKTtcbiAgICBpZiAodGV4dE9yRmlsZU5hbWUgPT09IGAke2xhbmd1YWdlQ29kZX1fJHtyZXBvQ29kZS50b0xvd2VyQ2FzZSgpfWApIHsgY29uc29sZS50cmFjZSgnY2hlY2tNYXJrZG93blRleHQoKScpOyB9XG4gICAgLy9wYXJhbWV0ZXJBc3NlcnQobWFya2Rvd25UZXh0ICE9PSB1bmRlZmluZWQsIFwiY2hlY2tNYXJrZG93blRleHQ6ICdtYXJrZG93blRleHQnIHBhcmFtZXRlciBzaG91bGQgYmUgZGVmaW5lZFwiKTtcbiAgICAvL3BhcmFtZXRlckFzc2VydCh0eXBlb2YgbWFya2Rvd25UZXh0ID09PSAnc3RyaW5nJywgYGNoZWNrTWFya2Rvd25UZXh0OiAnbWFya2Rvd25UZXh0JyBwYXJhbWV0ZXIgc2hvdWxkIGJlIGEgc3RyaW5nIG5vdCBhICcke3R5cGVvZiBtYXJrZG93blRleHR9JzogJHttYXJrZG93blRleHR9YCk7XG4gICAgLy9wYXJhbWV0ZXJBc3NlcnQoZ2l2ZW5Mb2NhdGlvbiAhPT0gdW5kZWZpbmVkLCBcImNoZWNrTWFya2Rvd25UZXh0OiAnb3B0aW9uYWxGaWVsZExvY2F0aW9uJyBwYXJhbWV0ZXIgc2hvdWxkIGJlIGRlZmluZWRcIik7XG4gICAgLy9wYXJhbWV0ZXJBc3NlcnQodHlwZW9mIGdpdmVuTG9jYXRpb24gPT09ICdzdHJpbmcnLCBgY2hlY2tNYXJrZG93blRleHQ6ICdvcHRpb25hbEZpZWxkTG9jYXRpb24nIHBhcmFtZXRlciBzaG91bGQgYmUgYSBzdHJpbmcgbm90IGEgJyR7dHlwZW9mIGdpdmVuTG9jYXRpb259JzogJHtnaXZlbkxvY2F0aW9ufWApO1xuICAgIC8vcGFyYW1ldGVyQXNzZXJ0KGdpdmVuTG9jYXRpb24uaW5kZXhPZigndHJ1ZScpID09PSAtMSwgYGNoZWNrTWFya2Rvd25UZXh0OiAnb3B0aW9uYWxGaWVsZExvY2F0aW9uJyBwYXJhbWV0ZXIgc2hvdWxkIG5vdCBiZSAnJHtnaXZlbkxvY2F0aW9ufSdgKTtcbiAgICAvL3BhcmFtZXRlckFzc2VydChjaGVja2luZ09wdGlvbnMgIT09IHVuZGVmaW5lZCwgXCJjaGVja01hcmtkb3duVGV4dDogJ2NoZWNraW5nT3B0aW9ucycgcGFyYW1ldGVyIHNob3VsZCBiZSBkZWZpbmVkXCIpO1xuICAgIGlmIChjaGVja2luZ09wdGlvbnMgIT09IHVuZGVmaW5lZCkgeyAvL3BhcmFtZXRlckFzc2VydCh0eXBlb2YgY2hlY2tpbmdPcHRpb25zID09PSAnb2JqZWN0JywgYGNoZWNrTWFya2Rvd25UZXh0OiAnY2hlY2tpbmdPcHRpb25zJyBwYXJhbWV0ZXIgc2hvdWxkIGJlIGFuIG9iamVjdCBub3QgYSAnJHt0eXBlb2YgY2hlY2tpbmdPcHRpb25zfSc6ICR7SlNPTi5zdHJpbmdpZnkoY2hlY2tpbmdPcHRpb25zKX1gKTtcbiAgICB9XG5cbiAgICBsZXQgb3VyTG9jYXRpb24gPSBnaXZlbkxvY2F0aW9uO1xuICAgIGlmIChvdXJMb2NhdGlvbiAmJiBvdXJMb2NhdGlvblswXSAhPT0gJyAnKSBvdXJMb2NhdGlvbiA9IGAgJHtvdXJMb2NhdGlvbn1gO1xuXG4gICAgbGV0IGV4Y2VycHRMZW5ndGg7XG4gICAgdHJ5IHtcbiAgICAgICAgZXhjZXJwdExlbmd0aCA9IGNoZWNraW5nT3B0aW9ucz8uZXhjZXJwdExlbmd0aDtcbiAgICB9IGNhdGNoIChtZHRjRXJyb3IpIHsgfVxuICAgIGlmICh0eXBlb2YgZXhjZXJwdExlbmd0aCAhPT0gJ251bWJlcicgfHwgaXNOYU4oZXhjZXJwdExlbmd0aCkpIHtcbiAgICAgICAgZXhjZXJwdExlbmd0aCA9IERFRkFVTFRfRVhDRVJQVF9MRU5HVEg7XG4gICAgICAgIC8vIGRlYnVnTG9nKFwiVXNpbmcgZGVmYXVsdCBleGNlcnB0TGVuZ3RoPVwiICsgZXhjZXJwdExlbmd0aCk7XG4gICAgfVxuICAgIC8vIGVsc2VcbiAgICAvLyBkZWJ1Z0xvZyhcIlVzaW5nIHN1cHBsaWVkIGV4Y2VycHRMZW5ndGg9XCIgKyBleGNlcnB0TGVuZ3RoLCBgY2YuIGRlZmF1bHQ9JHtERUZBVUxUX0VYQ0VSUFRfTEVOR1RIfWApO1xuICAgIGNvbnN0IGV4Y2VycHRIYWxmTGVuZ3RoID0gTWF0aC5mbG9vcihleGNlcnB0TGVuZ3RoIC8gMik7IC8vIHJvdW5kZWQgZG93blxuICAgIGNvbnN0IGV4Y2VycHRIYWxmTGVuZ3RoUGx1cyA9IE1hdGguZmxvb3IoKGV4Y2VycHRMZW5ndGggKyAxKSAvIDIpOyAvLyByb3VuZGVkIHVwXG4gICAgLy8gZGVidWdMb2coXCJVc2luZyBleGNlcnB0SGFsZkxlbmd0aD1cIiArIGV4Y2VycHRIYWxmTGVuZ3RoLCBgZXhjZXJwdEhhbGZMZW5ndGhQbHVzPSR7ZXhjZXJwdEhhbGZMZW5ndGhQbHVzfWApO1xuXG4gICAgY29uc3QgcmVzdWx0ID0geyBzdWNjZXNzTGlzdDogW10sIG5vdGljZUxpc3Q6IFtdIH07XG5cbiAgICBmdW5jdGlvbiBhZGRTdWNjZXNzTWVzc2FnZShzdWNjZXNzU3RyaW5nKSB7XG4gICAgICAgIC8vIGRlYnVnTG9nKFwiY2hlY2tNYXJrZG93blRleHQgc3VjY2VzczogXCIgKyBzdWNjZXNzU3RyaW5nKTtcbiAgICAgICAgcmVzdWx0LnN1Y2Nlc3NMaXN0LnB1c2goc3VjY2Vzc1N0cmluZyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGFkZE5vdGljZShub3RpY2VPYmplY3QpIHtcbiAgICAgICAgLy8gZnVuY3Rpb25Mb2coYGNoZWNrTWFya2Rvd25UZXh0IGFkZE5vdGljZTogKHByaW9yaXR5PSR7bm90aWNlT2JqZWN0LnByaW9yaXR5fSkgJHtub3RpY2VPYmplY3QubWVzc2FnZX0ke25vdGljZU9iamVjdC5jaGFyYWN0ZXJJbmRleCA+IDAgPyBgIChhdCBjaGFyYWN0ZXIgJHtub3RpY2VPYmplY3QuY2hhcmFjdGVySW5kZXh9KWAgOiBcIlwifSR7bm90aWNlT2JqZWN0LmV4Y2VycHQgPyBcIiBcIiArIGV4Y2VycHQgOiBcIlwifSR7bm90aWNlT2JqZWN0LmxvY2F0aW9ufWApO1xuICAgICAgICAvL3BhcmFtZXRlckFzc2VydChub3RpY2VPYmplY3QucHJpb3JpdHkgIT09IHVuZGVmaW5lZCwgXCJjTWRUIGFkZE5vdGljZTogJ3ByaW9yaXR5JyBwYXJhbWV0ZXIgc2hvdWxkIGJlIGRlZmluZWRcIik7XG4gICAgICAgIC8vcGFyYW1ldGVyQXNzZXJ0KHR5cGVvZiBub3RpY2VPYmplY3QucHJpb3JpdHkgPT09ICdudW1iZXInLCBgY01kVCBhZGROb3RpY2U6ICdwcmlvcml0eScgcGFyYW1ldGVyIHNob3VsZCBiZSBhIG51bWJlciBub3QgYSAnJHt0eXBlb2Ygbm90aWNlT2JqZWN0LnByaW9yaXR5fSc6ICR7bm90aWNlT2JqZWN0LnByaW9yaXR5fWApO1xuICAgICAgICAvL3BhcmFtZXRlckFzc2VydChub3RpY2VPYmplY3QubWVzc2FnZSAhPT0gdW5kZWZpbmVkLCBcImNNZFQgYWRkTm90aWNlOiAnbWVzc2FnZScgcGFyYW1ldGVyIHNob3VsZCBiZSBkZWZpbmVkXCIpO1xuICAgICAgICAvL3BhcmFtZXRlckFzc2VydCh0eXBlb2Ygbm90aWNlT2JqZWN0Lm1lc3NhZ2UgPT09ICdzdHJpbmcnLCBgY01kVCBhZGROb3RpY2U6ICdtZXNzYWdlJyBwYXJhbWV0ZXIgc2hvdWxkIGJlIGEgc3RyaW5nIG5vdCBhICcke3R5cGVvZiBub3RpY2VPYmplY3QubWVzc2FnZX0nOiAke25vdGljZU9iamVjdC5tZXNzYWdlfWApO1xuICAgICAgICAvLyAvL3BhcmFtZXRlckFzc2VydChjaGFyYWN0ZXJJbmRleCAhPT0gdW5kZWZpbmVkLCBcImNNZFQgYWRkTm90aWNlOiAnY2hhcmFjdGVySW5kZXgnIHBhcmFtZXRlciBzaG91bGQgYmUgZGVmaW5lZFwiKTtcbiAgICAgICAgaWYgKG5vdGljZU9iamVjdC5jaGFyYWN0ZXJJbmRleCkgeyAvL3BhcmFtZXRlckFzc2VydCh0eXBlb2Ygbm90aWNlT2JqZWN0LmNoYXJhY3RlckluZGV4ID09PSAnbnVtYmVyJywgYGNNZFQgYWRkTm90aWNlOiAnY2hhcmFjdGVySW5kZXgnIHBhcmFtZXRlciBzaG91bGQgYmUgYSBudW1iZXIgbm90IGEgJyR7dHlwZW9mIG5vdGljZU9iamVjdC5jaGFyYWN0ZXJJbmRleH0nOiAke25vdGljZU9iamVjdC5jaGFyYWN0ZXJJbmRleH1gKTtcbiAgICAgICAgfVxuICAgICAgICAvLyAvL3BhcmFtZXRlckFzc2VydChleGNlcnB0ICE9PSB1bmRlZmluZWQsIFwiY01kVCBhZGROb3RpY2U6ICdleGNlcnB0JyBwYXJhbWV0ZXIgc2hvdWxkIGJlIGRlZmluZWRcIik7XG4gICAgICAgIGlmIChub3RpY2VPYmplY3QuZXhjZXJwdCkgeyAvL3BhcmFtZXRlckFzc2VydCh0eXBlb2Ygbm90aWNlT2JqZWN0LmV4Y2VycHQgPT09ICdzdHJpbmcnLCBgY01kVCBhZGROb3RpY2U6ICdleGNlcnB0JyBwYXJhbWV0ZXIgc2hvdWxkIGJlIGEgc3RyaW5nIG5vdCBhICcke3R5cGVvZiBub3RpY2VPYmplY3QuZXhjZXJwdH0nOiAke25vdGljZU9iamVjdC5leGNlcnB0fWApO1xuICAgICAgICB9XG4gICAgICAgIC8vcGFyYW1ldGVyQXNzZXJ0KG5vdGljZU9iamVjdC5sb2NhdGlvbiAhPT0gdW5kZWZpbmVkLCBcImNNZFQgYWRkTm90aWNlOiAnbG9jYXRpb24nIHBhcmFtZXRlciBzaG91bGQgYmUgZGVmaW5lZFwiKTtcbiAgICAgICAgLy9wYXJhbWV0ZXJBc3NlcnQodHlwZW9mIG5vdGljZU9iamVjdC5sb2NhdGlvbiA9PT0gJ3N0cmluZycsIGBjTWRUIGFkZE5vdGljZTogJ2xvY2F0aW9uJyBwYXJhbWV0ZXIgc2hvdWxkIGJlIGEgc3RyaW5nIG5vdCBhICcke3R5cGVvZiBub3RpY2VPYmplY3QubG9jYXRpb259JzogJHtub3RpY2VPYmplY3QubG9jYXRpb259YCk7XG5cbiAgICAgICAgLy8gbm90aWNlT2JqZWN0LmRlYnVnQ2hhaW4gPSBub3RpY2VPYmplY3QuZGVidWdDaGFpbiA/IGBjaGVja01hcmtkb3duVGV4dCgke2xhbmd1YWdlQ29kZX0sICR7dGV4dE9yRmlsZU5hbWV9KSAke25vdGljZU9iamVjdC5kZWJ1Z0NoYWlufWAgOiBgY2hlY2tNYXJrZG93blRleHQoJHtsYW5ndWFnZUNvZGV9LCAke3RleHRPckZpbGVOYW1lfSlgO1xuICAgICAgICByZXN1bHQubm90aWNlTGlzdC5wdXNoKG5vdGljZU9iamVjdCk7IC8vIFVzZWQgdG8gaGF2ZSBmaWxlbmFtZTogdGV4dE5hbWUsIGJ1dCB0aGF0IGlzbuKAmXQgYWx3YXlzIGEgZmlsZW5hbWUgISEhXG4gICAgfVxuICAgIC8vIGVuZCBvZiBhZGROb3RpY2UgZnVuY3Rpb25cblxuICAgIGZ1bmN0aW9uIG91ckNoZWNrVGV4dEZpZWxkKGZpZWxkTmFtZSwgbGluZU51bWJlciwgZmllbGRUZXh0LCBhbGxvd2VkTGlua3MsIG9wdGlvbmFsRmllbGRMb2NhdGlvbiwgY2hlY2tpbmdPcHRpb25zKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAqIEBkZXNjcmlwdGlvbiAtIGNoZWNrcyB0aGUgZ2l2ZW4gdGV4dCBmaWVsZCBhbmQgcHJvY2Vzc2VzIHRoZSByZXR1cm5lZCByZXN1bHRzXG4gICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGZpZWxkTmFtZSAtIG5hbWUgb2YgdGhlIGZpZWxkIGJlaW5nIGNoZWNrZWRcbiAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gZmllbGRUZXh0IC0gdGhlIGFjdHVhbCB0ZXh0IG9mIHRoZSBmaWVsZCBiZWluZyBjaGVja2VkXG4gICAgICAgICogQHBhcmFtIHtib29sZWFufSBhbGxvd2VkTGlua3MgLSB0cnVlIGlmIGxpbmtzIGFyZSBhbGxvd2VkIGluIHRoZSBmaWVsZCwgb3RoZXJ3aXNlIGZhbHNlXG4gICAgICAgICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbmFsRmllbGRMb2NhdGlvbiAtIGRlc2NyaXB0aW9uIG9mIHdoZXJlIHRoZSBmaWVsZCBpcyBsb2NhdGVkXG4gICAgICAgICogQHBhcmFtIHtPYmplY3R9IGNoZWNraW5nT3B0aW9ucyAtIHBhcmFtZXRlcnMgdGhhdCBtaWdodCBhZmZlY3QgdGhlIGNoZWNrXG4gICAgICAgICovXG4gICAgICAgIC8vIERvZXMgYmFzaWMgY2hlY2tzIGZvciBzbWFsbCBlcnJvcnMgbGlrZSBsZWFkaW5nL3RyYWlsaW5nIHNwYWNlcywgZXRjLlxuXG4gICAgICAgIC8vIFdlIGFzc3VtZSB0aGF0IGNoZWNraW5nIGZvciBjb21wdWxzb3J5IGZpZWxkcyBpcyBkb25lIGVsc2V3aGVyZVxuXG4gICAgICAgIC8vIFVwZGF0ZXMgdGhlIGdsb2JhbCBsaXN0IG9mIG5vdGljZXNcbiAgICAgICAgLy8gZnVuY3Rpb25Mb2coYGNNZFQgb3VyQ2hlY2tUZXh0RmllbGQoJHtmaWVsZE5hbWV9LCAoJHtmaWVsZFRleHQubGVuZ3RofSksICR7YWxsb3dlZExpbmtzfSwgJHtvcHRpb25hbEZpZWxkTG9jYXRpb259LCDigKYpYCk7XG4gICAgICAgIC8vcGFyYW1ldGVyQXNzZXJ0KGZpZWxkTmFtZSAhPT0gdW5kZWZpbmVkLCBcImNNZFQgb3VyQ2hlY2tUZXh0RmllbGQ6ICdmaWVsZE5hbWUnIHBhcmFtZXRlciBzaG91bGQgYmUgZGVmaW5lZFwiKTtcbiAgICAgICAgLy9wYXJhbWV0ZXJBc3NlcnQodHlwZW9mIGZpZWxkTmFtZSA9PT0gJ3N0cmluZycsIGBjTWRUIG91ckNoZWNrVGV4dEZpZWxkOiAnZmllbGROYW1lJyBwYXJhbWV0ZXIgc2hvdWxkIGJlIGEgc3RyaW5nIG5vdCBhICcke3R5cGVvZiBmaWVsZE5hbWV9J2ApO1xuICAgICAgICAvL3BhcmFtZXRlckFzc2VydChsaW5lTnVtYmVyICE9PSB1bmRlZmluZWQsIFwiY01kVCBvdXJDaGVja1RleHRGaWVsZDogJ2xpbmVOdW1iZXInIHBhcmFtZXRlciBzaG91bGQgYmUgZGVmaW5lZFwiKTtcbiAgICAgICAgLy9wYXJhbWV0ZXJBc3NlcnQodHlwZW9mIGxpbmVOdW1iZXIgPT09ICdudW1iZXInLCBgY01kVCBvdXJDaGVja1RleHRGaWVsZDogJ2xpbmVOdW1iZXInIHBhcmFtZXRlciBzaG91bGQgYmUgYSBudW1iZXIgbm90IGEgJyR7dHlwZW9mIGxpbmVOdW1iZXJ9J2ApO1xuICAgICAgICAvL3BhcmFtZXRlckFzc2VydChmaWVsZFRleHQgIT09IHVuZGVmaW5lZCwgXCJjTWRUIG91ckNoZWNrVGV4dEZpZWxkOiAnZmllbGRUZXh0JyBwYXJhbWV0ZXIgc2hvdWxkIGJlIGRlZmluZWRcIik7XG4gICAgICAgIC8vcGFyYW1ldGVyQXNzZXJ0KHR5cGVvZiBmaWVsZFRleHQgPT09ICdzdHJpbmcnLCBgY01kVCBvdXJDaGVja1RleHRGaWVsZDogJ2ZpZWxkVGV4dCcgcGFyYW1ldGVyIHNob3VsZCBiZSBhIHN0cmluZyBub3QgYSAnJHt0eXBlb2YgZmllbGRUZXh0fSdgKTtcbiAgICAgICAgLy9wYXJhbWV0ZXJBc3NlcnQoYWxsb3dlZExpbmtzID09PSB0cnVlIHx8IGFsbG93ZWRMaW5rcyA9PT0gZmFsc2UsIFwiY01kVCBvdXJDaGVja1RleHRGaWVsZDogYWxsb3dlZExpbmtzIHBhcmFtZXRlciBtdXN0IGJlIGVpdGhlciB0cnVlIG9yIGZhbHNlXCIpO1xuICAgICAgICAvL3BhcmFtZXRlckFzc2VydChvcHRpb25hbEZpZWxkTG9jYXRpb24gIT09IHVuZGVmaW5lZCwgXCJjTWRUIG91ckNoZWNrVGV4dEZpZWxkOiAnb3B0aW9uYWxGaWVsZExvY2F0aW9uJyBwYXJhbWV0ZXIgc2hvdWxkIGJlIGRlZmluZWRcIik7XG4gICAgICAgIC8vcGFyYW1ldGVyQXNzZXJ0KHR5cGVvZiBvcHRpb25hbEZpZWxkTG9jYXRpb24gPT09ICdzdHJpbmcnLCBgY01kVCBvdXJDaGVja1RleHRGaWVsZDogJ29wdGlvbmFsRmllbGRMb2NhdGlvbicgcGFyYW1ldGVyIHNob3VsZCBiZSBhIHN0cmluZyBub3QgYSAnJHt0eXBlb2Ygb3B0aW9uYWxGaWVsZExvY2F0aW9ufSdgKTtcblxuICAgICAgICBjb25zdCBkYnRjUmVzdWx0T2JqZWN0ID0gY2hlY2tUZXh0RmllbGQobGFuZ3VhZ2VDb2RlLCByZXBvQ29kZSwgJ21hcmtkb3duJywgZmllbGROYW1lLCBmaWVsZFRleHQsIGFsbG93ZWRMaW5rcywgb3B0aW9uYWxGaWVsZExvY2F0aW9uLCBjaGVja2luZ09wdGlvbnMpO1xuXG4gICAgICAgIC8vIElmIHdlIG5lZWQgdG8gcHV0IGV2ZXJ5dGhpbmcgdGhyb3VnaCBhZGROb3RpY2UsIGUuZy4sIGZvciBkZWJ1Z2dpbmcgb3IgZmlsdGVyaW5nXG4gICAgICAgIC8vICBwcm9jZXNzIHJlc3VsdHMgbGluZSBieSBsaW5lXG4gICAgICAgIGZvciAoY29uc3Qgbm90aWNlRW50cnkgb2YgZGJ0Y1Jlc3VsdE9iamVjdC5ub3RpY2VMaXN0KVxuICAgICAgICAgICAgYWRkTm90aWNlKHsgLi4ubm90aWNlRW50cnksIGxpbmVOdW1iZXIgfSk7XG4gICAgICAgIHJldHVybiBkYnRjUmVzdWx0T2JqZWN0LnN1Z2dlc3Rpb247IC8vIFRoZXJlIG1heSBvciBtYXkgbm90IGJlIG9uZSFcbiAgICB9XG4gICAgLy8gZW5kIG9mIG91ckNoZWNrVGV4dEZpZWxkIGZ1bmN0aW9uXG5cblxuICAgIGFzeW5jIGZ1bmN0aW9uIG91ckNoZWNrTm90ZXNMaW5rc1RvT3V0c2lkZShsaW5lTnVtYmVyLCBsaW5lVGV4dCwgbG9jYXRpb24sIGNoZWNraW5nT3B0aW9ucykge1xuICAgICAgICAvLyBDaGVja3MgdGhhdCB0aGUgVEEvVFcvQmlibGUgcmVmZXJlbmNlIGNhbiBiZSBmb3VuZFxuXG4gICAgICAgIC8vIFVwZGF0ZXMgdGhlIGdsb2JhbCBsaXN0IG9mIG5vdGljZXNcblxuICAgICAgICAvLyBmdW5jdGlvbkxvZyhgY2hlY2tVU0ZNVGV4dCBvdXJDaGVja05vdGVzTGlua3NUb091dHNpZGUoJHtsaW5lTnVtYmVyfSwgJHtDfToke1Z9LCAke21hcmtlcn0sICgke3R3TGlua1RleHQubGVuZ3RofSkgJyR7dHdMaW5rVGV4dH0nLCAke2xvY2F0aW9ufSwgJHtKU09OLnN0cmluZ2lmeShjaGVja2luZ09wdGlvbnMpfSlgKTtcbiAgICAgICAgLy9wYXJhbWV0ZXJBc3NlcnQobGluZU51bWJlciAhPT0gdW5kZWZpbmVkLCBcImNoZWNrVVNGTVRleHQgb3VyQ2hlY2tOb3Rlc0xpbmtzVG9PdXRzaWRlOiAnbGluZU51bWJlcicgcGFyYW1ldGVyIHNob3VsZCBiZSBkZWZpbmVkXCIpO1xuICAgICAgICAvL3BhcmFtZXRlckFzc2VydCh0eXBlb2YgbGluZU51bWJlciA9PT0gJ251bWJlcicsIGBjaGVja1VTRk1UZXh0IG91ckNoZWNrTm90ZXNMaW5rc1RvT3V0c2lkZTogJ2xpbmVOdW1iZXInIHBhcmFtZXRlciBzaG91bGQgYmUgYSBudW1iZXIgbm90IGEgJyR7dHlwZW9mIGxpbmVOdW1iZXJ9JzogJHtsaW5lTnVtYmVyfWApO1xuICAgICAgICAvL3BhcmFtZXRlckFzc2VydChsaW5lVGV4dCAhPT0gdW5kZWZpbmVkLCBcImNoZWNrVVNGTVRleHQgb3VyQ2hlY2tOb3Rlc0xpbmtzVG9PdXRzaWRlOiAnbGluZVRleHQnIHBhcmFtZXRlciBzaG91bGQgYmUgZGVmaW5lZFwiKTtcbiAgICAgICAgLy9wYXJhbWV0ZXJBc3NlcnQodHlwZW9mIGxpbmVUZXh0ID09PSAnc3RyaW5nJywgYGNoZWNrVVNGTVRleHQgb3VyQ2hlY2tOb3Rlc0xpbmtzVG9PdXRzaWRlOiAnbGluZVRleHQnIHBhcmFtZXRlciBzaG91bGQgYmUgYSBzdHJpbmcgbm90IGEgJyR7dHlwZW9mIGxpbmVUZXh0fSc6ICR7bGluZVRleHR9YCk7XG4gICAgICAgIC8vcGFyYW1ldGVyQXNzZXJ0KGxvY2F0aW9uICE9PSB1bmRlZmluZWQsIFwiY2hlY2tVU0ZNVGV4dCBvdXJDaGVja05vdGVzTGlua3NUb091dHNpZGU6ICdsb2NhdGlvbicgcGFyYW1ldGVyIHNob3VsZCBiZSBkZWZpbmVkXCIpO1xuICAgICAgICAvL3BhcmFtZXRlckFzc2VydCh0eXBlb2YgbG9jYXRpb24gPT09ICdzdHJpbmcnLCBgY2hlY2tVU0ZNVGV4dCBvdXJDaGVja05vdGVzTGlua3NUb091dHNpZGU6ICdsb2NhdGlvbicgcGFyYW1ldGVyIHNob3VsZCBiZSBhIHN0cmluZyBub3QgYSAnJHt0eXBlb2YgbG9jYXRpb259JzogJHtsb2NhdGlvbn1gKTtcblxuICAgICAgICAvLyBFbXB0eSBmaWVsZHMgb24gdGhlIG5leHQgbGluZSBhcmUgYm9va0lELCBDLCBWIChhcyB3ZSBkb24ndCBoYXZlIHRoYXQgaW5mb3JtYXRpb24gaGVyZSlcbiAgICAgICAgbGV0IGFkanVzdGVkVGV4dE9yRmlsZU5hbWUgPSB0ZXh0T3JGaWxlTmFtZTtcbiAgICAgICAgaWYgKHRleHRPckZpbGVOYW1lID09PSAnUkVBRE1FLm1kJyB8fCB0ZXh0T3JGaWxlTmFtZSA9PT0gJ0xJQ0VOU0UubWQnKSBhZGp1c3RlZFRleHRPckZpbGVOYW1lID0gdGV4dE9yRmlsZU5hbWUuc3Vic3RyaW5nKDAsIHRleHRPckZpbGVOYW1lLmxlbmd0aCAtIDMpO1xuICAgICAgICBsZXQgYWRqdXN0ZWRMYW5ndWFnZUNvZGUgPSBsYW5ndWFnZUNvZGU7IC8vIFRoaXMgaXMgdGhlIGxhbmd1YWdlIGNvZGUgb2YgdGhlIHJlc291cmNlIHdpdGggdGhlIGxpbmtcbiAgICAgICAgaWYgKGxhbmd1YWdlQ29kZSA9PT0gJ2hibycgfHwgbGFuZ3VhZ2VDb2RlID09PSAnZWwteC1rb2luZScpIGFkanVzdGVkTGFuZ3VhZ2VDb2RlID0gJ2VuJyAvLyBUaGlzIGlzIGEgZ3Vlc3MgKGFuZCB3b24ndCBiZSBuZWVkZWQgZm9yIFRXcyB3aGVuIHdlIHN3aXRjaCB0byBUV0xzKVxuICAgICAgICBjb25zdCBjb1RObFJlc3VsdE9iamVjdCA9IGF3YWl0IGNoZWNrTm90ZXNMaW5rc1RvT3V0c2lkZShsYW5ndWFnZUNvZGUsIHJlcG9Db2RlLCAnJywgJycsICcnLCBhZGp1c3RlZFRleHRPckZpbGVOYW1lLCBsaW5lVGV4dCwgbG9jYXRpb24sIHsgLi4uY2hlY2tpbmdPcHRpb25zLCBkZWZhdWx0TGFuZ3VhZ2VDb2RlOiBhZGp1c3RlZExhbmd1YWdlQ29kZSB9KTtcbiAgICAgICAgLy8gZGVidWdMb2coYGNvVE5sUmVzdWx0T2JqZWN0PSR7SlNPTi5zdHJpbmdpZnkoY29UTmxSZXN1bHRPYmplY3QpfWApO1xuXG4gICAgICAgIC8vIENob29zZSBvbmx5IE9ORSBvZiB0aGUgZm9sbG93aW5nXG4gICAgICAgIC8vIFRoaXMgaXMgdGhlIGZhc3Qgd2F5IG9mIGFwcGVuZCB0aGUgcmVzdWx0cyBmcm9tIHRoaXMgZmllbGRcbiAgICAgICAgLy8gcmVzdWx0Lm5vdGljZUxpc3QgPSByZXN1bHQubm90aWNlTGlzdC5jb25jYXQoY29UTmxSZXN1bHRPYmplY3Qubm90aWNlTGlzdCk7XG4gICAgICAgIC8vIElmIHdlIG5lZWQgdG8gcHV0IGV2ZXJ5dGhpbmcgdGhyb3VnaCBhZGROb3RpY2VQYXJ0aWFsLCBlLmcuLCBmb3IgZGVidWdnaW5nIG9yIGZpbHRlcmluZ1xuICAgICAgICAvLyAgcHJvY2VzcyByZXN1bHRzIGxpbmUgYnkgbGluZVxuICAgICAgICBmb3IgKGNvbnN0IGNvcU5vdGljZUVudHJ5IG9mIGNvVE5sUmVzdWx0T2JqZWN0Lm5vdGljZUxpc3QpIHtcbiAgICAgICAgICAgIGlmIChjb3FOb3RpY2VFbnRyeS5leHRyYSkgLy8gaXQgbXVzdCBiZSBhbiBpbmRpcmVjdCBjaGVjayBvbiBhIFRBIG9yIFRXIGFydGljbGUgZnJvbSBhIFROMiBjaGVja1xuICAgICAgICAgICAgICAgIHJlc3VsdC5ub3RpY2VMaXN0LnB1c2goY29xTm90aWNlRW50cnkpOyAvLyBKdXN0IGNvcHkgdGhlIGNvbXBsZXRlIG5vdGljZSBhcyBpcyAtLSB3b3VsZCBiZSBjb25mdXNpbmcgdG8gaGF2ZSB0aGlzIGxpbmVOdW1iZXJcbiAgICAgICAgICAgIGVsc2UgLy8gRm9yIG91ciBkaXJlY3QgY2hlY2tzLCB3ZSBhZGQgdGhlIHJlcG9Db2RlIGFzIGFuIGV4dHJhIHZhbHVlXG4gICAgICAgICAgICAgICAgYWRkTm90aWNlKHsgLi4uY29xTm90aWNlRW50cnksIGxpbmVOdW1iZXIgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVGhlIGZvbGxvd2luZyBpcyBuZWVkZWQgY296IHdlIG1pZ2h0IGJlIGNoZWNraW5nIHRoZSBsaW5rZWQgVEEgYW5kL29yIFRXIGFydGljbGVzXG4gICAgICAgIGlmIChjb1RObFJlc3VsdE9iamVjdC5jaGVja2VkRmlsZUNvdW50ICYmIGNvVE5sUmVzdWx0T2JqZWN0LmNoZWNrZWRGaWxlQ291bnQgPiAwKVxuICAgICAgICAgICAgaWYgKHR5cGVvZiByZXN1bHQuY2hlY2tlZEZpbGVDb3VudCA9PT0gJ251bWJlcicpIHJlc3VsdC5jaGVja2VkRmlsZUNvdW50ICs9IGNvVE5sUmVzdWx0T2JqZWN0LmNoZWNrZWRGaWxlQ291bnQ7XG4gICAgICAgICAgICBlbHNlIHJlc3VsdC5jaGVja2VkRmlsZUNvdW50ID0gY29UTmxSZXN1bHRPYmplY3QuY2hlY2tlZEZpbGVDb3VudDtcbiAgICAgICAgaWYgKGNvVE5sUmVzdWx0T2JqZWN0LmNoZWNrZWRGaWxlc2l6ZXMgJiYgY29UTmxSZXN1bHRPYmplY3QuY2hlY2tlZEZpbGVzaXplcyA+IDApXG4gICAgICAgICAgICBpZiAodHlwZW9mIHJlc3VsdC5jaGVja2VkRmlsZXNpemVzID09PSAnbnVtYmVyJykgcmVzdWx0LmNoZWNrZWRGaWxlc2l6ZXMgKz0gY29UTmxSZXN1bHRPYmplY3QuY2hlY2tlZEZpbGVzaXplcztcbiAgICAgICAgICAgIGVsc2UgcmVzdWx0LmNoZWNrZWRGaWxlc2l6ZXMgPSBjb1RObFJlc3VsdE9iamVjdC5jaGVja2VkRmlsZXNpemVzO1xuICAgICAgICBpZiAoY29UTmxSZXN1bHRPYmplY3QuY2hlY2tlZFJlcG9OYW1lcyAmJiBjb1RObFJlc3VsdE9iamVjdC5jaGVja2VkUmVwb05hbWVzLmxlbmd0aCA+IDApXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGNoZWNrZWRSZXBvTmFtZSBvZiBjb1RObFJlc3VsdE9iamVjdC5jaGVja2VkUmVwb05hbWVzKVxuICAgICAgICAgICAgICAgIHRyeSB7IGlmIChyZXN1bHQuY2hlY2tlZFJlcG9OYW1lcy5pbmRleE9mKGNoZWNrZWRSZXBvTmFtZSkgPCAwKSByZXN1bHQuY2hlY2tlZFJlcG9OYW1lcy5wdXNoKGNoZWNrZWRSZXBvTmFtZSk7IH1cbiAgICAgICAgICAgICAgICBjYXRjaCB7IHJlc3VsdC5jaGVja2VkUmVwb05hbWVzID0gW2NoZWNrZWRSZXBvTmFtZV07IH1cbiAgICAgICAgaWYgKGNvVE5sUmVzdWx0T2JqZWN0LmNoZWNrZWRGaWxlbmFtZUV4dGVuc2lvbnMgJiYgY29UTmxSZXN1bHRPYmplY3QuY2hlY2tlZEZpbGVuYW1lRXh0ZW5zaW9ucy5sZW5ndGggPiAwKVxuICAgICAgICAgICAgZm9yIChjb25zdCBjaGVja2VkRmlsZW5hbWVFeHRlbnNpb24gb2YgY29UTmxSZXN1bHRPYmplY3QuY2hlY2tlZEZpbGVuYW1lRXh0ZW5zaW9ucylcbiAgICAgICAgICAgICAgICB0cnkgeyBpZiAocmVzdWx0LmNoZWNrZWRGaWxlbmFtZUV4dGVuc2lvbnMuaW5kZXhPZihjaGVja2VkRmlsZW5hbWVFeHRlbnNpb24pIDwgMCkgcmVzdWx0LmNoZWNrZWRGaWxlbmFtZUV4dGVuc2lvbnMucHVzaChjaGVja2VkRmlsZW5hbWVFeHRlbnNpb24pOyB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggeyByZXN1bHQuY2hlY2tlZEZpbGVuYW1lRXh0ZW5zaW9ucyA9IFtjaGVja2VkRmlsZW5hbWVFeHRlbnNpb25dOyB9XG4gICAgICAgIC8vIGlmIChyZXN1bHQuY2hlY2tlZEZpbGVuYW1lRXh0ZW5zaW9ucykgdXNlckxvZyhcInJlc3VsdFwiLCBKU09OLnN0cmluZ2lmeShyZXN1bHQpKTtcbiAgICB9XG4gICAgLy8gZW5kIG9mIG91ckNoZWNrTm90ZXNMaW5rc1RvT3V0c2lkZSBmdW5jdGlvblxuXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBsaW5lTnVtYmVyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGxpbmVUZXh0IC0tIHRleHQgdG8gYmUgY2hlY2tlZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBsaW5lTG9jYXRpb25cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBzdWdnZXN0aW9uIChtYXkgYmUgdW5kZWZpbmVkKSAtLSBzdWdnZXN0ZWQgZml4ZWQgcmVwbGFjZW1lbnQgZmllbGRcbiAgICAgKi9cbiAgICBhc3luYyBmdW5jdGlvbiBjaGVja01hcmtkb3duTGluZUNvbnRlbnRzKGxpbmVOdW1iZXIsIGxpbmVUZXh0LCBsaW5lTG9jYXRpb24pIHtcblxuICAgICAgICAvLyBmdW5jdGlvbkxvZyhgY2hlY2tNYXJrZG93bkxpbmVDb250ZW50cyBmb3IgJHtsaW5lTnVtYmVyfSAnJHtsaW5lVGV4dH0nIGF0JHtsaW5lTG9jYXRpb259YCk7XG5cbiAgICAgICAgLy8gLy8gQ2hlY2sgZm9yIGltYWdlIGxpbmtzXG4gICAgICAgIC8vIGxldCByZWdleFJlc3VsdEFycmF5O1xuICAgICAgICAvLyB3aGlsZSAoKHJlZ2V4UmVzdWx0QXJyYXkgPSBTSU1QTEVfSU1BR0VfUkVHRVguZXhlYyhsaW5lVGV4dCkpKSB7XG4gICAgICAgIC8vICAgICAvLyBkZWJ1Z0xvZyhgR290IG1hcmtkb3duIGltYWdlIGluIGxpbmUgJHtsaW5lTnVtYmVyfTpgLCBKU09OLnN0cmluZ2lmeShyZWdleFJlc3VsdEFycmF5KSk7XG4gICAgICAgIC8vICAgICBjb25zdCBbdG90YWxMaW5rLCBhbHRUZXh0LCBmZXRjaExpbmtdID0gcmVnZXhSZXN1bHRBcnJheTtcbiAgICAgICAgLy8gICAgIC8vIGlmIChhbHRUZXh0ICE9PSAnT0JTIEltYWdlJykgdXNlckxvZyhcIlRoaXMgY29kZSB3YXMgb25seSBjaGVja2VkIGZvciAnT0JTIEltYWdlJyBsaW5rc1wiKTtcbiAgICAgICAgLy8gICAgIGlmICghYWx0VGV4dClcbiAgICAgICAgLy8gICAgICAgICBhZGROb3RpY2UoeyBwcmlvcml0eTogMTk5LCBtZXNzYWdlOiBcIk1hcmtkb3duIGltYWdlIGxpbmsgaGFzIG5vIGFsdGVybmF0aXZlIHRleHRcIiwgbGluZU51bWJlciwgZXhjZXJwdDogdG90YWxMaW5rLCBsb2NhdGlvbjogbGluZUxvY2F0aW9uIH0pO1xuICAgICAgICAvLyAgICAgaWYgKCFmZXRjaExpbmsuc3RhcnRzV2l0aCgnaHR0cHM6Ly8nKSlcbiAgICAgICAgLy8gICAgICAgICBhZGROb3RpY2UoeyBwcmlvcml0eTogNzQ5LCBtZXNzYWdlOiBcIk1hcmtkb3duIGltYWdlIGxpbmsgc2VlbXMgZmF1bHR5XCIsIGxpbmVOdW1iZXIsIGV4Y2VycHQ6IGZldGNoTGluaywgbG9jYXRpb246IGxpbmVMb2NhdGlvbiB9KTtcbiAgICAgICAgLy8gICAgIGVsc2UgaWYgKGNoZWNraW5nT3B0aW9ucz8uZGlzYWJsZUFsbExpbmtGZXRjaGluZ0ZsYWcgIT09IHRydWUpIHtcbiAgICAgICAgLy8gICAgICAgICAvLyBkZWJ1Z0xvZyhgTmVlZCB0byBjaGVjayBleGlzdGVuY2Ugb2YgJHtmZXRjaExpbmt9YCk7XG4gICAgICAgIC8vICAgICAgICAgdHJ5IHtcbiAgICAgICAgLy8gICAgICAgICAgICAgY29uc3QgcmVzcG9uc2VEYXRhID0gYXdhaXQgY2FjaGVkR2V0RmlsZVVzaW5nRnVsbFVSTCh7IHVyaTogZmV0Y2hMaW5rIH0pO1xuICAgICAgICAvLyAgICAgICAgICAgICBkYXRhQXNzZXJ0KHJlc3BvbnNlRGF0YS5sZW5ndGggPiAxMCwgYEV4cGVjdGVkICR7ZmV0Y2hMaW5rfSBpbWFnZSBmaWxlIHRvIGJlIGxvbmdlcjogJHtyZXNwb25zZURhdGEubGVuZ3RofWApO1xuICAgICAgICAvLyAgICAgICAgICAgICAvLyBkZWJ1Z0xvZyhcIk1hcmtkb3duIGxpbmsgZmV0Y2ggZ290IHJlc3BvbnNlOiBcIiwgcmVzcG9uc2VEYXRhLmxlbmd0aCk7XG4gICAgICAgIC8vICAgICAgICAgfSBjYXRjaCAoZmxFcnJvcikge1xuICAgICAgICAvLyAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGBNYXJrZG93biBpbWFnZSBsaW5rIGZldGNoIGhhZCBhbiBlcnJvciBmZXRjaGluZyAnJHtmZXRjaExpbmt9JzogJHtmbEVycm9yfWApO1xuICAgICAgICAvLyAgICAgICAgICAgICBhZGROb3RpY2UoeyBwcmlvcml0eTogNzQ4LCBtZXNzYWdlOiBcIkVycm9yIGZldGNoaW5nIG1hcmtkb3duIGltYWdlIGxpbmtcIiwgbGluZU51bWJlciwgZXhjZXJwdDogZmV0Y2hMaW5rLCBsb2NhdGlvbjogbGluZUxvY2F0aW9uIH0pO1xuICAgICAgICAvLyAgICAgICAgIH1cbiAgICAgICAgLy8gICAgIH1cbiAgICAgICAgLy8gfVxuICAgICAgICAvLyB3aGlsZSAoKHJlZ2V4UmVzdWx0QXJyYXkgPSBUSVRMRURfSU1BR0VfUkVHRVguZXhlYyhsaW5lVGV4dCkpKSB7XG4gICAgICAgIC8vICAgICAvLyBkZWJ1Z0xvZyhgR290IG1hcmtkb3duIGltYWdlIGluIGxpbmUgJHtsaW5lTnVtYmVyfTpgLCBKU09OLnN0cmluZ2lmeShyZWdleFJlc3VsdEFycmF5KSk7XG4gICAgICAgIC8vICAgICBjb25zdCBbdG90YWxMaW5rLCBhbHQsIGZldGNoTGluaywgdGl0bGVdID0gcmVnZXhSZXN1bHRBcnJheTtcbiAgICAgICAgLy8gICAgIGlmICghYWx0KVxuICAgICAgICAvLyAgICAgICAgIGFkZE5vdGljZSh7IHByaW9yaXR5OiAxOTksIG1lc3NhZ2U6IFwiTWFya2Rvd24gaW1hZ2UgbGluayBoYXMgbm8gYWx0ZXJuYXRpdmUgdGV4dFwiLCBsaW5lTnVtYmVyLCBleGNlcnB0OiB0b3RhbExpbmssIGxvY2F0aW9uOiBsaW5lTG9jYXRpb24gfSk7XG4gICAgICAgIC8vICAgICBpZiAoIXRpdGxlKVxuICAgICAgICAvLyAgICAgICAgIGFkZE5vdGljZSh7IHByaW9yaXR5OiAzNDgsIG1lc3NhZ2U6IFwiTWFya2Rvd24gaW1hZ2UgbGluayBoYXMgbm8gdGl0bGUgdGV4dFwiLCBsaW5lTnVtYmVyLCBleGNlcnB0OiB0b3RhbExpbmssIGxvY2F0aW9uOiBsaW5lTG9jYXRpb24gfSk7XG4gICAgICAgIC8vICAgICBpZiAoIWZldGNoTGluay5zdGFydHNXaXRoKCdodHRwczovLycpKVxuICAgICAgICAvLyAgICAgICAgIGFkZE5vdGljZSh7IHByaW9yaXR5OiA3NDksIG1lc3NhZ2U6IFwiTWFya2Rvd24gaW1hZ2UgbGluayBzZWVtcyBmYXVsdHlcIiwgbGluZU51bWJlciwgZXhjZXJwdDogZmV0Y2hMaW5rLCBsb2NhdGlvbjogbGluZUxvY2F0aW9uIH0pO1xuICAgICAgICAvLyAgICAgZWxzZSBpZiAoY2hlY2tpbmdPcHRpb25zPy5kaXNhYmxlQWxsTGlua0ZldGNoaW5nRmxhZyAhPT0gdHJ1ZSkge1xuICAgICAgICAvLyAgICAgICAgIC8vIGRlYnVnTG9nKGBOZWVkIHRvIGNoZWNrIGV4aXN0ZW5jZSBvZiAke2ZldGNoTGlua31gKTtcbiAgICAgICAgLy8gICAgICAgICB0cnkge1xuICAgICAgICAvLyAgICAgICAgICAgICBjb25zdCByZXNwb25zZURhdGEgPSBhd2FpdCBjYWNoZWRHZXRGaWxlVXNpbmdGdWxsVVJMKHsgdXJpOiBmZXRjaExpbmsgfSk7XG4gICAgICAgIC8vICAgICAgICAgICAgIGRhdGFBc3NlcnQocmVzcG9uc2VEYXRhLmxlbmd0aCA+IDEwLCBgRXhwZWN0ZWQgJHtmZXRjaExpbmt9IGltYWdlIGZpbGUgdG8gYmUgbG9uZ2VyOiAke3Jlc3BvbnNlRGF0YS5sZW5ndGh9YCk7XG4gICAgICAgIC8vICAgICAgICAgICAgIC8vIGRlYnVnTG9nKFwiTWFya2Rvd24gbGluayBmZXRjaCBnb3QgcmVzcG9uc2U6IFwiLCByZXNwb25zZURhdGEubGVuZ3RoKTtcbiAgICAgICAgLy8gICAgICAgICB9IGNhdGNoIChmbEVycm9yKSB7XG4gICAgICAgIC8vICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYE1hcmtkb3duIGltYWdlIGxpbmsgZmV0Y2ggaGFkIGFuIGVycm9yIGZldGNoaW5nICcke2ZldGNoTGlua30nOiAke2ZsRXJyb3J9YCk7XG4gICAgICAgIC8vICAgICAgICAgICAgIGFkZE5vdGljZSh7IHByaW9yaXR5OiA3NDgsIG1lc3NhZ2U6IFwiRXJyb3IgZmV0Y2hpbmcgbWFya2Rvd24gaW1hZ2UgbGlua1wiLCBsaW5lTnVtYmVyLCBleGNlcnB0OiBmZXRjaExpbmssIGxvY2F0aW9uOiBsaW5lTG9jYXRpb24gfSk7XG4gICAgICAgIC8vICAgICAgICAgfVxuICAgICAgICAvLyAgICAgfVxuICAgICAgICAvLyB9XG5cbiAgICAgICAgaWYgKGxpbmVUZXh0LmluZGV4T2YoJ1snKSA+PSAwKSAvLyBDaGVjayBmb3IgbWFya2Rvd24gbGlua3MgbGlrZSBbW3h4XV0gb3IgW3h4XSh5eSkgZXRjLlxuICAgICAgICAgICAgYXdhaXQgb3VyQ2hlY2tOb3Rlc0xpbmtzVG9PdXRzaWRlKGxpbmVOdW1iZXIsIGxpbmVUZXh0LCBnaXZlbkxvY2F0aW9uLCBjaGVja2luZ09wdGlvbnMpXG5cbiAgICAgICAgbGV0IHRoaXNUZXh0ID0gbGluZVRleHQ7IC8vIHNvIHdlIGNhbiBhZGp1c3QgaXRcblxuICAgICAgICAvLyBSZW1vdmUgbGVhZGluZyBhbmQgdHJhaWxpbmcgaGFzaCBzaWducyAjXG4gICAgICAgIHRoaXNUZXh0ID0gdGhpc1RleHQucmVwbGFjZSgvXiMrfCMrJC9nLCAnJyk7XG4gICAgICAgIC8vIGRlYnVnTG9nKGBBZnRlciByZW1vdmluZyBoYXNoZXMgaGF2ZSAnJHt0aGlzVGV4dH0nYCk7XG5cbiAgICAgICAgLy8gUmVtb3ZlIGxlYWRpbmcgc3BhY2VzXG4gICAgICAgIHRoaXNUZXh0ID0gdGhpc1RleHQucmVwbGFjZSgvXiArL2csICcnKTtcblxuICAgICAgICAvLyBSZW1vdmUgbGVhZGluZyBibG9jayB0ZXh0IG1hcmtlcnMgPlxuICAgICAgICB3aGlsZSAodGhpc1RleHQuc3RhcnRzV2l0aCgnPicpKVxuICAgICAgICAgICAgdGhpc1RleHQgPSB0aGlzVGV4dC5yZXBsYWNlKC9ePisgKi9nLCAnJyk7XG4gICAgICAgIC8vIGlmICh0aGlzVGV4dC5pbmRleE9mKCc+JykgPj0gMCkgdXNlckxvZyhgQWZ0ZXIgcmVtb3ZpbmcgbGVhZGluZyBibG9jayB0ZXh0IG1hcmtlcnMgZnJvbSAnJHtsaW5lVGV4dH0nIHN0aWxsIGhhdmUgJyR7dGhpc1RleHR9J2ApO1xuXG4gICAgICAgIC8vIFJlbW92ZSBsZWFkaW5nIHNwYWNlcyBhZ2FpblxuICAgICAgICAvLyB0aGlzVGV4dCA9IHRoaXNUZXh0LnJlcGxhY2UoL14gKy9nLCAnJyk7XG4gICAgICAgIC8vIGRlYnVnTG9nKGBBZnRlciByZW1vdmluZyBsZWFkaW5nIHNwYWNlcyBoYXZlICcke3RoaXNUZXh0fSdgKTtcblxuICAgICAgICAvLyAvLyBSZW1vdmUgbGVhZGluZyBhc3Rlcmlza3NcbiAgICAgICAgLy8gdGhpc1RleHQgPSB0aGlzVGV4dC5yZXBsYWNlKC9eXFwqL2csJycpXG4gICAgICAgIC8vIGRlYnVnTG9nKGBBZnRlciByZW1vdmluZyBhc3Rlcmlza3MgaGF2ZSAnJHt0aGlzVGV4dH0nYCk7XG5cbiAgICAgICAgLy8gLy8gUmVtb3ZlIGxlYWRpbmcgc3BhY2VzIGFnYWluIG5vd1xuICAgICAgICAvLyB0aGlzVGV4dCA9IHRoaXNUZXh0LnJlcGxhY2UoL14gKy9nLCcnKVxuICAgICAgICAvLyBkZWJ1Z0xvZyhgQWZ0ZXIgcmVtb3ZpbmcgbW9yZSBsZWFkaW5nIHNwYWNlcyBoYXZlICcke3RoaXNUZXh0fSdgKTtcblxuICAgICAgICBsZXQgc3VnZ2VzdGlvbjtcbiAgICAgICAgaWYgKHRoaXNUZXh0ICYmIGxpbmVUZXh0WzBdICE9PSAnfCcpIC8vIERvZXNu4oCZdCByZWFsbHkgbWFrZSBzZW5zZSB0byBjaGVjayB0YWJsZSBsaW5lIGVudHJpZXNcbiAgICAgICAgICAgIHN1Z2dlc3Rpb24gPSBvdXJDaGVja1RleHRGaWVsZCh0ZXh0T3JGaWxlTmFtZSwgbGluZU51bWJlciwgdGhpc1RleHQsIHRydWUsIGxpbmVMb2NhdGlvbiwgY2hlY2tpbmdPcHRpb25zKTtcblxuICAgICAgICBpZiAodGhpc1RleHQgPT09IGxpbmVUZXh0KSAvLyBpLmUuLCB3ZSBkaWRu4oCZdCBwcmVtb2RpZnkgdGhlIGZpZWxkIGJlaW5nIGNoZWNrZWQgKG90aGVyd2lzZSBzdWdnZXN0aW9uIGNvdWxkIGJlIHdyb25nKVxuICAgICAgICAgICAgcmV0dXJuIHN1Z2dlc3Rpb247XG4gICAgfVxuICAgIC8vIGVuZCBvZiBjaGVja01hcmtkb3duTGluZUNvbnRlbnRzIGZ1bmN0aW9uXG5cblxuICAgIC8vIE1haW4gY29kZSBmb3IgY2hlY2tNYXJrZG93blRleHQgZnVuY3Rpb25cbiAgICBjb25zdCBsaW5lcyA9IG1hcmtkb3duVGV4dC5zcGxpdCgnXFxuJyk7XG4gICAgLy8gZGVidWdMb2coYCAgJyR7bG9jYXRpb259JyBoYXMgJHtsaW5lcy5sZW5ndGgudG9Mb2NhbGVTdHJpbmcoKX0gdG90YWwgbGluZXNgKTtcblxuICAgIGxldCBoZWFkZXJMZXZlbCA9IDA7XG4gICAgbGV0IGxhc3RMaW5lO1xuICAgIGxldCBpbmRlbnRMZXZlbHMgPSBbXTtcbiAgICBjb25zdCBzdWdnZXN0ZWRMaW5lcyA9IFtdO1xuICAgIGxldCBub3RpZmllZEJsYW5rTGluZXMgPSBmYWxzZTtcbiAgICBmb3IgKGxldCBuID0gMTsgbiA8PSBsaW5lcy5sZW5ndGg7IG4rKykge1xuXG4gICAgICAgIGNvbnN0IGxpbmUgPSBsaW5lc1tuIC0gMV07XG4gICAgICAgIGNvbnN0IG5leHRMaW5lID0gKG4gPCBsaW5lcy5sZW5ndGggLSAxKSA/IGxpbmVzW25dIDogdW5kZWZpbmVkO1xuXG4gICAgICAgIC8vIE1hcmtkb3duIGhlYWRlcnMgc2hvdWxkIGJlIHByZWNlZGVkIGFuZCBmb2xsb3dlZCBieSBhIGJsYW5rIGxpbmVcbiAgICAgICAgaWYgKGxpbmUuc3RhcnRzV2l0aCgnIycpKSB7XG4gICAgICAgICAgICBpZiAobiA+IDEgJiYgbGFzdExpbmUubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgbm90aWNlID0geyBwcmlvcml0eTogMjUyLCBtZXNzYWdlOiBcIk1hcmtkb3duIGhlYWRlcnMgc2hvdWxkIGJlIHByZWNlZGVkIGJ5IGEgYmxhbmsgbGluZVwiLCBsaW5lTnVtYmVyOiBuLCBsb2NhdGlvbjogb3VyTG9jYXRpb24gfTtcbiAgICAgICAgICAgICAgICBpZiAodGV4dE9yRmlsZU5hbWUgPT09ICdOb3RlJyB8fCB0ZXh0T3JGaWxlTmFtZSA9PT0gJ09jY3VycmVuY2VOb3RlJylcbiAgICAgICAgICAgICAgICAgICAgbm90aWNlLmRldGFpbHMgPSBgbWFya2Rvd24gbGluZSAke259YDtcbiAgICAgICAgICAgICAgICBhZGROb3RpY2Uobm90aWNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChuZXh0TGluZT8ubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgbm90aWNlID0geyBwcmlvcml0eTogMjUxLCBtZXNzYWdlOiBcIk1hcmtkb3duIGhlYWRlcnMgc2hvdWxkIGJlIGZvbGxvd2VkIGJ5IGEgYmxhbmsgbGluZVwiLCBsaW5lTnVtYmVyOiBuLCBsb2NhdGlvbjogb3VyTG9jYXRpb24gfTtcbiAgICAgICAgICAgICAgICBpZiAodGV4dE9yRmlsZU5hbWUgPT09ICdOb3RlJyB8fCB0ZXh0T3JGaWxlTmFtZSA9PT0gJ09jY3VycmVuY2VOb3RlJylcbiAgICAgICAgICAgICAgICAgICAgbm90aWNlLmRldGFpbHMgPSBgbWFya2Rvd24gbGluZSAke259YDtcbiAgICAgICAgICAgICAgICBhZGROb3RpY2Uobm90aWNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBudW1MZWFkaW5nU3BhY2VzO1xuICAgICAgICBpZiAobGluZSkge1xuICAgICAgICAgICAgY29uc3QgdGhpc0hlYWRlckxldmVsID0gbGluZS5tYXRjaCgvXiMqLylbMF0ubGVuZ3RoO1xuICAgICAgICAgICAgLy8gZGVidWdMb2coYEdvdCB0aGlzSGVhZGVyTGV2ZWw9JHt0aGlzSGVhZGVyTGV2ZWx9IGZvciAke2xpbmV9JHthdFN0cmluZ31gKTtcbiAgICAgICAgICAgIGlmICh0aGlzSGVhZGVyTGV2ZWwgPiBoZWFkZXJMZXZlbCArIDFcbiAgICAgICAgICAgICAgICAmJiAhdGV4dE9yRmlsZU5hbWUuc3RhcnRzV2l0aCgnVEEgJykpIHsgLy8gU3VwcHJlc3MgdGhpcyBub3RpY2UgZm9yIHRyYW5zbGF0aW9uQWNhZGVteSBzdWJzZWN0aW9uc1xuICAgICAgICAgICAgICAgIGNvbnN0IG5vdGljZSA9IHsgcHJpb3JpdHk6IDE3MiwgbWVzc2FnZTogXCJIZWFkZXIgbGV2ZWxzIHNob3VsZCBvbmx5IGluY3JlbWVudCBieSBvbmVcIiwgbGluZU51bWJlcjogbiwgY2hhcmFjdGVySW5kZXg6IDAsIGxvY2F0aW9uOiBvdXJMb2NhdGlvbiB9O1xuICAgICAgICAgICAgICAgIGlmICh0ZXh0T3JGaWxlTmFtZSA9PT0gJ05vdGUnIHx8IHRleHRPckZpbGVOYW1lID09PSAnT2NjdXJyZW5jZU5vdGUnKVxuICAgICAgICAgICAgICAgICAgICBub3RpY2UuZGV0YWlscyA9IGBtYXJrZG93biBsaW5lICR7bn1gO1xuICAgICAgICAgICAgICAgIGFkZE5vdGljZShub3RpY2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXNIZWFkZXJMZXZlbCA+IDApIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJMZXZlbCA9IHRoaXNIZWFkZXJMZXZlbDtcbiAgICAgICAgICAgICAgICBpbmRlbnRMZXZlbHMgPSBbXTsgLy8gcmVzZXRcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbnVtTGVhZGluZ1NwYWNlcyA9IGxpbmUubWF0Y2goL14gKi8pWzBdLmxlbmd0aDtcbiAgICAgICAgICAgIC8vIGRlYnVnTG9nKGBHb3QgbnVtTGVhZGluZ1NwYWNlcz0ke251bUxlYWRpbmdTcGFjZXN9IHdpdGggaW5kZW50TGV2ZWxzPSR7SlNPTi5zdHJpbmdpZnkoaW5kZW50TGV2ZWxzKX0gZm9yICR7bGluZX0ke291ckxvY2F0aW9ufWApO1xuICAgICAgICAgICAgY29uc3QgcHJldmlvdXNJbmRlbnRMZXZlbCA9IChpbmRlbnRMZXZlbHMubGVuZ3RoID4gMCkgPyBpbmRlbnRMZXZlbHNbaW5kZW50TGV2ZWxzLmxlbmd0aCAtIDFdIDogMDtcbiAgICAgICAgICAgIGlmICgobnVtTGVhZGluZ1NwYWNlcyA+IHByZXZpb3VzSW5kZW50TGV2ZWwpIC8vIFdlIGhhdmUgYW4gaW5kZW50IGxldmVsIGluY3JlYXNlXG4gICAgICAgICAgICAgICAgfHwgKG51bUxlYWRpbmdTcGFjZXMgPT09IDAgJiYgbGluZS5sZW5ndGggPiAwICYmIGluZGVudExldmVscy5sZW5ndGggPT09IDApKSAvLyB3ZSBoYXZlIG91ciBmaXJzdCB6ZXJvLWxldmVsIGluZGVudFxuICAgICAgICAgICAgICAgIGluZGVudExldmVscy5wdXNoKG51bUxlYWRpbmdTcGFjZXMpO1xuICAgICAgICAgICAgZWxzZSBpZiAobnVtTGVhZGluZ1NwYWNlcyA8IHByZXZpb3VzSW5kZW50TGV2ZWwpIHsgLy8gV2UgaGF2ZSBhbiBpbmRlbnQgbGV2ZWwgZGVjcmVhc2VcbiAgICAgICAgICAgICAgICBpZiAoaW5kZW50TGV2ZWxzLmxlbmd0aCA+IDEgJiYgaW5kZW50TGV2ZWxzW2luZGVudExldmVscy5sZW5ndGggLSAyXSA9PT0gbnVtTGVhZGluZ1NwYWNlcylcbiAgICAgICAgICAgICAgICAgICAgLy8gV2Ugd2VudCBiYWNrIHRvIHRoZSBwcmV2aW91cyBsZXZlbFxuICAgICAgICAgICAgICAgICAgICBpbmRlbnRMZXZlbHMucG9wKCk7XG4gICAgICAgICAgICAgICAgZWxzZSB7IC8vIHNlZW1zIHdlIGRpZG4ndCBnbyBiYWNrIHRvIHRoZSBwcmV2aW91cyBsZXZlbCA/Pz9cbiAgICAgICAgICAgICAgICAgICAgbGV0IGZvdW5kUHJldmlvdXNMZXZlbCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCB6ID0gaW5kZW50TGV2ZWxzLmxlbmd0aCAtIDE7IHogPj0gMDsgei0tKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5kZW50TGV2ZWxzW3pdID09PSBudW1MZWFkaW5nU3BhY2VzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZGVidWdMb2coYEFmdGVyIGZpbmRpbmcgJHtudW1MZWFkaW5nU3BhY2VzfSBzcGFjZXMsIHJlZHVjaW5nIGxlbmd0aCBvZiAke0pTT04uc3RyaW5naWZ5KGluZGVudExldmVscyl9IHRvICR7eisxfWApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGVudExldmVscy5sZW5ndGggPSB6ICsgMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3VuZFByZXZpb3VzTGV2ZWwgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICghZm91bmRQcmV2aW91c0xldmVsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBub3RpY2UgPSB7IHByaW9yaXR5OiAyODIsIG1lc3NhZ2U6IFwiTmVzdGluZyBvZiBoZWFkZXIgbGV2ZWxzIHNlZW1zIGNvbmZ1c2VkXCIsIGRldGFpbHM6IGByZWNlbnQgaW5kZW50IGxldmVscz0ke0pTT04uc3RyaW5naWZ5KGluZGVudExldmVscyl9IGJ1dCBub3cgJHtudW1MZWFkaW5nU3BhY2VzfWAsIGxpbmVOdW1iZXI6IG4sIGNoYXJhY3RlckluZGV4OiAwLCBsb2NhdGlvbjogb3VyTG9jYXRpb24gfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0ZXh0T3JGaWxlTmFtZSA9PT0gJ05vdGUnIHx8IHRleHRPckZpbGVOYW1lID09PSAnT2NjdXJyZW5jZU5vdGUnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vdGljZS5kZXRhaWxzID0gYG1hcmtkb3duIGxpbmUgJHtufWA7XG4gICAgICAgICAgICAgICAgICAgICAgICBhZGROb3RpY2Uobm90aWNlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3Qgc3VnZ2VzdGVkTGluZSA9IGF3YWl0IGNoZWNrTWFya2Rvd25MaW5lQ29udGVudHMobiwgbGluZSwgb3VyTG9jYXRpb24pO1xuICAgICAgICAgICAgc3VnZ2VzdGVkTGluZXMucHVzaChzdWdnZXN0ZWRMaW5lID09PSB1bmRlZmluZWQgPyBsaW5lIDogc3VnZ2VzdGVkTGluZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBUaGlzIGlzIGEgYmxhbmsgbGluZVxuICAgICAgICAgICAgbnVtTGVhZGluZ1NwYWNlcyA9IDA7XG4gICAgICAgICAgICBzdWdnZXN0ZWRMaW5lcy5wdXNoKCcnKTtcblxuICAgICAgICAgICAgLy8gU2hvdWxkIG9ubHkgZXZlciBoYXZlIHNpbmdsZSBibGFuayBsaW5lcyBpbiBtYXJrZG93blxuICAgICAgICAgICAgaWYgKG4gPiAxICYmIGxhc3RMaW5lLmxlbmd0aCA9PT0gMCAmJiBuZXh0TGluZT8ubGVuZ3RoID09PSAwICYmICFub3RpZmllZEJsYW5rTGluZXMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBub3RpY2UgPSB7IHByaW9yaXR5OiAyNTAsIG1lc3NhZ2U6IFwiTXVsdGlwbGUgYmxhbmsgbGluZXMgYXJlIG5vdCBleHBlY3RlZCBpbiBtYXJrZG93blwiLCBsaW5lTnVtYmVyOiBuLCBsb2NhdGlvbjogb3VyTG9jYXRpb24gfTtcbiAgICAgICAgICAgICAgICBpZiAodGV4dE9yRmlsZU5hbWUgPT09ICdOb3RlJyB8fCB0ZXh0T3JGaWxlTmFtZSA9PT0gJ09jY3VycmVuY2VOb3RlJylcbiAgICAgICAgICAgICAgICAgICAgbm90aWNlLmRldGFpbHMgPSBgbWFya2Rvd24gbGluZSAke259YDtcbiAgICAgICAgICAgICAgICBhZGROb3RpY2Uobm90aWNlKTtcbiAgICAgICAgICAgICAgICBub3RpZmllZEJsYW5rTGluZXMgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgbGFzdExpbmUgPSBsaW5lO1xuICAgICAgICAvLyBsYXN0TnVtTGVhZGluZ1NwYWNlcyA9IG51bUxlYWRpbmdTcGFjZXM7XG4gICAgfVxuXG5cbiAgICAvLyBDaGVjayBmb3IgYW4gdW5ldmVuIG51bWJlciBvZiBzZXRzIG9mIHN5bW1ldHJpY2FsIChpLmUuLCBvcGVuZXIgPT0gY2xvc2VyKSBtdWx0aWNoYXJhY3RlciBtYXJrZG93biBmb3JtYXR0aW5nIHNlcXVlbmNlc1xuICAgIGZvciAoY29uc3QgdGhpc1NldCBvZiBbIC8vIFB1dCBsb25nZXN0IG9uZXMgZmlyc3RcbiAgICAgICAgLy8gU2VlbXMgdGhhdCB0aGUgZmFuY3kgb25lcyAoY29tbWVudGVkIG91dCkgZG9uJ3QgZmluZCBvY2N1cnJlbmNlcyBhdCB0aGUgc3RhcnQgKG9yIGVuZD8pIG9mIHRoZSB0ZXh0XG4gICAgICAgIFsnX19fJywgL19fXy9nXSxcbiAgICAgICAgLy8gWydfX18nLCByJ1teX11fX19bXl9dJ10sIC8vIHRocmVlIHVuZGVybGluZXNcbiAgICAgICAgWycqKionLCAvXFwqXFwqXFwqL2ddLFxuICAgICAgICAvLyBbJyoqKicsIHInW15cXCpdXFwqXFwqXFwqW15cXCpdJ10sIC8vIHRocmVlIGFzdGVyaXNrc1xuICAgICAgICBbJ19fJywgL19fL2ddLFxuICAgICAgICAvLyBbJ19fJywgcidbXl9dX19bXl9dJ10sIC8vIHR3byB1bmRlcmxpbmVzXG4gICAgICAgIFsnKionLCAvXFwqXFwqL2ddLFxuICAgICAgICAvLyBbJyoqJywgcidbXlxcKl1cXCpcXCpbXlxcKl0nXSwgLy8gdHdvIGFzdGVyaXNrc1xuICAgIF0pIHtcbiAgICAgICAgY29uc3QgdGhpc0ZpZWxkID0gdGhpc1NldFswXSwgdGhpc1JlZ2V4ID0gdGhpc1NldFsxXTtcbiAgICAgICAgY29uc3QgY291bnQgPSAoKG1hcmtkb3duVGV4dCB8fCAnJykubWF0Y2godGhpc1JlZ2V4KSB8fCBbXSkubGVuZ3RoOyAvLyBGaW5kcyBvbmx5IE5PTi1PVkVSTEFQUElORyBtYXRjaGVzIGhvcGVmdWxseVxuICAgICAgICBpZiAoY291bnQgJiYgKGNvdW50ICUgMikgIT09IDApIHtcbiAgICAgICAgICAgIGNvbnN0IGNoYXJhY3RlckluZGV4ID0gbWFya2Rvd25UZXh0LmluZGV4T2YodGhpc0ZpZWxkKTtcbiAgICAgICAgICAgIGNvbnN0IGl5ID0gY2hhcmFjdGVySW5kZXggKyBleGNlcnB0SGFsZkxlbmd0aDsgLy8gV2FudCBleGNlcnB0IHRvIGZvY3VzIG1vcmUgb24gd2hhdCBmb2xsb3dzXG4gICAgICAgICAgICBjb25zdCBleGNlcnB0ID0gLyooaXkgPiBleGNlcnB0SGFsZkxlbmd0aCA/ICfigKYnIDogJycpICsqLyBtYXJrZG93blRleHQuc3Vic3RyaW5nKGl5IC0gZXhjZXJwdEhhbGZMZW5ndGgsIGl5ICsgZXhjZXJwdEhhbGZMZW5ndGhQbHVzKSArIChpeSArIGV4Y2VycHRIYWxmTGVuZ3RoUGx1cyA8IG1hcmtkb3duVGV4dC5sZW5ndGggPyAn4oCmJyA6ICcnKVxuICAgICAgICAgICAgYWRkTm90aWNlKHsgcHJpb3JpdHk6IDM3OCwgbWVzc2FnZTogYFBvc3NpYmxlIG1pc21hdGNoZWQgJyR7dGhpc0ZpZWxkfScgbWFya2Rvd24gZm9ybWF0dGluZyBwYWlyc2AsIGRldGFpbHM6IGAke2NvdW50LnRvTG9jYWxlU3RyaW5nKCl9IHRvdGFsIG9jY3VycmVuY2Uke2NvdW50ID09PSAxID8gJycgOiAncyd9YCwgY2hhcmFjdGVySW5kZXgsIGV4Y2VycHQsIGxvY2F0aW9uOiBvdXJMb2NhdGlvbiB9KTtcbiAgICAgICAgICAgIGJyZWFrOyAvLyBPbmx5IHdhbnQgb25lIHdhcm5pbmcgcGVyIHRleHRcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IHN1Z2dlc3Rpb24gPSBzdWdnZXN0ZWRMaW5lcy5qb2luKCdcXG4nKTtcbiAgICBpZiAoc3VnZ2VzdGlvbiAhPT0gbWFya2Rvd25UZXh0KSB7XG4gICAgICAgIC8vIGRlYnVnTG9nKGBIYWQgbWFya2Rvd24gJHttYXJrZG93blRleHR9YCk7XG4gICAgICAgIC8vIGRlYnVnTG9nKGBTdWcgbWFya2Rvd24gJHtzdWdnZXN0aW9ufWApO1xuICAgICAgICByZXN1bHQuc3VnZ2VzdGlvbiA9IHN1Z2dlc3Rpb247XG4gICAgfVxuXG4gICAgaWYgKCFjaGVja2luZ09wdGlvbnM/LnN1cHByZXNzTm90aWNlRGlzYWJsaW5nRmxhZykge1xuICAgICAgICAvLyBmdW5jdGlvbkxvZyhgY2hlY2tNYXJrZG93blRleHQ6IGNhbGxpbmcgcmVtb3ZlRGlzYWJsZWROb3RpY2VzKCR7cmVzdWx0Lm5vdGljZUxpc3QubGVuZ3RofSkgaGF2aW5nICR7SlNPTi5zdHJpbmdpZnkoY2hlY2tpbmdPcHRpb25zKX1gKTtcbiAgICAgICAgcmVzdWx0Lm5vdGljZUxpc3QgPSByZW1vdmVEaXNhYmxlZE5vdGljZXMocmVzdWx0Lm5vdGljZUxpc3QpO1xuICAgIH1cblxuICAgIGFkZFN1Y2Nlc3NNZXNzYWdlKGBDaGVja2VkIGFsbCAke2xpbmVzLmxlbmd0aC50b0xvY2FsZVN0cmluZygpfSBsaW5lJHtsaW5lcy5sZW5ndGggPT09IDEgPyAnJyA6ICdzJ30ke291ckxvY2F0aW9ufS5gKTtcbiAgICBpZiAocmVzdWx0Lm5vdGljZUxpc3QubGVuZ3RoKVxuICAgICAgICBhZGRTdWNjZXNzTWVzc2FnZShgY2hlY2tNYXJrZG93blRleHQgdiR7TUFSS0RPV05fVEVYVF9WQUxJREFUT1JfVkVSU0lPTl9TVFJJTkd9IGZpbmlzaGVkIHdpdGggJHtyZXN1bHQubm90aWNlTGlzdC5sZW5ndGggPyByZXN1bHQubm90aWNlTGlzdC5sZW5ndGgudG9Mb2NhbGVTdHJpbmcoKSA6IFwiemVyb1wifSBub3RpY2Uke3Jlc3VsdC5ub3RpY2VMaXN0Lmxlbmd0aCA9PT0gMSA/ICcnIDogJ3MnfWApO1xuICAgIGVsc2VcbiAgICAgICAgYWRkU3VjY2Vzc01lc3NhZ2UoYE5vIGVycm9ycyBvciB3YXJuaW5ncyBmb3VuZCBieSBjaGVja01hcmtkb3duVGV4dCB2JHtNQVJLRE9XTl9URVhUX1ZBTElEQVRPUl9WRVJTSU9OX1NUUklOR31gKVxuICAgIC8vIGRlYnVnTG9nKGAgIGNoZWNrTWFya2Rvd25UZXh0IHJldHVybmluZyB3aXRoICR7cmVzdWx0LnN1Y2Nlc3NMaXN0Lmxlbmd0aC50b0xvY2FsZVN0cmluZygpfSBzdWNjZXNzKGVzKSwgJHtyZXN1bHQubm90aWNlTGlzdC5sZW5ndGgudG9Mb2NhbGVTdHJpbmcoKX0gbm90aWNlKHMpLmApO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG4vLyBlbmQgb2YgY2hlY2tNYXJrZG93blRleHQgZnVuY3Rpb25cbiJdfQ==