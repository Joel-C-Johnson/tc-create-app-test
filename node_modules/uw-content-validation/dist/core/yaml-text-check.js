"use strict";var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");Object.defineProperty(exports, "__esModule", { value: true });exports.checkYAMLText = checkYAMLText;var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));var _yaml = _interopRequireDefault(require("yaml"));

var _defaults = require("./defaults");
var _fieldTextCheck = require("./field-text-check");
var _fileTextCheck = require("./file-text-check");
var _disabledNotices = require("./disabled-notices");

var _utilities = require("./utilities");function ownKeys(object, enumerableOnly) {var keys = Object.keys(object);if (Object.getOwnPropertySymbols) {var symbols = Object.getOwnPropertySymbols(object);if (enumerableOnly) {symbols = symbols.filter(function (sym) {return Object.getOwnPropertyDescriptor(object, sym).enumerable;});}keys.push.apply(keys, symbols);}return keys;}function _objectSpread(target) {for (var i = 1; i < arguments.length; i++) {var source = arguments[i] != null ? arguments[i] : {};if (i % 2) {ownKeys(Object(source), true).forEach(function (key) {(0, _defineProperty2.default)(target, key, source[key]);});} else if (Object.getOwnPropertyDescriptors) {Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));} else {ownKeys(Object(source)).forEach(function (key) {Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));});}}return target;}function _createForOfIteratorHelper(o, allowArrayLike) {var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];if (!it) {if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {if (it) o = it;var i = 0;var F = function F() {};return { s: F, n: function n() {if (i >= o.length) return { done: true };return { done: false, value: o[i++] };}, e: function e(_e) {throw _e;}, f: F };}throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");}var normalCompletion = true,didErr = false,err;return { s: function s() {it = it.call(o);}, n: function n() {var step = it.next();normalCompletion = step.done;return step;}, e: function e(_e2) {didErr = true;err = _e2;}, f: function f() {try {if (!normalCompletion && it.return != null) it.return();} finally {if (didErr) throw err;}} };}function _unsupportedIterableToArray(o, minLen) {if (!o) return;if (typeof o === "string") return _arrayLikeToArray(o, minLen);var n = Object.prototype.toString.call(o).slice(8, -1);if (n === "Object" && o.constructor) n = o.constructor.name;if (n === "Map" || n === "Set") return Array.from(o);if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);}function _arrayLikeToArray(arr, len) {if (len == null || len > arr.length) len = arr.length;for (var i = 0, arr2 = new Array(len); i < len; i++) {arr2[i] = arr[i];}return arr2;}


var YAML_VALIDATOR_VERSION_STRING = '0.4.3';


/**
 *
 * @param {string} languageCode
 * @param {string} repoCode -- e.g., 'TN' or 'TQ2', etc.
 * @param {string} textName
 * @param {string} YAMLText
 * @param {string} givenLocation
 * @param {Object} checkingOptions
 */
function checkYAMLText(languageCode, repoCode, textName, YAMLText, givenLocation, checkingOptions) {
  /* This function is optimised for checking the entire file, i.e., all lines.
    Returns a result object containing a successList and a noticeList,
      as well as the parsed YAML for further checking.
    */


  // functionLog(`checkYAMLText(${textName}, ${YAMLText.length}, ${givenLocation})…`);
  //parameterAssert(languageCode !== undefined, "checkYAMLText: 'languageCode' parameter should be defined");
  //parameterAssert(typeof languageCode === 'string', `checkYAMLText: 'languageCode' parameter should be a string not a '${typeof languageCode}': ${languageCode}`);
  //parameterAssert(repoCode !== undefined, "checkYAMLText: 'repoCode' parameter should be defined");
  //parameterAssert(typeof repoCode === 'string', `checkYAMLText: 'repoCode' parameter should be a string not a '${typeof repoCode}': ${repoCode}`);
  //parameterAssert(REPO_CODES_LIST.includes(repoCode), `checkYAMLText: 'repoCode' parameter should not be '${repoCode}'`);
  //parameterAssert(textName !== undefined, "checkYAMLText: 'textName' parameter should be defined");
  //parameterAssert(typeof textName === 'string', `checkYAMLText: 'textName' parameter should be a string not a '${typeof textName}': ${textName}`);
  //parameterAssert(YAMLText !== undefined, "checkYAMLText: 'YAMLText' parameter should be defined");
  //parameterAssert(typeof YAMLText === 'string', `checkYAMLText: 'YAMLText' parameter should be a string not a '${typeof YAMLText}': ${YAMLText}`);
  //parameterAssert(givenLocation !== undefined, "checkYAMLText: 'optionalFieldLocation' parameter should be defined");
  //parameterAssert(typeof givenLocation === 'string', `checkYAMLText: 'optionalFieldLocation' parameter should be a string not a '${typeof givenLocation}': ${givenLocation}`);
  //parameterAssert(givenLocation.indexOf('true') === -1, `checkYAMLText: 'optionalFieldLocation' parameter should not be '${givenLocation}'`);
  //parameterAssert(checkingOptions !== undefined, "checkYAMLText: 'checkingOptions' parameter should be defined");
  if (checkingOptions !== undefined) {//parameterAssert(typeof checkingOptions === 'object', `checkYAMLText: 'checkingOptions' parameter should be an object not a '${typeof checkingOptions}': ${JSON.stringify(checkingOptions)}`);
  }

  var ourLocation = givenLocation;
  if (ourLocation && ourLocation[0] !== ' ') ourLocation = " ".concat(ourLocation);
  // if (textName) ourLocation = ` in ${textName}${ourLocation}`;

  var excerptLength;
  try {
    excerptLength = checkingOptions === null || checkingOptions === void 0 ? void 0 : checkingOptions.excerptLength;
  } catch (ytcError) {}
  if (typeof excerptLength !== 'number' || isNaN(excerptLength)) {
    excerptLength = _defaults.DEFAULT_EXCERPT_LENGTH;
    // debugLog(`Using default excerptLength=${excerptLength}`);
  }
  // else
  // debugLog(`Using supplied excerptLength=${excerptLength}`, `cf. default=${DEFAULT_EXCERPT_LENGTH}`);
  // const excerptHalfLength = Math.floor(excerptLength / 2); // rounded down
  // const excerptHalfLengthPlus = Math.floor((excerptLength+1) / 2); // rounded up
  // debugLog(`Using excerptHalfLength=${excerptHalfLength}`, `excerptHalfLengthPlus=${excerptHalfLengthPlus}`);

  var cytResult = { successList: [], noticeList: [] };

  function addSuccessMessage(successString) {
    // functionLog(`checkYAMLText success: ${successString}`);
    cytResult.successList.push(successString);
  }
  function addNotice(noticeObject) {
    // functionLog(`checkYAMLText Notice: (priority=${priority}) ${message}${characterIndex > 0 ? ` (at character ${characterIndex})` : ""}${excerpt ? ` ${excerpt}` : ""}${location}`);
    //parameterAssert(noticeObject.priority !== undefined, "cYt addNotice: 'priority' parameter should be defined");
    //parameterAssert(typeof noticeObject.priority === 'number', `cManT addNotice: 'priority' parameter should be a number not a '${typeof noticeObject.priority}': ${noticeObject.priority}`);
    //parameterAssert(noticeObject.message !== undefined, "cYt addNotice: 'message' parameter should be defined");
    //parameterAssert(typeof noticeObject.message === 'string', `cManT addNotice: 'message' parameter should be a string not a '${typeof noticeObject.message}': ${noticeObject.message}`);
    // //parameterAssert(characterIndex!==undefined, "cYt addNotice: 'characterIndex' parameter should be defined");
    if (noticeObject.characterIndex) {//parameterAssert(typeof noticeObject.characterIndex === 'number', `cManT addNotice: 'characterIndex' parameter should be a number not a '${typeof noticeObject.characterIndex}': ${noticeObject.characterIndex}`);
    }
    // //parameterAssert(excerpt!==undefined, "cYt addNotice: 'excerpt' parameter should be defined");
    if (noticeObject.excerpt) {//parameterAssert(typeof noticeObject.excerpt === 'string', `cManT addNotice: 'excerpt' parameter should be a string not a '${typeof noticeObject.excerpt}': ${noticeObject.excerpt}`);
    }
    //parameterAssert(noticeObject.location !== undefined, "cYt addNotice: 'location' parameter should be defined");
    //parameterAssert(typeof noticeObject.location === 'string', `cYt addNotice: 'location' parameter should be a string not a '${typeof noticeObject.location}': ${noticeObject.location}`);
    if (noticeObject.debugChain) noticeObject.debugChain = "checkYAMLText ".concat(noticeObject.debugChain);
    cytResult.noticeList.push(noticeObject);
  }

  function ourCheckTextField(lineNumber, fieldText, allowedLinks, optionalFieldLocation, checkingOptions) {
    /**
    * @description - checks the given text field and processes the returned results
    * @param {string} fieldName - name of the field being checked
    * @param {string} fieldText - the actual text of the field being checked
    * @param {boolean} allowedLinks - true if links are allowed in the field, otherwise false
    * @param {string} optionalFieldLocation - description of where the field is located
    * @param {Object} checkingOptions - parameters that might affect the check
    */
    // Does basic checks for small errors like leading/trailing spaces, etc.

    // We assume that checking for compulsory fields is done elsewhere

    // Updates the global list of notices
    // debugLog(`cYt ourCheckTextField(${fieldName}, (${fieldText.length}), ${allowedLinks}, ${fieldLocation}, …)`);
    //parameterAssert(fieldText !== undefined, "cYt ourCheckTextField: 'fieldText' parameter should be defined");
    //parameterAssert(typeof fieldText === 'string', `cYt ourCheckTextField: 'fieldText' parameter should be a string not a '${typeof fieldText}'`);
    //parameterAssert(allowedLinks === true || allowedLinks === false, "cYt ourCheckTextField: allowedLinks parameter must be either true or false");
    //parameterAssert(optionalFieldLocation !== undefined, "cYt ourCheckTextField: 'optionalFieldLocation' parameter should be defined");
    //parameterAssert(typeof optionalFieldLocation === 'string', `cYt ourCheckTextField: 'optionalFieldLocation' parameter should be a string not a '${typeof optionalFieldLocation}'`);

    var resultObject = (0, _fieldTextCheck.checkTextField)(languageCode, repoCode, 'YAML', '', fieldText, allowedLinks, optionalFieldLocation, checkingOptions);

    // Concat is faster if we don’t need to process each notice individually
    // cytResult.noticeList = cytResult.noticeList.concat(resultObject.noticeList);
    // // Process noticeList line by line
    // //  suppressing undesired errors
    var _iterator = _createForOfIteratorHelper(resultObject.noticeList),_step;try {for (_iterator.s(); !(_step = _iterator.n()).done;) {var noticeEntry = _step.value;
        addNotice(_objectSpread(_objectSpread({}, noticeEntry), {}, { lineNumber: lineNumber }));}} catch (err) {_iterator.e(err);} finally {_iterator.f();}
  }
  // end of ourCheckTextField function

  function checkYAMLLineContents(lineNumber, lineText, lineLocation) {

    // functionLog(`checkYAMLLineContents for '${lineNumber} ${lineText}' at${lineLocation}`);
    var thisText = lineText;

    // Remove leading spaces
    thisText = thisText.replace(/^ +/g, '');
    // debugLog(`After removing leading spaces have '${thisText}'`);

    // Remove leading hyphens
    thisText = thisText.replace(/^-/g, '');
    // debugLog(`After removing hyphens have '${thisText}'`);

    // Remove leading spaces again now
    thisText = thisText.replace(/^ +/g, '');
    // debugLog(`After removing more leading spaces have '${thisText}'`);

    var allowedLinksInLine = thisText.startsWith('url:') || thisText.startsWith('chapter_url:') || thisText.startsWith('rc:');
    if (thisText)
    ourCheckTextField(lineNumber, thisText, allowedLinksInLine, lineLocation, checkingOptions);
  }
  // end of checkYAMLLine function


  function ourBasicFileChecks(filename, fileText, fileLocation, checkingOptions) {
    // Does basic checks for small errors like leading/trailing spaces, etc.

    // We assume that checking for compulsory fields is done elsewhere

    // Updates the global list of notices
    //parameterAssert(filename !== undefined, "cYT ourBasicFileChecks: 'filename' parameter should be defined");
    //parameterAssert(typeof filename === 'string', `cYT ourBasicFileChecks: 'filename' parameter should be a string not a '${typeof filename}'`);
    //parameterAssert(fileText !== undefined, "cYT ourBasicFileChecks: 'fileText' parameter should be defined");
    //parameterAssert(typeof fileText === 'string', `cYT ourBasicFileChecks: 'fileText' parameter should be a string not a '${typeof fileText}'`);
    //parameterAssert(checkingOptions !== undefined, "cYT ourBasicFileChecks: 'checkingOptions' parameter should be defined");

    var resultObject = (0, _fileTextCheck.checkTextfileContents)(languageCode, repoCode, 'YAML', filename, fileText, fileLocation, checkingOptions);

    // If we need to put everything through addNoticePartial, e.g., for debugging or filtering
    //  process results line by line
    var _iterator2 = _createForOfIteratorHelper(resultObject.noticeList),_step2;try {for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {var noticeEntry = _step2.value;
        //parameterAssert(Object.keys(noticeEntry).length >= 5, `USFM ourBasicFileChecks notice length=${Object.keys(noticeEntry).length}`);
        addNotice(noticeEntry);
      }} catch (err) {_iterator2.e(err);} finally {_iterator2.f();}
  }
  // end of ourBasicFileChecks function


  // Main code for checkYAMLText function
  var lines = YAMLText.split('\n');
  // debugLog(`  '${location}' has ${lines.length.toLocaleString()} total lines`);
  var formData;
  try {
    formData = _yaml.default.parse(YAMLText);
    // debugLog("yaml.parse(YAMLText) got formData", JSON.stringify(formData));
  }
  catch (yamlError) {
    // console.error(`yaml parse error: ${yamlError.message}`);
    addNotice({ priority: 920, message: yamlError.message, location: ourLocation });
  }
  // Add the parsed YAML to our result
  cytResult.formData = formData;

  // let lastNumLeadingSpaces = 0;
  // let lastLineContents;
  for (var n = 1; n <= lines.length; n++) {

    var line = lines[n - 1];
    // let numLeadingSpaces;
    // if (line) {
    //     numLeadingSpaces = line.match(/^ */)[0].length;
    // debugLog(`Got numLeadingSpaces=${numLeadingSpaces} for ${line}${atString}`);
    //     if (numLeadingSpaces && lastNumLeadingSpaces && numLeadingSpaces!=lastNumLeadingSpaces)
    //         addNotice({472, "Nesting seems confused", 0, '', atString);

    checkYAMLLineContents(n, line, ourLocation);
    // } else {
    //     // This is a blank line
    //     numLeadingSpaces = 0;
    // }

    // lastLineContents = line;
    // lastNumLeadingSpaces = numLeadingSpaces;
  }

  // Do basic file checks
  ourBasicFileChecks(textName, YAMLText, givenLocation, checkingOptions);

  if (!(checkingOptions !== null && checkingOptions !== void 0 && checkingOptions.suppressNoticeDisablingFlag)) {
    // functionLog(`checkYAMLText: calling removeDisabledNotices(${cytResult.noticeList.length}) having ${JSON.stringify(checkingOptions)}`);
    cytResult.noticeList = (0, _disabledNotices.removeDisabledNotices)(cytResult.noticeList);
  }

  addSuccessMessage("Checked all ".concat(lines.length.toLocaleString(), " line").concat(lines.length === 1 ? '' : 's').concat(ourLocation, "."));
  if (cytResult.noticeList.length)
  addSuccessMessage("checkYAMLText v".concat(YAML_VALIDATOR_VERSION_STRING, " finished with ").concat(cytResult.noticeList.length ? cytResult.noticeList.length.toLocaleString() : "zero", " notice").concat(cytResult.noticeList.length === 1 ? '' : 's'));else

  addSuccessMessage("No errors or warnings found by checkYAMLText v".concat(YAML_VALIDATOR_VERSION_STRING));
  // debugLog(`  checkYAMLText returning with ${cytResult.successList.length.toLocaleString()} success(es), ${cytResult.noticeList.length.toLocaleString()} notice(s).`);
  // debugLog("checkYAMLText result is", JSON.stringify(result));
  return cytResult;
}
// end of checkYAMLText function
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9jb3JlL3lhbWwtdGV4dC1jaGVjay5qcyJdLCJuYW1lcyI6WyJZQU1MX1ZBTElEQVRPUl9WRVJTSU9OX1NUUklORyIsImNoZWNrWUFNTFRleHQiLCJsYW5ndWFnZUNvZGUiLCJyZXBvQ29kZSIsInRleHROYW1lIiwiWUFNTFRleHQiLCJnaXZlbkxvY2F0aW9uIiwiY2hlY2tpbmdPcHRpb25zIiwidW5kZWZpbmVkIiwib3VyTG9jYXRpb24iLCJleGNlcnB0TGVuZ3RoIiwieXRjRXJyb3IiLCJpc05hTiIsIkRFRkFVTFRfRVhDRVJQVF9MRU5HVEgiLCJjeXRSZXN1bHQiLCJzdWNjZXNzTGlzdCIsIm5vdGljZUxpc3QiLCJhZGRTdWNjZXNzTWVzc2FnZSIsInN1Y2Nlc3NTdHJpbmciLCJwdXNoIiwiYWRkTm90aWNlIiwibm90aWNlT2JqZWN0IiwiY2hhcmFjdGVySW5kZXgiLCJleGNlcnB0IiwiZGVidWdDaGFpbiIsIm91ckNoZWNrVGV4dEZpZWxkIiwibGluZU51bWJlciIsImZpZWxkVGV4dCIsImFsbG93ZWRMaW5rcyIsIm9wdGlvbmFsRmllbGRMb2NhdGlvbiIsInJlc3VsdE9iamVjdCIsIm5vdGljZUVudHJ5IiwiY2hlY2tZQU1MTGluZUNvbnRlbnRzIiwibGluZVRleHQiLCJsaW5lTG9jYXRpb24iLCJ0aGlzVGV4dCIsInJlcGxhY2UiLCJhbGxvd2VkTGlua3NJbkxpbmUiLCJzdGFydHNXaXRoIiwib3VyQmFzaWNGaWxlQ2hlY2tzIiwiZmlsZW5hbWUiLCJmaWxlVGV4dCIsImZpbGVMb2NhdGlvbiIsImxpbmVzIiwic3BsaXQiLCJmb3JtRGF0YSIsInlhbWwiLCJwYXJzZSIsInlhbWxFcnJvciIsInByaW9yaXR5IiwibWVzc2FnZSIsImxvY2F0aW9uIiwibiIsImxlbmd0aCIsImxpbmUiLCJzdXBwcmVzc05vdGljZURpc2FibGluZ0ZsYWciLCJ0b0xvY2FsZVN0cmluZyJdLCJtYXBwaW5ncyI6InNTQUFBOztBQUVBO0FBQ0E7QUFDQTtB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QUEvRSxTQUFxRjVDLFdBQXJGLE9BQWpCO0FBQ0EsTUFBSUssU0FBUyxDQUFDRSxVQUFWLENBQXFCcUMsTUFBekI7QUFDSXBDLEVBQUFBLGlCQUFpQiwwQkFBbUJqQiw2QkFBbkIsNEJBQWtFYyxTQUFTLENBQUNFLFVBQVYsQ0FBcUJxQyxNQUFyQixHQUE4QnZDLFNBQVMsQ0FBQ0UsVUFBVixDQUFxQnFDLE1BQXJCLENBQTRCRyxjQUE1QixFQUE5QixHQUE2RSxNQUEvSSxvQkFBK0oxQyxTQUFTLENBQUNFLFVBQVYsQ0FBcUJxQyxNQUFyQixLQUFnQyxDQUFoQyxHQUFvQyxFQUFwQyxHQUF5QyxHQUF4TSxFQUFqQixDQURKOztBQUdJcEMsRUFBQUEsaUJBQWlCLHlEQUFrRGpCLDZCQUFsRCxFQUFqQjtBQUNKO0FBQ0E7QUFDQSxTQUFPYyxTQUFQO0FBQ0g7QUFDRCIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB5YW1sIGZyb20gJ3lhbWwnO1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC12YXJzXG5pbXBvcnQgeyBERUZBVUxUX0VYQ0VSUFRfTEVOR1RILCBSRVBPX0NPREVTX0xJU1QgfSBmcm9tICcuL2RlZmF1bHRzJ1xuaW1wb3J0IHsgY2hlY2tUZXh0RmllbGQgfSBmcm9tICcuL2ZpZWxkLXRleHQtY2hlY2snO1xuaW1wb3J0IHsgY2hlY2tUZXh0ZmlsZUNvbnRlbnRzIH0gZnJvbSAnLi9maWxlLXRleHQtY2hlY2snO1xuaW1wb3J0IHsgcmVtb3ZlRGlzYWJsZWROb3RpY2VzIH0gZnJvbSAnLi9kaXNhYmxlZC1ub3RpY2VzJztcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtdmFyc1xuaW1wb3J0IHsgcGFyYW1ldGVyQXNzZXJ0IH0gZnJvbSAnLi91dGlsaXRpZXMnO1xuXG5cbmNvbnN0IFlBTUxfVkFMSURBVE9SX1ZFUlNJT05fU1RSSU5HID0gJzAuNC4zJztcblxuXG4vKipcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gbGFuZ3VhZ2VDb2RlXG4gKiBAcGFyYW0ge3N0cmluZ30gcmVwb0NvZGUgLS0gZS5nLiwgJ1ROJyBvciAnVFEyJywgZXRjLlxuICogQHBhcmFtIHtzdHJpbmd9IHRleHROYW1lXG4gKiBAcGFyYW0ge3N0cmluZ30gWUFNTFRleHRcbiAqIEBwYXJhbSB7c3RyaW5nfSBnaXZlbkxvY2F0aW9uXG4gKiBAcGFyYW0ge09iamVjdH0gY2hlY2tpbmdPcHRpb25zXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjaGVja1lBTUxUZXh0KGxhbmd1YWdlQ29kZSwgcmVwb0NvZGUsIHRleHROYW1lLCBZQU1MVGV4dCwgZ2l2ZW5Mb2NhdGlvbiwgY2hlY2tpbmdPcHRpb25zKSB7XG4gICAgLyogVGhpcyBmdW5jdGlvbiBpcyBvcHRpbWlzZWQgZm9yIGNoZWNraW5nIHRoZSBlbnRpcmUgZmlsZSwgaS5lLiwgYWxsIGxpbmVzLlxuXG4gICAgIFJldHVybnMgYSByZXN1bHQgb2JqZWN0IGNvbnRhaW5pbmcgYSBzdWNjZXNzTGlzdCBhbmQgYSBub3RpY2VMaXN0LFxuICAgICAgICBhcyB3ZWxsIGFzIHRoZSBwYXJzZWQgWUFNTCBmb3IgZnVydGhlciBjaGVja2luZy5cblxuICAgICAqL1xuICAgIC8vIGZ1bmN0aW9uTG9nKGBjaGVja1lBTUxUZXh0KCR7dGV4dE5hbWV9LCAke1lBTUxUZXh0Lmxlbmd0aH0sICR7Z2l2ZW5Mb2NhdGlvbn0p4oCmYCk7XG4gICAgLy9wYXJhbWV0ZXJBc3NlcnQobGFuZ3VhZ2VDb2RlICE9PSB1bmRlZmluZWQsIFwiY2hlY2tZQU1MVGV4dDogJ2xhbmd1YWdlQ29kZScgcGFyYW1ldGVyIHNob3VsZCBiZSBkZWZpbmVkXCIpO1xuICAgIC8vcGFyYW1ldGVyQXNzZXJ0KHR5cGVvZiBsYW5ndWFnZUNvZGUgPT09ICdzdHJpbmcnLCBgY2hlY2tZQU1MVGV4dDogJ2xhbmd1YWdlQ29kZScgcGFyYW1ldGVyIHNob3VsZCBiZSBhIHN0cmluZyBub3QgYSAnJHt0eXBlb2YgbGFuZ3VhZ2VDb2RlfSc6ICR7bGFuZ3VhZ2VDb2RlfWApO1xuICAgIC8vcGFyYW1ldGVyQXNzZXJ0KHJlcG9Db2RlICE9PSB1bmRlZmluZWQsIFwiY2hlY2tZQU1MVGV4dDogJ3JlcG9Db2RlJyBwYXJhbWV0ZXIgc2hvdWxkIGJlIGRlZmluZWRcIik7XG4gICAgLy9wYXJhbWV0ZXJBc3NlcnQodHlwZW9mIHJlcG9Db2RlID09PSAnc3RyaW5nJywgYGNoZWNrWUFNTFRleHQ6ICdyZXBvQ29kZScgcGFyYW1ldGVyIHNob3VsZCBiZSBhIHN0cmluZyBub3QgYSAnJHt0eXBlb2YgcmVwb0NvZGV9JzogJHtyZXBvQ29kZX1gKTtcbiAgICAvL3BhcmFtZXRlckFzc2VydChSRVBPX0NPREVTX0xJU1QuaW5jbHVkZXMocmVwb0NvZGUpLCBgY2hlY2tZQU1MVGV4dDogJ3JlcG9Db2RlJyBwYXJhbWV0ZXIgc2hvdWxkIG5vdCBiZSAnJHtyZXBvQ29kZX0nYCk7XG4gICAgLy9wYXJhbWV0ZXJBc3NlcnQodGV4dE5hbWUgIT09IHVuZGVmaW5lZCwgXCJjaGVja1lBTUxUZXh0OiAndGV4dE5hbWUnIHBhcmFtZXRlciBzaG91bGQgYmUgZGVmaW5lZFwiKTtcbiAgICAvL3BhcmFtZXRlckFzc2VydCh0eXBlb2YgdGV4dE5hbWUgPT09ICdzdHJpbmcnLCBgY2hlY2tZQU1MVGV4dDogJ3RleHROYW1lJyBwYXJhbWV0ZXIgc2hvdWxkIGJlIGEgc3RyaW5nIG5vdCBhICcke3R5cGVvZiB0ZXh0TmFtZX0nOiAke3RleHROYW1lfWApO1xuICAgIC8vcGFyYW1ldGVyQXNzZXJ0KFlBTUxUZXh0ICE9PSB1bmRlZmluZWQsIFwiY2hlY2tZQU1MVGV4dDogJ1lBTUxUZXh0JyBwYXJhbWV0ZXIgc2hvdWxkIGJlIGRlZmluZWRcIik7XG4gICAgLy9wYXJhbWV0ZXJBc3NlcnQodHlwZW9mIFlBTUxUZXh0ID09PSAnc3RyaW5nJywgYGNoZWNrWUFNTFRleHQ6ICdZQU1MVGV4dCcgcGFyYW1ldGVyIHNob3VsZCBiZSBhIHN0cmluZyBub3QgYSAnJHt0eXBlb2YgWUFNTFRleHR9JzogJHtZQU1MVGV4dH1gKTtcbiAgICAvL3BhcmFtZXRlckFzc2VydChnaXZlbkxvY2F0aW9uICE9PSB1bmRlZmluZWQsIFwiY2hlY2tZQU1MVGV4dDogJ29wdGlvbmFsRmllbGRMb2NhdGlvbicgcGFyYW1ldGVyIHNob3VsZCBiZSBkZWZpbmVkXCIpO1xuICAgIC8vcGFyYW1ldGVyQXNzZXJ0KHR5cGVvZiBnaXZlbkxvY2F0aW9uID09PSAnc3RyaW5nJywgYGNoZWNrWUFNTFRleHQ6ICdvcHRpb25hbEZpZWxkTG9jYXRpb24nIHBhcmFtZXRlciBzaG91bGQgYmUgYSBzdHJpbmcgbm90IGEgJyR7dHlwZW9mIGdpdmVuTG9jYXRpb259JzogJHtnaXZlbkxvY2F0aW9ufWApO1xuICAgIC8vcGFyYW1ldGVyQXNzZXJ0KGdpdmVuTG9jYXRpb24uaW5kZXhPZigndHJ1ZScpID09PSAtMSwgYGNoZWNrWUFNTFRleHQ6ICdvcHRpb25hbEZpZWxkTG9jYXRpb24nIHBhcmFtZXRlciBzaG91bGQgbm90IGJlICcke2dpdmVuTG9jYXRpb259J2ApO1xuICAgIC8vcGFyYW1ldGVyQXNzZXJ0KGNoZWNraW5nT3B0aW9ucyAhPT0gdW5kZWZpbmVkLCBcImNoZWNrWUFNTFRleHQ6ICdjaGVja2luZ09wdGlvbnMnIHBhcmFtZXRlciBzaG91bGQgYmUgZGVmaW5lZFwiKTtcbiAgICBpZiAoY2hlY2tpbmdPcHRpb25zICE9PSB1bmRlZmluZWQpIHsgLy9wYXJhbWV0ZXJBc3NlcnQodHlwZW9mIGNoZWNraW5nT3B0aW9ucyA9PT0gJ29iamVjdCcsIGBjaGVja1lBTUxUZXh0OiAnY2hlY2tpbmdPcHRpb25zJyBwYXJhbWV0ZXIgc2hvdWxkIGJlIGFuIG9iamVjdCBub3QgYSAnJHt0eXBlb2YgY2hlY2tpbmdPcHRpb25zfSc6ICR7SlNPTi5zdHJpbmdpZnkoY2hlY2tpbmdPcHRpb25zKX1gKTtcbiAgICB9XG5cbiAgICBsZXQgb3VyTG9jYXRpb24gPSBnaXZlbkxvY2F0aW9uO1xuICAgIGlmIChvdXJMb2NhdGlvbiAmJiBvdXJMb2NhdGlvblswXSAhPT0gJyAnKSBvdXJMb2NhdGlvbiA9IGAgJHtvdXJMb2NhdGlvbn1gO1xuICAgIC8vIGlmICh0ZXh0TmFtZSkgb3VyTG9jYXRpb24gPSBgIGluICR7dGV4dE5hbWV9JHtvdXJMb2NhdGlvbn1gO1xuXG4gICAgbGV0IGV4Y2VycHRMZW5ndGg7XG4gICAgdHJ5IHtcbiAgICAgICAgZXhjZXJwdExlbmd0aCA9IGNoZWNraW5nT3B0aW9ucz8uZXhjZXJwdExlbmd0aDtcbiAgICB9IGNhdGNoICh5dGNFcnJvcikgeyB9XG4gICAgaWYgKHR5cGVvZiBleGNlcnB0TGVuZ3RoICE9PSAnbnVtYmVyJyB8fCBpc05hTihleGNlcnB0TGVuZ3RoKSkge1xuICAgICAgICBleGNlcnB0TGVuZ3RoID0gREVGQVVMVF9FWENFUlBUX0xFTkdUSDtcbiAgICAgICAgLy8gZGVidWdMb2coYFVzaW5nIGRlZmF1bHQgZXhjZXJwdExlbmd0aD0ke2V4Y2VycHRMZW5ndGh9YCk7XG4gICAgfVxuICAgIC8vIGVsc2VcbiAgICAvLyBkZWJ1Z0xvZyhgVXNpbmcgc3VwcGxpZWQgZXhjZXJwdExlbmd0aD0ke2V4Y2VycHRMZW5ndGh9YCwgYGNmLiBkZWZhdWx0PSR7REVGQVVMVF9FWENFUlBUX0xFTkdUSH1gKTtcbiAgICAvLyBjb25zdCBleGNlcnB0SGFsZkxlbmd0aCA9IE1hdGguZmxvb3IoZXhjZXJwdExlbmd0aCAvIDIpOyAvLyByb3VuZGVkIGRvd25cbiAgICAvLyBjb25zdCBleGNlcnB0SGFsZkxlbmd0aFBsdXMgPSBNYXRoLmZsb29yKChleGNlcnB0TGVuZ3RoKzEpIC8gMik7IC8vIHJvdW5kZWQgdXBcbiAgICAvLyBkZWJ1Z0xvZyhgVXNpbmcgZXhjZXJwdEhhbGZMZW5ndGg9JHtleGNlcnB0SGFsZkxlbmd0aH1gLCBgZXhjZXJwdEhhbGZMZW5ndGhQbHVzPSR7ZXhjZXJwdEhhbGZMZW5ndGhQbHVzfWApO1xuXG4gICAgY29uc3QgY3l0UmVzdWx0ID0geyBzdWNjZXNzTGlzdDogW10sIG5vdGljZUxpc3Q6IFtdIH07XG5cbiAgICBmdW5jdGlvbiBhZGRTdWNjZXNzTWVzc2FnZShzdWNjZXNzU3RyaW5nKSB7XG4gICAgICAgIC8vIGZ1bmN0aW9uTG9nKGBjaGVja1lBTUxUZXh0IHN1Y2Nlc3M6ICR7c3VjY2Vzc1N0cmluZ31gKTtcbiAgICAgICAgY3l0UmVzdWx0LnN1Y2Nlc3NMaXN0LnB1c2goc3VjY2Vzc1N0cmluZyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGFkZE5vdGljZShub3RpY2VPYmplY3QpIHtcbiAgICAgICAgLy8gZnVuY3Rpb25Mb2coYGNoZWNrWUFNTFRleHQgTm90aWNlOiAocHJpb3JpdHk9JHtwcmlvcml0eX0pICR7bWVzc2FnZX0ke2NoYXJhY3RlckluZGV4ID4gMCA/IGAgKGF0IGNoYXJhY3RlciAke2NoYXJhY3RlckluZGV4fSlgIDogXCJcIn0ke2V4Y2VycHQgPyBgICR7ZXhjZXJwdH1gIDogXCJcIn0ke2xvY2F0aW9ufWApO1xuICAgICAgICAvL3BhcmFtZXRlckFzc2VydChub3RpY2VPYmplY3QucHJpb3JpdHkgIT09IHVuZGVmaW5lZCwgXCJjWXQgYWRkTm90aWNlOiAncHJpb3JpdHknIHBhcmFtZXRlciBzaG91bGQgYmUgZGVmaW5lZFwiKTtcbiAgICAgICAgLy9wYXJhbWV0ZXJBc3NlcnQodHlwZW9mIG5vdGljZU9iamVjdC5wcmlvcml0eSA9PT0gJ251bWJlcicsIGBjTWFuVCBhZGROb3RpY2U6ICdwcmlvcml0eScgcGFyYW1ldGVyIHNob3VsZCBiZSBhIG51bWJlciBub3QgYSAnJHt0eXBlb2Ygbm90aWNlT2JqZWN0LnByaW9yaXR5fSc6ICR7bm90aWNlT2JqZWN0LnByaW9yaXR5fWApO1xuICAgICAgICAvL3BhcmFtZXRlckFzc2VydChub3RpY2VPYmplY3QubWVzc2FnZSAhPT0gdW5kZWZpbmVkLCBcImNZdCBhZGROb3RpY2U6ICdtZXNzYWdlJyBwYXJhbWV0ZXIgc2hvdWxkIGJlIGRlZmluZWRcIik7XG4gICAgICAgIC8vcGFyYW1ldGVyQXNzZXJ0KHR5cGVvZiBub3RpY2VPYmplY3QubWVzc2FnZSA9PT0gJ3N0cmluZycsIGBjTWFuVCBhZGROb3RpY2U6ICdtZXNzYWdlJyBwYXJhbWV0ZXIgc2hvdWxkIGJlIGEgc3RyaW5nIG5vdCBhICcke3R5cGVvZiBub3RpY2VPYmplY3QubWVzc2FnZX0nOiAke25vdGljZU9iamVjdC5tZXNzYWdlfWApO1xuICAgICAgICAvLyAvL3BhcmFtZXRlckFzc2VydChjaGFyYWN0ZXJJbmRleCE9PXVuZGVmaW5lZCwgXCJjWXQgYWRkTm90aWNlOiAnY2hhcmFjdGVySW5kZXgnIHBhcmFtZXRlciBzaG91bGQgYmUgZGVmaW5lZFwiKTtcbiAgICAgICAgaWYgKG5vdGljZU9iamVjdC5jaGFyYWN0ZXJJbmRleCkgeyAvL3BhcmFtZXRlckFzc2VydCh0eXBlb2Ygbm90aWNlT2JqZWN0LmNoYXJhY3RlckluZGV4ID09PSAnbnVtYmVyJywgYGNNYW5UIGFkZE5vdGljZTogJ2NoYXJhY3RlckluZGV4JyBwYXJhbWV0ZXIgc2hvdWxkIGJlIGEgbnVtYmVyIG5vdCBhICcke3R5cGVvZiBub3RpY2VPYmplY3QuY2hhcmFjdGVySW5kZXh9JzogJHtub3RpY2VPYmplY3QuY2hhcmFjdGVySW5kZXh9YCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gLy9wYXJhbWV0ZXJBc3NlcnQoZXhjZXJwdCE9PXVuZGVmaW5lZCwgXCJjWXQgYWRkTm90aWNlOiAnZXhjZXJwdCcgcGFyYW1ldGVyIHNob3VsZCBiZSBkZWZpbmVkXCIpO1xuICAgICAgICBpZiAobm90aWNlT2JqZWN0LmV4Y2VycHQpIHsgLy9wYXJhbWV0ZXJBc3NlcnQodHlwZW9mIG5vdGljZU9iamVjdC5leGNlcnB0ID09PSAnc3RyaW5nJywgYGNNYW5UIGFkZE5vdGljZTogJ2V4Y2VycHQnIHBhcmFtZXRlciBzaG91bGQgYmUgYSBzdHJpbmcgbm90IGEgJyR7dHlwZW9mIG5vdGljZU9iamVjdC5leGNlcnB0fSc6ICR7bm90aWNlT2JqZWN0LmV4Y2VycHR9YCk7XG4gICAgICAgIH1cbiAgICAgICAgLy9wYXJhbWV0ZXJBc3NlcnQobm90aWNlT2JqZWN0LmxvY2F0aW9uICE9PSB1bmRlZmluZWQsIFwiY1l0IGFkZE5vdGljZTogJ2xvY2F0aW9uJyBwYXJhbWV0ZXIgc2hvdWxkIGJlIGRlZmluZWRcIik7XG4gICAgICAgIC8vcGFyYW1ldGVyQXNzZXJ0KHR5cGVvZiBub3RpY2VPYmplY3QubG9jYXRpb24gPT09ICdzdHJpbmcnLCBgY1l0IGFkZE5vdGljZTogJ2xvY2F0aW9uJyBwYXJhbWV0ZXIgc2hvdWxkIGJlIGEgc3RyaW5nIG5vdCBhICcke3R5cGVvZiBub3RpY2VPYmplY3QubG9jYXRpb259JzogJHtub3RpY2VPYmplY3QubG9jYXRpb259YCk7XG4gICAgICAgIGlmIChub3RpY2VPYmplY3QuZGVidWdDaGFpbikgbm90aWNlT2JqZWN0LmRlYnVnQ2hhaW4gPSBgY2hlY2tZQU1MVGV4dCAke25vdGljZU9iamVjdC5kZWJ1Z0NoYWlufWA7XG4gICAgICAgIGN5dFJlc3VsdC5ub3RpY2VMaXN0LnB1c2gobm90aWNlT2JqZWN0KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBvdXJDaGVja1RleHRGaWVsZChsaW5lTnVtYmVyLCBmaWVsZFRleHQsIGFsbG93ZWRMaW5rcywgb3B0aW9uYWxGaWVsZExvY2F0aW9uLCBjaGVja2luZ09wdGlvbnMpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICogQGRlc2NyaXB0aW9uIC0gY2hlY2tzIHRoZSBnaXZlbiB0ZXh0IGZpZWxkIGFuZCBwcm9jZXNzZXMgdGhlIHJldHVybmVkIHJlc3VsdHNcbiAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gZmllbGROYW1lIC0gbmFtZSBvZiB0aGUgZmllbGQgYmVpbmcgY2hlY2tlZFxuICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBmaWVsZFRleHQgLSB0aGUgYWN0dWFsIHRleHQgb2YgdGhlIGZpZWxkIGJlaW5nIGNoZWNrZWRcbiAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGFsbG93ZWRMaW5rcyAtIHRydWUgaWYgbGlua3MgYXJlIGFsbG93ZWQgaW4gdGhlIGZpZWxkLCBvdGhlcndpc2UgZmFsc2VcbiAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9uYWxGaWVsZExvY2F0aW9uIC0gZGVzY3JpcHRpb24gb2Ygd2hlcmUgdGhlIGZpZWxkIGlzIGxvY2F0ZWRcbiAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gY2hlY2tpbmdPcHRpb25zIC0gcGFyYW1ldGVycyB0aGF0IG1pZ2h0IGFmZmVjdCB0aGUgY2hlY2tcbiAgICAgICAgKi9cbiAgICAgICAgLy8gRG9lcyBiYXNpYyBjaGVja3MgZm9yIHNtYWxsIGVycm9ycyBsaWtlIGxlYWRpbmcvdHJhaWxpbmcgc3BhY2VzLCBldGMuXG5cbiAgICAgICAgLy8gV2UgYXNzdW1lIHRoYXQgY2hlY2tpbmcgZm9yIGNvbXB1bHNvcnkgZmllbGRzIGlzIGRvbmUgZWxzZXdoZXJlXG5cbiAgICAgICAgLy8gVXBkYXRlcyB0aGUgZ2xvYmFsIGxpc3Qgb2Ygbm90aWNlc1xuICAgICAgICAvLyBkZWJ1Z0xvZyhgY1l0IG91ckNoZWNrVGV4dEZpZWxkKCR7ZmllbGROYW1lfSwgKCR7ZmllbGRUZXh0Lmxlbmd0aH0pLCAke2FsbG93ZWRMaW5rc30sICR7ZmllbGRMb2NhdGlvbn0sIOKApilgKTtcbiAgICAgICAgLy9wYXJhbWV0ZXJBc3NlcnQoZmllbGRUZXh0ICE9PSB1bmRlZmluZWQsIFwiY1l0IG91ckNoZWNrVGV4dEZpZWxkOiAnZmllbGRUZXh0JyBwYXJhbWV0ZXIgc2hvdWxkIGJlIGRlZmluZWRcIik7XG4gICAgICAgIC8vcGFyYW1ldGVyQXNzZXJ0KHR5cGVvZiBmaWVsZFRleHQgPT09ICdzdHJpbmcnLCBgY1l0IG91ckNoZWNrVGV4dEZpZWxkOiAnZmllbGRUZXh0JyBwYXJhbWV0ZXIgc2hvdWxkIGJlIGEgc3RyaW5nIG5vdCBhICcke3R5cGVvZiBmaWVsZFRleHR9J2ApO1xuICAgICAgICAvL3BhcmFtZXRlckFzc2VydChhbGxvd2VkTGlua3MgPT09IHRydWUgfHwgYWxsb3dlZExpbmtzID09PSBmYWxzZSwgXCJjWXQgb3VyQ2hlY2tUZXh0RmllbGQ6IGFsbG93ZWRMaW5rcyBwYXJhbWV0ZXIgbXVzdCBiZSBlaXRoZXIgdHJ1ZSBvciBmYWxzZVwiKTtcbiAgICAgICAgLy9wYXJhbWV0ZXJBc3NlcnQob3B0aW9uYWxGaWVsZExvY2F0aW9uICE9PSB1bmRlZmluZWQsIFwiY1l0IG91ckNoZWNrVGV4dEZpZWxkOiAnb3B0aW9uYWxGaWVsZExvY2F0aW9uJyBwYXJhbWV0ZXIgc2hvdWxkIGJlIGRlZmluZWRcIik7XG4gICAgICAgIC8vcGFyYW1ldGVyQXNzZXJ0KHR5cGVvZiBvcHRpb25hbEZpZWxkTG9jYXRpb24gPT09ICdzdHJpbmcnLCBgY1l0IG91ckNoZWNrVGV4dEZpZWxkOiAnb3B0aW9uYWxGaWVsZExvY2F0aW9uJyBwYXJhbWV0ZXIgc2hvdWxkIGJlIGEgc3RyaW5nIG5vdCBhICcke3R5cGVvZiBvcHRpb25hbEZpZWxkTG9jYXRpb259J2ApO1xuXG4gICAgICAgIGNvbnN0IHJlc3VsdE9iamVjdCA9IGNoZWNrVGV4dEZpZWxkKGxhbmd1YWdlQ29kZSwgcmVwb0NvZGUsICdZQU1MJywgJycsIGZpZWxkVGV4dCwgYWxsb3dlZExpbmtzLCBvcHRpb25hbEZpZWxkTG9jYXRpb24sIGNoZWNraW5nT3B0aW9ucyk7XG5cbiAgICAgICAgLy8gQ29uY2F0IGlzIGZhc3RlciBpZiB3ZSBkb27igJl0IG5lZWQgdG8gcHJvY2VzcyBlYWNoIG5vdGljZSBpbmRpdmlkdWFsbHlcbiAgICAgICAgLy8gY3l0UmVzdWx0Lm5vdGljZUxpc3QgPSBjeXRSZXN1bHQubm90aWNlTGlzdC5jb25jYXQocmVzdWx0T2JqZWN0Lm5vdGljZUxpc3QpO1xuICAgICAgICAvLyAvLyBQcm9jZXNzIG5vdGljZUxpc3QgbGluZSBieSBsaW5lXG4gICAgICAgIC8vIC8vICBzdXBwcmVzc2luZyB1bmRlc2lyZWQgZXJyb3JzXG4gICAgICAgIGZvciAoY29uc3Qgbm90aWNlRW50cnkgb2YgcmVzdWx0T2JqZWN0Lm5vdGljZUxpc3QpXG4gICAgICAgICAgICBhZGROb3RpY2UoeyAuLi5ub3RpY2VFbnRyeSwgbGluZU51bWJlciB9KTtcbiAgICB9XG4gICAgLy8gZW5kIG9mIG91ckNoZWNrVGV4dEZpZWxkIGZ1bmN0aW9uXG5cbiAgICBmdW5jdGlvbiBjaGVja1lBTUxMaW5lQ29udGVudHMobGluZU51bWJlciwgbGluZVRleHQsIGxpbmVMb2NhdGlvbikge1xuXG4gICAgICAgIC8vIGZ1bmN0aW9uTG9nKGBjaGVja1lBTUxMaW5lQ29udGVudHMgZm9yICcke2xpbmVOdW1iZXJ9ICR7bGluZVRleHR9JyBhdCR7bGluZUxvY2F0aW9ufWApO1xuICAgICAgICBsZXQgdGhpc1RleHQgPSBsaW5lVGV4dFxuXG4gICAgICAgIC8vIFJlbW92ZSBsZWFkaW5nIHNwYWNlc1xuICAgICAgICB0aGlzVGV4dCA9IHRoaXNUZXh0LnJlcGxhY2UoL14gKy9nLCAnJylcbiAgICAgICAgLy8gZGVidWdMb2coYEFmdGVyIHJlbW92aW5nIGxlYWRpbmcgc3BhY2VzIGhhdmUgJyR7dGhpc1RleHR9J2ApO1xuXG4gICAgICAgIC8vIFJlbW92ZSBsZWFkaW5nIGh5cGhlbnNcbiAgICAgICAgdGhpc1RleHQgPSB0aGlzVGV4dC5yZXBsYWNlKC9eLS9nLCAnJylcbiAgICAgICAgLy8gZGVidWdMb2coYEFmdGVyIHJlbW92aW5nIGh5cGhlbnMgaGF2ZSAnJHt0aGlzVGV4dH0nYCk7XG5cbiAgICAgICAgLy8gUmVtb3ZlIGxlYWRpbmcgc3BhY2VzIGFnYWluIG5vd1xuICAgICAgICB0aGlzVGV4dCA9IHRoaXNUZXh0LnJlcGxhY2UoL14gKy9nLCAnJylcbiAgICAgICAgLy8gZGVidWdMb2coYEFmdGVyIHJlbW92aW5nIG1vcmUgbGVhZGluZyBzcGFjZXMgaGF2ZSAnJHt0aGlzVGV4dH0nYCk7XG5cbiAgICAgICAgY29uc3QgYWxsb3dlZExpbmtzSW5MaW5lID0gdGhpc1RleHQuc3RhcnRzV2l0aCgndXJsOicpIHx8IHRoaXNUZXh0LnN0YXJ0c1dpdGgoJ2NoYXB0ZXJfdXJsOicpIHx8IHRoaXNUZXh0LnN0YXJ0c1dpdGgoJ3JjOicpO1xuICAgICAgICBpZiAodGhpc1RleHQpXG4gICAgICAgICAgICBvdXJDaGVja1RleHRGaWVsZChsaW5lTnVtYmVyLCB0aGlzVGV4dCwgYWxsb3dlZExpbmtzSW5MaW5lLCBsaW5lTG9jYXRpb24sIGNoZWNraW5nT3B0aW9ucyk7XG4gICAgfVxuICAgIC8vIGVuZCBvZiBjaGVja1lBTUxMaW5lIGZ1bmN0aW9uXG5cblxuICAgIGZ1bmN0aW9uIG91ckJhc2ljRmlsZUNoZWNrcyhmaWxlbmFtZSwgZmlsZVRleHQsIGZpbGVMb2NhdGlvbiwgY2hlY2tpbmdPcHRpb25zKSB7XG4gICAgICAgIC8vIERvZXMgYmFzaWMgY2hlY2tzIGZvciBzbWFsbCBlcnJvcnMgbGlrZSBsZWFkaW5nL3RyYWlsaW5nIHNwYWNlcywgZXRjLlxuXG4gICAgICAgIC8vIFdlIGFzc3VtZSB0aGF0IGNoZWNraW5nIGZvciBjb21wdWxzb3J5IGZpZWxkcyBpcyBkb25lIGVsc2V3aGVyZVxuXG4gICAgICAgIC8vIFVwZGF0ZXMgdGhlIGdsb2JhbCBsaXN0IG9mIG5vdGljZXNcbiAgICAgICAgLy9wYXJhbWV0ZXJBc3NlcnQoZmlsZW5hbWUgIT09IHVuZGVmaW5lZCwgXCJjWVQgb3VyQmFzaWNGaWxlQ2hlY2tzOiAnZmlsZW5hbWUnIHBhcmFtZXRlciBzaG91bGQgYmUgZGVmaW5lZFwiKTtcbiAgICAgICAgLy9wYXJhbWV0ZXJBc3NlcnQodHlwZW9mIGZpbGVuYW1lID09PSAnc3RyaW5nJywgYGNZVCBvdXJCYXNpY0ZpbGVDaGVja3M6ICdmaWxlbmFtZScgcGFyYW1ldGVyIHNob3VsZCBiZSBhIHN0cmluZyBub3QgYSAnJHt0eXBlb2YgZmlsZW5hbWV9J2ApO1xuICAgICAgICAvL3BhcmFtZXRlckFzc2VydChmaWxlVGV4dCAhPT0gdW5kZWZpbmVkLCBcImNZVCBvdXJCYXNpY0ZpbGVDaGVja3M6ICdmaWxlVGV4dCcgcGFyYW1ldGVyIHNob3VsZCBiZSBkZWZpbmVkXCIpO1xuICAgICAgICAvL3BhcmFtZXRlckFzc2VydCh0eXBlb2YgZmlsZVRleHQgPT09ICdzdHJpbmcnLCBgY1lUIG91ckJhc2ljRmlsZUNoZWNrczogJ2ZpbGVUZXh0JyBwYXJhbWV0ZXIgc2hvdWxkIGJlIGEgc3RyaW5nIG5vdCBhICcke3R5cGVvZiBmaWxlVGV4dH0nYCk7XG4gICAgICAgIC8vcGFyYW1ldGVyQXNzZXJ0KGNoZWNraW5nT3B0aW9ucyAhPT0gdW5kZWZpbmVkLCBcImNZVCBvdXJCYXNpY0ZpbGVDaGVja3M6ICdjaGVja2luZ09wdGlvbnMnIHBhcmFtZXRlciBzaG91bGQgYmUgZGVmaW5lZFwiKTtcblxuICAgICAgICBjb25zdCByZXN1bHRPYmplY3QgPSBjaGVja1RleHRmaWxlQ29udGVudHMobGFuZ3VhZ2VDb2RlLCByZXBvQ29kZSwgJ1lBTUwnLCBmaWxlbmFtZSwgZmlsZVRleHQsIGZpbGVMb2NhdGlvbiwgY2hlY2tpbmdPcHRpb25zKTtcblxuICAgICAgICAvLyBJZiB3ZSBuZWVkIHRvIHB1dCBldmVyeXRoaW5nIHRocm91Z2ggYWRkTm90aWNlUGFydGlhbCwgZS5nLiwgZm9yIGRlYnVnZ2luZyBvciBmaWx0ZXJpbmdcbiAgICAgICAgLy8gIHByb2Nlc3MgcmVzdWx0cyBsaW5lIGJ5IGxpbmVcbiAgICAgICAgZm9yIChjb25zdCBub3RpY2VFbnRyeSBvZiByZXN1bHRPYmplY3Qubm90aWNlTGlzdCkge1xuICAgICAgICAgICAgLy9wYXJhbWV0ZXJBc3NlcnQoT2JqZWN0LmtleXMobm90aWNlRW50cnkpLmxlbmd0aCA+PSA1LCBgVVNGTSBvdXJCYXNpY0ZpbGVDaGVja3Mgbm90aWNlIGxlbmd0aD0ke09iamVjdC5rZXlzKG5vdGljZUVudHJ5KS5sZW5ndGh9YCk7XG4gICAgICAgICAgICBhZGROb3RpY2Uobm90aWNlRW50cnkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIGVuZCBvZiBvdXJCYXNpY0ZpbGVDaGVja3MgZnVuY3Rpb25cblxuXG4gICAgLy8gTWFpbiBjb2RlIGZvciBjaGVja1lBTUxUZXh0IGZ1bmN0aW9uXG4gICAgY29uc3QgbGluZXMgPSBZQU1MVGV4dC5zcGxpdCgnXFxuJyk7XG4gICAgLy8gZGVidWdMb2coYCAgJyR7bG9jYXRpb259JyBoYXMgJHtsaW5lcy5sZW5ndGgudG9Mb2NhbGVTdHJpbmcoKX0gdG90YWwgbGluZXNgKTtcbiAgICBsZXQgZm9ybURhdGE7XG4gICAgdHJ5IHtcbiAgICAgICAgZm9ybURhdGEgPSB5YW1sLnBhcnNlKFlBTUxUZXh0KTtcbiAgICAgICAgLy8gZGVidWdMb2coXCJ5YW1sLnBhcnNlKFlBTUxUZXh0KSBnb3QgZm9ybURhdGFcIiwgSlNPTi5zdHJpbmdpZnkoZm9ybURhdGEpKTtcbiAgICB9XG4gICAgY2F0Y2ggKHlhbWxFcnJvcikge1xuICAgICAgICAvLyBjb25zb2xlLmVycm9yKGB5YW1sIHBhcnNlIGVycm9yOiAke3lhbWxFcnJvci5tZXNzYWdlfWApO1xuICAgICAgICBhZGROb3RpY2UoeyBwcmlvcml0eTogOTIwLCBtZXNzYWdlOiB5YW1sRXJyb3IubWVzc2FnZSwgbG9jYXRpb246IG91ckxvY2F0aW9uIH0pXG4gICAgfVxuICAgIC8vIEFkZCB0aGUgcGFyc2VkIFlBTUwgdG8gb3VyIHJlc3VsdFxuICAgIGN5dFJlc3VsdC5mb3JtRGF0YSA9IGZvcm1EYXRhO1xuXG4gICAgLy8gbGV0IGxhc3ROdW1MZWFkaW5nU3BhY2VzID0gMDtcbiAgICAvLyBsZXQgbGFzdExpbmVDb250ZW50cztcbiAgICBmb3IgKGxldCBuID0gMTsgbiA8PSBsaW5lcy5sZW5ndGg7IG4rKykge1xuXG4gICAgICAgIGNvbnN0IGxpbmUgPSBsaW5lc1tuIC0gMV07XG4gICAgICAgIC8vIGxldCBudW1MZWFkaW5nU3BhY2VzO1xuICAgICAgICAvLyBpZiAobGluZSkge1xuICAgICAgICAvLyAgICAgbnVtTGVhZGluZ1NwYWNlcyA9IGxpbmUubWF0Y2goL14gKi8pWzBdLmxlbmd0aDtcbiAgICAgICAgLy8gZGVidWdMb2coYEdvdCBudW1MZWFkaW5nU3BhY2VzPSR7bnVtTGVhZGluZ1NwYWNlc30gZm9yICR7bGluZX0ke2F0U3RyaW5nfWApO1xuICAgICAgICAvLyAgICAgaWYgKG51bUxlYWRpbmdTcGFjZXMgJiYgbGFzdE51bUxlYWRpbmdTcGFjZXMgJiYgbnVtTGVhZGluZ1NwYWNlcyE9bGFzdE51bUxlYWRpbmdTcGFjZXMpXG4gICAgICAgIC8vICAgICAgICAgYWRkTm90aWNlKHs0NzIsIFwiTmVzdGluZyBzZWVtcyBjb25mdXNlZFwiLCAwLCAnJywgYXRTdHJpbmcpO1xuXG4gICAgICAgIGNoZWNrWUFNTExpbmVDb250ZW50cyhuLCBsaW5lLCBvdXJMb2NhdGlvbik7XG4gICAgICAgIC8vIH0gZWxzZSB7XG4gICAgICAgIC8vICAgICAvLyBUaGlzIGlzIGEgYmxhbmsgbGluZVxuICAgICAgICAvLyAgICAgbnVtTGVhZGluZ1NwYWNlcyA9IDA7XG4gICAgICAgIC8vIH1cblxuICAgICAgICAvLyBsYXN0TGluZUNvbnRlbnRzID0gbGluZTtcbiAgICAgICAgLy8gbGFzdE51bUxlYWRpbmdTcGFjZXMgPSBudW1MZWFkaW5nU3BhY2VzO1xuICAgIH1cblxuICAgIC8vIERvIGJhc2ljIGZpbGUgY2hlY2tzXG4gICAgb3VyQmFzaWNGaWxlQ2hlY2tzKHRleHROYW1lLCBZQU1MVGV4dCwgZ2l2ZW5Mb2NhdGlvbiwgY2hlY2tpbmdPcHRpb25zKTtcblxuICAgIGlmICghY2hlY2tpbmdPcHRpb25zPy5zdXBwcmVzc05vdGljZURpc2FibGluZ0ZsYWcpIHtcbiAgICAgICAgLy8gZnVuY3Rpb25Mb2coYGNoZWNrWUFNTFRleHQ6IGNhbGxpbmcgcmVtb3ZlRGlzYWJsZWROb3RpY2VzKCR7Y3l0UmVzdWx0Lm5vdGljZUxpc3QubGVuZ3RofSkgaGF2aW5nICR7SlNPTi5zdHJpbmdpZnkoY2hlY2tpbmdPcHRpb25zKX1gKTtcbiAgICAgICAgY3l0UmVzdWx0Lm5vdGljZUxpc3QgPSByZW1vdmVEaXNhYmxlZE5vdGljZXMoY3l0UmVzdWx0Lm5vdGljZUxpc3QpO1xuICAgIH1cblxuICAgIGFkZFN1Y2Nlc3NNZXNzYWdlKGBDaGVja2VkIGFsbCAke2xpbmVzLmxlbmd0aC50b0xvY2FsZVN0cmluZygpfSBsaW5lJHtsaW5lcy5sZW5ndGggPT09IDEgPyAnJyA6ICdzJ30ke291ckxvY2F0aW9ufS5gKTtcbiAgICBpZiAoY3l0UmVzdWx0Lm5vdGljZUxpc3QubGVuZ3RoKVxuICAgICAgICBhZGRTdWNjZXNzTWVzc2FnZShgY2hlY2tZQU1MVGV4dCB2JHtZQU1MX1ZBTElEQVRPUl9WRVJTSU9OX1NUUklOR30gZmluaXNoZWQgd2l0aCAke2N5dFJlc3VsdC5ub3RpY2VMaXN0Lmxlbmd0aCA/IGN5dFJlc3VsdC5ub3RpY2VMaXN0Lmxlbmd0aC50b0xvY2FsZVN0cmluZygpIDogXCJ6ZXJvXCJ9IG5vdGljZSR7Y3l0UmVzdWx0Lm5vdGljZUxpc3QubGVuZ3RoID09PSAxID8gJycgOiAncyd9YCk7XG4gICAgZWxzZVxuICAgICAgICBhZGRTdWNjZXNzTWVzc2FnZShgTm8gZXJyb3JzIG9yIHdhcm5pbmdzIGZvdW5kIGJ5IGNoZWNrWUFNTFRleHQgdiR7WUFNTF9WQUxJREFUT1JfVkVSU0lPTl9TVFJJTkd9YClcbiAgICAvLyBkZWJ1Z0xvZyhgICBjaGVja1lBTUxUZXh0IHJldHVybmluZyB3aXRoICR7Y3l0UmVzdWx0LnN1Y2Nlc3NMaXN0Lmxlbmd0aC50b0xvY2FsZVN0cmluZygpfSBzdWNjZXNzKGVzKSwgJHtjeXRSZXN1bHQubm90aWNlTGlzdC5sZW5ndGgudG9Mb2NhbGVTdHJpbmcoKX0gbm90aWNlKHMpLmApO1xuICAgIC8vIGRlYnVnTG9nKFwiY2hlY2tZQU1MVGV4dCByZXN1bHQgaXNcIiwgSlNPTi5zdHJpbmdpZnkocmVzdWx0KSk7XG4gICAgcmV0dXJuIGN5dFJlc3VsdDtcbn1cbi8vIGVuZCBvZiBjaGVja1lBTUxUZXh0IGZ1bmN0aW9uXG4iXX0=