"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _react = _interopRequireWildcard(require("react"));

var _propTypes = _interopRequireDefault(require("prop-types"));

var _styles = require("@material-ui/core/styles");

var _core = require("@material-ui/core");

var _blockEditable = _interopRequireDefault(require("../block-editable"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function BlockTranslatable(_ref) {
  var original = _ref.original,
      translation = _ref.translation,
      onTranslation = _ref.onTranslation,
      inputFilters = _ref.inputFilters,
      outputFilters = _ref.outputFilters,
      style = _ref.style,
      preview = _ref.preview;
  var classes = useStyles();
  var originalBlock = (0, _react.useMemo)(function () {
    return /*#__PURE__*/_react.default.createElement(_blockEditable.default, {
      markdown: original,
      inputFilters: inputFilters,
      outputFilters: outputFilters,
      preview: preview,
      editable: false
    });
  }, [original, inputFilters, outputFilters, preview]);
  var translationBlock = (0, _react.useMemo)(function () {
    return /*#__PURE__*/_react.default.createElement(_blockEditable.default, {
      markdown: translation,
      onEdit: onTranslation,
      inputFilters: inputFilters,
      outputFilters: outputFilters,
      preview: preview,
      editable: true
    });
  }, [translation, onTranslation, inputFilters, outputFilters, preview]);
  return /*#__PURE__*/_react.default.createElement(_core.Grid, {
    container: true,
    wrap: "nowrap",
    spacing: 0,
    className: classes.root,
    style: style
  }, /*#__PURE__*/_react.default.createElement(_core.Grid, {
    item: true,
    xs: 12,
    className: classes.original
  }, originalBlock), /*#__PURE__*/_react.default.createElement(_core.Grid, {
    item: true,
    xs: 12,
    className: classes.translation
  }, translationBlock));
}

;
BlockTranslatable.propTypes = {
  /** Original markdown for the editor. */
  original: _propTypes.default.string.isRequired,

  /** Translation markdown for the editor. */
  translation: _propTypes.default.string.isRequired,

  /** Function to propogate changes to the translation. */
  onTranslation: _propTypes.default.func.isRequired,

  /** Replace strings before rendering. */
  inputFilters: _propTypes.default.array,

  /** Replace strings after editing. */
  outputFilters: _propTypes.default.array,

  /** CSS for the component. */
  style: _propTypes.default.object,

  /** Display Raw Markdown or HTML. */
  preview: _propTypes.default.bool
};
BlockTranslatable.defaultProps = {
  original: '',
  translation: '',
  inputFilters: [],
  outputFilters: [],
  style: {},
  preview: true
};
var useStyles = (0, _styles.makeStyles)(function (theme) {
  return {
    root: {},
    original: {
      background: '#eee4'
    },
    translation: {}
  };
});
var _default = BlockTranslatable;
exports.default = _default;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9jb21wb25lbnRzL2Jsb2NrLXRyYW5zbGF0YWJsZS9CbG9ja1RyYW5zbGF0YWJsZS5qcyJdLCJuYW1lcyI6WyJCbG9ja1RyYW5zbGF0YWJsZSIsIm9yaWdpbmFsIiwidHJhbnNsYXRpb24iLCJvblRyYW5zbGF0aW9uIiwiaW5wdXRGaWx0ZXJzIiwib3V0cHV0RmlsdGVycyIsInN0eWxlIiwicHJldmlldyIsImNsYXNzZXMiLCJ1c2VTdHlsZXMiLCJvcmlnaW5hbEJsb2NrIiwidHJhbnNsYXRpb25CbG9jayIsInJvb3QiLCJwcm9wVHlwZXMiLCJQcm9wVHlwZXMiLCJzdHJpbmciLCJpc1JlcXVpcmVkIiwiZnVuYyIsImFycmF5Iiwib2JqZWN0IiwiYm9vbCIsImRlZmF1bHRQcm9wcyIsInRoZW1lIiwiYmFja2dyb3VuZCJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUE7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7Ozs7Ozs7O0FBRUEsU0FBU0EsaUJBQVQsT0FRRztBQUFBLE1BUERDLFFBT0MsUUFQREEsUUFPQztBQUFBLE1BTkRDLFdBTUMsUUFOREEsV0FNQztBQUFBLE1BTERDLGFBS0MsUUFMREEsYUFLQztBQUFBLE1BSkRDLFlBSUMsUUFKREEsWUFJQztBQUFBLE1BSERDLGFBR0MsUUFIREEsYUFHQztBQUFBLE1BRkRDLEtBRUMsUUFGREEsS0FFQztBQUFBLE1BRERDLE9BQ0MsUUFEREEsT0FDQztBQUNELE1BQU1DLE9BQU8sR0FBR0MsU0FBUyxFQUF6QjtBQUVBLE1BQU1DLGFBQWEsR0FBRyxvQkFBUTtBQUFBLHdCQUM1Qiw2QkFBQyxzQkFBRDtBQUNFLE1BQUEsUUFBUSxFQUFFVCxRQURaO0FBRUUsTUFBQSxZQUFZLEVBQUVHLFlBRmhCO0FBR0UsTUFBQSxhQUFhLEVBQUVDLGFBSGpCO0FBSUUsTUFBQSxPQUFPLEVBQUVFLE9BSlg7QUFLRSxNQUFBLFFBQVEsRUFBRTtBQUxaLE1BRDRCO0FBQUEsR0FBUixFQVFuQixDQUFDTixRQUFELEVBQVdHLFlBQVgsRUFBeUJDLGFBQXpCLEVBQXdDRSxPQUF4QyxDQVJtQixDQUF0QjtBQVVBLE1BQU1JLGdCQUFnQixHQUFHLG9CQUFRO0FBQUEsd0JBQy9CLDZCQUFDLHNCQUFEO0FBQ0UsTUFBQSxRQUFRLEVBQUVULFdBRFo7QUFFRSxNQUFBLE1BQU0sRUFBRUMsYUFGVjtBQUdFLE1BQUEsWUFBWSxFQUFFQyxZQUhoQjtBQUlFLE1BQUEsYUFBYSxFQUFFQyxhQUpqQjtBQUtFLE1BQUEsT0FBTyxFQUFFRSxPQUxYO0FBTUUsTUFBQSxRQUFRLEVBQUU7QUFOWixNQUQrQjtBQUFBLEdBQVIsRUFTdEIsQ0FBQ0wsV0FBRCxFQUFjQyxhQUFkLEVBQTZCQyxZQUE3QixFQUEyQ0MsYUFBM0MsRUFBMERFLE9BQTFELENBVHNCLENBQXpCO0FBV0Esc0JBQ0UsNkJBQUMsVUFBRDtBQUNFLElBQUEsU0FBUyxNQURYO0FBRUUsSUFBQSxJQUFJLEVBQUMsUUFGUDtBQUdFLElBQUEsT0FBTyxFQUFFLENBSFg7QUFJRSxJQUFBLFNBQVMsRUFBRUMsT0FBTyxDQUFDSSxJQUpyQjtBQUtFLElBQUEsS0FBSyxFQUFFTjtBQUxULGtCQU9FLDZCQUFDLFVBQUQ7QUFBTSxJQUFBLElBQUksTUFBVjtBQUFXLElBQUEsRUFBRSxFQUFFLEVBQWY7QUFBbUIsSUFBQSxTQUFTLEVBQUVFLE9BQU8sQ0FBQ1A7QUFBdEMsS0FDR1MsYUFESCxDQVBGLGVBVUUsNkJBQUMsVUFBRDtBQUFNLElBQUEsSUFBSSxNQUFWO0FBQVcsSUFBQSxFQUFFLEVBQUUsRUFBZjtBQUFtQixJQUFBLFNBQVMsRUFBRUYsT0FBTyxDQUFDTjtBQUF0QyxLQUNHUyxnQkFESCxDQVZGLENBREY7QUFnQkQ7O0FBQUE7QUFFRFgsaUJBQWlCLENBQUNhLFNBQWxCLEdBQThCO0FBQzVCO0FBQ0FaLEVBQUFBLFFBQVEsRUFBRWEsbUJBQVVDLE1BQVYsQ0FBaUJDLFVBRkM7O0FBRzVCO0FBQ0FkLEVBQUFBLFdBQVcsRUFBRVksbUJBQVVDLE1BQVYsQ0FBaUJDLFVBSkY7O0FBSzVCO0FBQ0FiLEVBQUFBLGFBQWEsRUFBRVcsbUJBQVVHLElBQVYsQ0FBZUQsVUFORjs7QUFPNUI7QUFDQVosRUFBQUEsWUFBWSxFQUFFVSxtQkFBVUksS0FSSTs7QUFTNUI7QUFDQWIsRUFBQUEsYUFBYSxFQUFFUyxtQkFBVUksS0FWRzs7QUFXNUI7QUFDQVosRUFBQUEsS0FBSyxFQUFFUSxtQkFBVUssTUFaVzs7QUFhNUI7QUFDQVosRUFBQUEsT0FBTyxFQUFFTyxtQkFBVU07QUFkUyxDQUE5QjtBQWlCQXBCLGlCQUFpQixDQUFDcUIsWUFBbEIsR0FBaUM7QUFDL0JwQixFQUFBQSxRQUFRLEVBQUUsRUFEcUI7QUFFL0JDLEVBQUFBLFdBQVcsRUFBRSxFQUZrQjtBQUcvQkUsRUFBQUEsWUFBWSxFQUFFLEVBSGlCO0FBSS9CQyxFQUFBQSxhQUFhLEVBQUUsRUFKZ0I7QUFLL0JDLEVBQUFBLEtBQUssRUFBRSxFQUx3QjtBQU0vQkMsRUFBQUEsT0FBTyxFQUFFO0FBTnNCLENBQWpDO0FBU0EsSUFBTUUsU0FBUyxHQUFHLHdCQUFXLFVBQUFhLEtBQUs7QUFBQSxTQUFLO0FBQ3JDVixJQUFBQSxJQUFJLEVBQUUsRUFEK0I7QUFHckNYLElBQUFBLFFBQVEsRUFBRTtBQUNSc0IsTUFBQUEsVUFBVSxFQUFFO0FBREosS0FIMkI7QUFNckNyQixJQUFBQSxXQUFXLEVBQUU7QUFOd0IsR0FBTDtBQUFBLENBQWhCLENBQWxCO2VBVWVGLGlCIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFJlYWN0LCB7dXNlQ2FsbGJhY2ssIHVzZU1lbW99IGZyb20gJ3JlYWN0JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQge21ha2VTdHlsZXN9IGZyb20gJ0BtYXRlcmlhbC11aS9jb3JlL3N0eWxlcyc7XG5pbXBvcnQge0dyaWR9IGZyb20gJ0BtYXRlcmlhbC11aS9jb3JlJztcbmltcG9ydCBCbG9ja0VkaXRhYmxlIGZyb20gJy4uL2Jsb2NrLWVkaXRhYmxlJztcblxuZnVuY3Rpb24gQmxvY2tUcmFuc2xhdGFibGUoe1xuICBvcmlnaW5hbCxcbiAgdHJhbnNsYXRpb24sXG4gIG9uVHJhbnNsYXRpb24sXG4gIGlucHV0RmlsdGVycyxcbiAgb3V0cHV0RmlsdGVycyxcbiAgc3R5bGUsXG4gIHByZXZpZXcsXG59KSB7XG4gIGNvbnN0IGNsYXNzZXMgPSB1c2VTdHlsZXMoKTtcblxuICBjb25zdCBvcmlnaW5hbEJsb2NrID0gdXNlTWVtbygoKSA9PiAoXG4gICAgPEJsb2NrRWRpdGFibGVcbiAgICAgIG1hcmtkb3duPXtvcmlnaW5hbH1cbiAgICAgIGlucHV0RmlsdGVycz17aW5wdXRGaWx0ZXJzfVxuICAgICAgb3V0cHV0RmlsdGVycz17b3V0cHV0RmlsdGVyc31cbiAgICAgIHByZXZpZXc9e3ByZXZpZXd9XG4gICAgICBlZGl0YWJsZT17ZmFsc2V9XG4gICAgLz5cbiAgKSwgW29yaWdpbmFsLCBpbnB1dEZpbHRlcnMsIG91dHB1dEZpbHRlcnMsIHByZXZpZXddKTtcblxuICBjb25zdCB0cmFuc2xhdGlvbkJsb2NrID0gdXNlTWVtbygoKSA9PiAoXG4gICAgPEJsb2NrRWRpdGFibGVcbiAgICAgIG1hcmtkb3duPXt0cmFuc2xhdGlvbn1cbiAgICAgIG9uRWRpdD17b25UcmFuc2xhdGlvbn1cbiAgICAgIGlucHV0RmlsdGVycz17aW5wdXRGaWx0ZXJzfVxuICAgICAgb3V0cHV0RmlsdGVycz17b3V0cHV0RmlsdGVyc31cbiAgICAgIHByZXZpZXc9e3ByZXZpZXd9XG4gICAgICBlZGl0YWJsZT17dHJ1ZX1cbiAgICAvPlxuICApLCBbdHJhbnNsYXRpb24sIG9uVHJhbnNsYXRpb24sIGlucHV0RmlsdGVycywgb3V0cHV0RmlsdGVycywgcHJldmlld10pO1xuXG4gIHJldHVybiAoXG4gICAgPEdyaWRcbiAgICAgIGNvbnRhaW5lclxuICAgICAgd3JhcD1cIm5vd3JhcFwiXG4gICAgICBzcGFjaW5nPXswfVxuICAgICAgY2xhc3NOYW1lPXtjbGFzc2VzLnJvb3R9XG4gICAgICBzdHlsZT17c3R5bGV9XG4gICAgPlxuICAgICAgPEdyaWQgaXRlbSB4cz17MTJ9IGNsYXNzTmFtZT17Y2xhc3Nlcy5vcmlnaW5hbH0+XG4gICAgICAgIHtvcmlnaW5hbEJsb2NrfVxuICAgICAgPC9HcmlkPlxuICAgICAgPEdyaWQgaXRlbSB4cz17MTJ9IGNsYXNzTmFtZT17Y2xhc3Nlcy50cmFuc2xhdGlvbn0+XG4gICAgICAgIHt0cmFuc2xhdGlvbkJsb2NrfVxuICAgICAgPC9HcmlkPlxuICAgIDwvR3JpZD5cbiAgKTtcbn07XG5cbkJsb2NrVHJhbnNsYXRhYmxlLnByb3BUeXBlcyA9IHtcbiAgLyoqIE9yaWdpbmFsIG1hcmtkb3duIGZvciB0aGUgZWRpdG9yLiAqL1xuICBvcmlnaW5hbDogUHJvcFR5cGVzLnN0cmluZy5pc1JlcXVpcmVkLFxuICAvKiogVHJhbnNsYXRpb24gbWFya2Rvd24gZm9yIHRoZSBlZGl0b3IuICovXG4gIHRyYW5zbGF0aW9uOiBQcm9wVHlwZXMuc3RyaW5nLmlzUmVxdWlyZWQsXG4gIC8qKiBGdW5jdGlvbiB0byBwcm9wb2dhdGUgY2hhbmdlcyB0byB0aGUgdHJhbnNsYXRpb24uICovXG4gIG9uVHJhbnNsYXRpb246IFByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWQsXG4gIC8qKiBSZXBsYWNlIHN0cmluZ3MgYmVmb3JlIHJlbmRlcmluZy4gKi9cbiAgaW5wdXRGaWx0ZXJzOiBQcm9wVHlwZXMuYXJyYXksXG4gIC8qKiBSZXBsYWNlIHN0cmluZ3MgYWZ0ZXIgZWRpdGluZy4gKi9cbiAgb3V0cHV0RmlsdGVyczogUHJvcFR5cGVzLmFycmF5LFxuICAvKiogQ1NTIGZvciB0aGUgY29tcG9uZW50LiAqL1xuICBzdHlsZTogUHJvcFR5cGVzLm9iamVjdCxcbiAgLyoqIERpc3BsYXkgUmF3IE1hcmtkb3duIG9yIEhUTUwuICovXG4gIHByZXZpZXc6IFByb3BUeXBlcy5ib29sLFxufTtcblxuQmxvY2tUcmFuc2xhdGFibGUuZGVmYXVsdFByb3BzID0ge1xuICBvcmlnaW5hbDogJycsXG4gIHRyYW5zbGF0aW9uOiAnJyxcbiAgaW5wdXRGaWx0ZXJzOiBbXSxcbiAgb3V0cHV0RmlsdGVyczogW10sXG4gIHN0eWxlOiB7fSxcbiAgcHJldmlldzogdHJ1ZSxcbn07XG5cbmNvbnN0IHVzZVN0eWxlcyA9IG1ha2VTdHlsZXModGhlbWUgPT4gKHtcbiAgcm9vdDoge1xuICB9LFxuICBvcmlnaW5hbDoge1xuICAgIGJhY2tncm91bmQ6ICcjZWVlNCcsXG4gIH0sXG4gIHRyYW5zbGF0aW9uOiB7XG4gIH0sXG59KSk7XG5cbmV4cG9ydCBkZWZhdWx0IEJsb2NrVHJhbnNsYXRhYmxlO1xuIl19