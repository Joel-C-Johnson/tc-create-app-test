"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _react = _interopRequireWildcard(require("react"));

var _propTypes = _interopRequireDefault(require("prop-types"));

var _styles = require("@material-ui/core/styles");

var _core = require("@material-ui/core");

var _helpers = require("./helpers");

var _ = require(".");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

var useStyles = (0, _styles.makeStyles)(function (theme) {
  return {
    list: {
      paddingTop: 0,
      paddingBottom: 0
    }
  };
});
/**
 * A Listing Component to render an array of Git Tree objects.
 */

function Tree(_ref) {
  var tree = _ref.tree,
      url = _ref.url,
      config = _ref.config,
      selected = _ref.selected,
      blob = _ref.blob,
      onBlob = _ref.onBlob,
      depth = _ref.depth,
      filepath = _ref.filepath,
      comparer = _ref.comparer;
  var classes = useStyles();

  var _useState = (0, _react.useState)(tree || []),
      _useState2 = _slicedToArray(_useState, 2),
      _tree = _useState2[0],
      setTree = _useState2[1];

  var _selectedPath;

  if (blob) {
    _selectedPath = blob.filepath.split('/')[depth - 2];
  }

  var _useState3 = (0, _react.useState)(_selectedPath),
      _useState4 = _slicedToArray(_useState3, 2),
      selectedPath = _useState4[0],
      setSelectedPath = _useState4[1];

  var updateTree = /*#__PURE__*/function () {
    var _ref2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
      var __tree;

      return regeneratorRuntime.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              _context.next = 2;
              return (0, _helpers.fetchTree)({
                url: url,
                config: config,
                comparer: comparer
              });

            case 2:
              __tree = _context.sent;
              setTree(__tree);

            case 4:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));

    return function updateTree() {
      return _ref2.apply(this, arguments);
    };
  }();

  var emptyTree = !_tree || _tree.length === 0;

  if (selected && emptyTree) {
    updateTree();
  }

  var components = [];

  if (_tree) {
    components = _tree.map(function (object, index) {
      var _selected = object.path === selectedPath;

      var component;

      if (object.type === 'tree') {
        component = /*#__PURE__*/_react.default.createElement(_.TreeObject, _extends({}, object, {
          selected: _selected,
          depth: depth,
          onBlob: onBlob,
          filepath: filepath
        }));
      } else if (object.type === 'blob') {
        component = /*#__PURE__*/_react.default.createElement(_.BlobObject, {
          blob: object,
          onBlob: onBlob,
          selected: _selected,
          depth: depth,
          filepath: filepath
        });
      }

      var onSelectedPath = function onSelectedPath() {
        return setSelectedPath(object.path);
      };

      return /*#__PURE__*/_react.default.createElement("div", {
        key: index,
        onClick: onSelectedPath
      }, component);
    });
  }

  return /*#__PURE__*/_react.default.createElement(_core.Collapse, {
    in: selected,
    timeout: "auto",
    unmountOnExit: true
  }, /*#__PURE__*/_react.default.createElement(_core.List, {
    "data-test": "file-tree",
    dense: true,
    className: classes.list
  }, components));
}

Tree.propTypes = {
  /** An array of paths from the Gitea file tree api. */
  tree: _propTypes.default.arrayOf(_propTypes.default.shape({
    path: _propTypes.default.string.isRequired,
    type: _propTypes.default.oneOf(['tree', 'blob']).isRequired
  })),

  /** The Url to fetch the listing if listing is not provided. */
  url: _propTypes.default.string,

  /** If url is relative, pass the server in the config object. */
  config: _propTypes.default.shape({
    server: _propTypes.default.string
  }),

  /** Set if the Listing is currently selected, which will expand the collapsed view. */
  selected: _propTypes.default.bool,

  /** Function to propogate when the Blob is selected. */
  onBlob: _propTypes.default.func,

  /** The depth of the path in the tree sets the inset of the component. */
  depth: _propTypes.default.number,

  /** The nested filepath that will concatenate. */
  filepath: _propTypes.default.string,

  /** Blob data to render, if url not provided. */
  blob: _propTypes.default.shape({
    /** The filepath in the Git Tree Blob Object */
    path: _propTypes.default.string.isRequired,

    /** The url in the Git Tree Blob Object */
    url: _propTypes.default.string,

    /** The content size of the Git Tree Blob Object */
    size: _propTypes.default.number
  })
};
Tree.defaultProps = {
  selected: false,
  depth: 1
};
var _default = Tree;
exports.default = _default;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9jb21wb25lbnRzL3RyZWUtYmxvYi9UcmVlLmpzIl0sIm5hbWVzIjpbInVzZVN0eWxlcyIsInRoZW1lIiwibGlzdCIsInBhZGRpbmdUb3AiLCJwYWRkaW5nQm90dG9tIiwiVHJlZSIsInRyZWUiLCJ1cmwiLCJjb25maWciLCJzZWxlY3RlZCIsImJsb2IiLCJvbkJsb2IiLCJkZXB0aCIsImZpbGVwYXRoIiwiY29tcGFyZXIiLCJjbGFzc2VzIiwiX3RyZWUiLCJzZXRUcmVlIiwiX3NlbGVjdGVkUGF0aCIsInNwbGl0Iiwic2VsZWN0ZWRQYXRoIiwic2V0U2VsZWN0ZWRQYXRoIiwidXBkYXRlVHJlZSIsIl9fdHJlZSIsImVtcHR5VHJlZSIsImxlbmd0aCIsImNvbXBvbmVudHMiLCJtYXAiLCJvYmplY3QiLCJpbmRleCIsIl9zZWxlY3RlZCIsInBhdGgiLCJjb21wb25lbnQiLCJ0eXBlIiwib25TZWxlY3RlZFBhdGgiLCJwcm9wVHlwZXMiLCJQcm9wVHlwZXMiLCJhcnJheU9mIiwic2hhcGUiLCJzdHJpbmciLCJpc1JlcXVpcmVkIiwib25lT2YiLCJzZXJ2ZXIiLCJib29sIiwiZnVuYyIsIm51bWJlciIsInNpemUiLCJkZWZhdWx0UHJvcHMiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFBOztBQUNBOztBQUNBOztBQUNBOztBQUtBOztBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUVBLElBQU1BLFNBQVMsR0FBRyx3QkFBVyxVQUFBQyxLQUFLO0FBQUEsU0FBSztBQUNyQ0MsSUFBQUEsSUFBSSxFQUFFO0FBQ0pDLE1BQUFBLFVBQVUsRUFBRSxDQURSO0FBRUpDLE1BQUFBLGFBQWEsRUFBRTtBQUZYO0FBRCtCLEdBQUw7QUFBQSxDQUFoQixDQUFsQjtBQU9BO0FBQ0E7QUFDQTs7QUFDQSxTQUFTQyxJQUFULE9BVUc7QUFBQSxNQVREQyxJQVNDLFFBVERBLElBU0M7QUFBQSxNQVJEQyxHQVFDLFFBUkRBLEdBUUM7QUFBQSxNQVBE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QUksRUFBRVYsbUJBQVVTO0FBTkksR0FBaEI7QUFyQlMsQ0FBakI7QUErQkF4QyxJQUFJLENBQUMwQyxZQUFMLEdBQW9CO0FBQ2xCdEMsRUFBQUEsUUFBUSxFQUFFLEtBRFE7QUFFbEJHLEVBQUFBLEtBQUssRUFBRTtBQUZXLENBQXBCO2VBS2VQLEkiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUmVhY3QsIHsgdXNlU3RhdGUgfSBmcm9tICdyZWFjdCc7XHJcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XHJcbmltcG9ydCB7IG1ha2VTdHlsZXMgfSBmcm9tICdAbWF0ZXJpYWwtdWkvY29yZS9zdHlsZXMnO1xyXG5pbXBvcnQge1xyXG4gIExpc3QsXHJcbiAgQ29sbGFwc2UsXHJcbn0gZnJvbSAnQG1hdGVyaWFsLXVpL2NvcmUnO1xyXG5cclxuaW1wb3J0IHsgZmV0Y2hUcmVlIH0gZnJvbSAnLi9oZWxwZXJzJztcclxuaW1wb3J0IHsgQmxvYk9iamVjdCwgVHJlZU9iamVjdCB9IGZyb20gJy4nO1xyXG5cclxuY29uc3QgdXNlU3R5bGVzID0gbWFrZVN0eWxlcyh0aGVtZSA9PiAoe1xyXG4gIGxpc3Q6IHtcclxuICAgIHBhZGRpbmdUb3A6IDAsXHJcbiAgICBwYWRkaW5nQm90dG9tOiAwLFxyXG4gIH0sXHJcbn0pKTtcclxuXHJcbi8qKlxyXG4gKiBBIExpc3RpbmcgQ29tcG9uZW50IHRvIHJlbmRlciBhbiBhcnJheSBvZiBHaXQgVHJlZSBvYmplY3RzLlxyXG4gKi9cclxuZnVuY3Rpb24gVHJlZSh7XHJcbiAgdHJlZSxcclxuICB1cmwsXHJcbiAgY29uZmlnLFxyXG4gIHNlbGVjdGVkLFxyXG4gIGJsb2IsXHJcbiAgb25CbG9iLFxyXG4gIGRlcHRoLFxyXG4gIGZpbGVwYXRoLFxyXG4gIGNvbXBhcmVyLFxyXG59KSB7XHJcbiAgY29uc3QgY2xhc3NlcyA9IHVzZVN0eWxlcygpO1xyXG4gIGNvbnN0IFtfdHJlZSwgc2V0VHJlZV0gPSB1c2VTdGF0ZSh0cmVlIHx8IFtdKTtcclxuICBsZXQgX3NlbGVjdGVkUGF0aDtcclxuXHJcbiAgaWYgKGJsb2IpIHtcclxuICAgIF9zZWxlY3RlZFBhdGggPSBibG9iLmZpbGVwYXRoLnNwbGl0KCcvJylbZGVwdGggLSAyXTtcclxuICB9XHJcblxyXG4gIGNvbnN0IFtzZWxlY3RlZFBhdGgsIHNldFNlbGVjdGVkUGF0aF0gPSB1c2VTdGF0ZShfc2VsZWN0ZWRQYXRoKTtcclxuXHJcbiAgY29uc3QgdXBkYXRlVHJlZSA9IGFzeW5jICgpID0+IHtcclxuICAgIGNvbnN0IF9fdHJlZSA9IGF3YWl0IGZldGNoVHJlZSh7IHVybCwgY29uZmlnLCBjb21wYXJlciB9KTtcclxuICAgIHNldFRyZWUoX190cmVlKTtcclxuICB9O1xyXG5cclxuICBjb25zdCBlbXB0eVRyZWUgPSAoIV90cmVlIHx8IF90cmVlLmxlbmd0aCA9PT0gMCk7XHJcblxyXG4gIGlmIChzZWxlY3RlZCAmJiBlbXB0eVRyZWUpIHtcclxuICAgIHVwZGF0ZVRyZWUoKTtcclxuICB9XHJcblxyXG4gIGxldCBjb21wb25lbnRzID0gW107XHJcblxyXG4gIGlmIChfdHJlZSkge1xyXG4gICAgY29tcG9uZW50cyA9IF90cmVlLm1hcCgob2JqZWN0LCBpbmRleCkgPT4ge1xyXG4gICAgICBjb25zdCBfc2VsZWN0ZWQgPSAob2JqZWN0LnBhdGggPT09IHNlbGVjdGVkUGF0aCk7XHJcbiAgICAgIGxldCBjb21wb25lbnQ7XHJcblxyXG4gICAgICBpZiAob2JqZWN0LnR5cGUgPT09ICd0cmVlJykge1xyXG4gICAgICAgIGNvbXBvbmVudCA9IChcclxuICAgICAgICAgIDxUcmVlT2JqZWN0XHJcbiAgICAgICAgICAgIHsuLi5vYmplY3R9XHJcbiAgICAgICAgICAgIHNlbGVjdGVkPXtfc2VsZWN0ZWR9XHJcbiAgICAgICAgICAgIGRlcHRoPXtkZXB0aH1cclxuICAgICAgICAgICAgb25CbG9iPXtvbkJsb2J9XHJcbiAgICAgICAgICAgIGZpbGVwYXRoPXtmaWxlcGF0aH1cclxuICAgICAgICAgIC8+XHJcbiAgICAgICAgKTtcclxuICAgICAgfSBlbHNlIGlmIChvYmplY3QudHlwZSA9PT0gJ2Jsb2InKSB7XHJcbiAgICAgICAgY29tcG9uZW50ID0gKFxyXG4gICAgICAgICAgPEJsb2JPYmplY3RcclxuICAgICAgICAgICAgYmxvYj17b2JqZWN0fVxyXG4gICAgICAgICAgICBvbkJsb2I9e29uQmxvYn1cclxuICAgICAgICAgICAgc2VsZWN0ZWQ9e19zZWxlY3RlZH1cclxuICAgICAgICAgICAgZGVwdGg9e2RlcHRofVxyXG4gICAgICAgICAgICBmaWxlcGF0aD17ZmlsZXBhdGh9XHJcbiAgICAgICAgICAvPlxyXG4gICAgICAgICk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGNvbnN0IG9uU2VsZWN0ZWRQYXRoID0gKCkgPT4gc2V0U2VsZWN0ZWRQYXRoKG9iamVjdC5wYXRoKTtcclxuXHJcbiAgICAgIHJldHVybiAoXHJcbiAgICAgICAgPGRpdlxyXG4gICAgICAgICAga2V5PXtpbmRleH1cclxuICAgICAgICAgIG9uQ2xpY2s9e29uU2VsZWN0ZWRQYXRofVxyXG4gICAgICAgID5cclxuICAgICAgICAgIHtjb21wb25lbnR9XHJcbiAgICAgICAgPC9kaXY+XHJcbiAgICAgICk7XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIHJldHVybiAoXHJcbiAgICA8Q29sbGFwc2UgaW49e3NlbGVjdGVkfSB0aW1lb3V0PVwiYXV0b1wiIHVubW91bnRPbkV4aXQ+XHJcbiAgICAgIDxMaXN0IGRhdGEtdGVzdD1cImZpbGUtdHJlZVwiIGRlbnNlIGNsYXNzTmFtZT17Y2xhc3Nlcy5saXN0fT5cclxuICAgICAgICB7Y29tcG9uZW50c31cclxuICAgICAgPC9MaXN0PlxyXG4gICAgPC9Db2xsYXBzZT5cclxuICApO1xyXG59XHJcblxyXG5UcmVlLnByb3BUeXBlcyA9IHtcclxuICAvKiogQW4gYXJyYXkgb2YgcGF0aHMgZnJvbSB0aGUgR2l0ZWEgZmlsZSB0cmVlIGFwaS4gKi9cclxuICB0cmVlOiBQcm9wVHlwZXMuYXJyYXlPZihQcm9wVHlwZXMuc2hhcGUoe1xyXG4gICAgcGF0aDogUHJvcFR5cGVzLnN0cmluZy5pc1JlcXVpcmVkLFxyXG4gICAgdHlwZTogUHJvcFR5cGVzLm9uZU9mKFsndHJlZScsICdibG9iJ10pLmlzUmVxdWlyZWQsXHJcbiAgfSkpLFxyXG4gIC8qKiBUaGUgVXJsIHRvIGZldGNoIHRoZSBsaXN0aW5nIGlmIGxpc3RpbmcgaXMgbm90IHByb3ZpZGVkLiAqL1xyXG4gIHVybDogUHJvcFR5cGVzLnN0cmluZyxcclxuICAvKiogSWYgdXJsIGlzIHJlbGF0aXZlLCBwYXNzIHRoZSBzZXJ2ZXIgaW4gdGhlIGNvbmZpZyBvYmplY3QuICovXHJcbiAgY29uZmlnOiBQcm9wVHlwZXMuc2hhcGUoe1xyXG4gICAgc2VydmVyOiBQcm9wVHlwZXMuc3RyaW5nLFxyXG4gIH0pLFxyXG4gIC8qKiBTZXQgaWYgdGhlIExpc3RpbmcgaXMgY3VycmVudGx5IHNlbGVjdGVkLCB3aGljaCB3aWxsIGV4cGFuZCB0aGUgY29sbGFwc2VkIHZpZXcuICovXHJcbiAgc2VsZWN0ZWQ6IFByb3BUeXBlcy5ib29sLFxyXG4gIC8qKiBGdW5jdGlvbiB0byBwcm9wb2dhdGUgd2hlbiB0aGUgQmxvYiBpcyBzZWxlY3RlZC4gKi9cclxuICBvbkJsb2I6IFByb3BUeXBlcy5mdW5jLFxyXG4gIC8qKiBUaGUgZGVwdGggb2YgdGhlIHBhdGggaW4gdGhlIHRyZWUgc2V0cyB0aGUgaW5zZXQgb2YgdGhlIGNvbXBvbmVudC4gKi9cclxuICBkZXB0aDogUHJvcFR5cGVzLm51bWJlcixcclxuICAvKiogVGhlIG5lc3RlZCBmaWxlcGF0aCB0aGF0IHdpbGwgY29uY2F0ZW5hdGUuICovXHJcbiAgZmlsZXBhdGg6IFByb3BUeXBlcy5zdHJpbmcsXHJcbiAgLyoqIEJsb2IgZGF0YSB0byByZW5kZXIsIGlmIHVybCBub3QgcHJvdmlkZWQuICovXHJcbiAgYmxvYjogUHJvcFR5cGVzLnNoYXBlKHtcclxuICAgIC8qKiBUaGUgZmlsZXBhdGggaW4gdGhlIEdpdCBUcmVlIEJsb2IgT2JqZWN0ICovXHJcbiAgICBwYXRoOiBQcm9wVHlwZXMuc3RyaW5nLmlzUmVxdWlyZWQsXHJcbiAgICAvKiogVGhlIHVybCBpbiB0aGUgR2l0IFRyZWUgQmxvYiBPYmplY3QgKi9cclxuICAgIHVybDogUHJvcFR5cGVzLnN0cmluZyxcclxuICAgIC8qKiBUaGUgY29udGVudCBzaXplIG9mIHRoZSBHaXQgVHJlZSBCbG9iIE9iamVjdCAqL1xyXG4gICAgc2l6ZTogUHJvcFR5cGVzLm51bWJlcixcclxuICB9KSxcclxufTtcclxuXHJcblRyZWUuZGVmYXVsdFByb3BzID0ge1xyXG4gIHNlbGVjdGVkOiBmYWxzZSxcclxuICBkZXB0aDogMSxcclxufTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IFRyZWU7XHJcbiJdfQ==