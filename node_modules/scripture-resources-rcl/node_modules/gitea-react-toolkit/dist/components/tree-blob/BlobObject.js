"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _path = _interopRequireDefault(require("path"));

var _react = _interopRequireDefault(require("react"));

var _propTypes = _interopRequireDefault(require("prop-types"));

var _styles = require("@material-ui/core/styles");

var _core = require("@material-ui/core");

var _icons = require("@material-ui/icons");

var _helpers = require("./helpers");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var useStyles = (0, _styles.makeStyles)(function (theme) {
  return {
    root: {
      paddingRight: '0.7em'
    },
    pathText: {
      paddingLeft: '0.7em'
    }
  };
});
/**
 * A Blob Component to render a Git Tree blob object.
 */

function BlobObject(_ref) {
  var selected = _ref.selected,
      blob = _ref.blob,
      _ref$blob = _ref.blob,
      path = _ref$blob.path,
      size = _ref$blob.size,
      onBlob = _ref.onBlob,
      depth = _ref.depth,
      filepath = _ref.filepath;
  var classes = useStyles();

  var _filepath = _path.default.join(filepath || '', path);

  var _blob = _objectSpread(_objectSpread({}, blob), {}, {
    filepath: _filepath
  });

  var icon = selected ? /*#__PURE__*/_react.default.createElement(_icons.Note, null) : /*#__PURE__*/_react.default.createElement(_icons.NoteOutlined, null);
  return /*#__PURE__*/_react.default.createElement(_core.ListItem, {
    button: true,
    selected: selected,
    className: classes.root,
    style: {
      paddingLeft: depth + 'em'
    },
    onClick: function onClick() {
      if (onBlob) {
        onBlob(_blob);
      }
    }
  }, /*#__PURE__*/_react.default.createElement(_core.ListItemIcon, {
    style: {
      marginRight: 0
    }
  }, icon), /*#__PURE__*/_react.default.createElement(_core.ListItemText, {
    className: classes.pathText,
    primary: path,
    secondary: (0, _helpers.humanFileSize)(size)
  }));
}

BlobObject.propTypes = {
  /** Blob data to render, if url not provided. */
  blob: _propTypes.default.shape({
    /** The filepath in the Git Tree Blob Object */
    path: _propTypes.default.string.isRequired,

    /** The url in the Git Tree Blob Object */
    url: _propTypes.default.string,

    /** The content size of the Git Tree Blob Object */
    size: _propTypes.default.number
  }),

  /** Set whether or not the File object is currently selected. */
  selected: _propTypes.default.bool,

  /** Function to propogate when the Blob is selected. */
  onBlob: _propTypes.default.func,

  /** The depth of the path in the tree sets the inset of the component. */
  depth: _propTypes.default.number,

  /** The nested filepath that will concatenate. */
  filepath: _propTypes.default.string
};
BlobObject.defaultProps = {
  selected: false,
  depth: 1
};
var _default = BlobObject;
exports.default = _default;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9jb21wb25lbnRzL3RyZWUtYmxvYi9CbG9iT2JqZWN0LmpzIl0sIm5hbWVzIjpbInVzZVN0eWxlcyIsInRoZW1lIiwicm9vdCIsInBhZGRpbmdSaWdodCIsInBhdGhUZXh0IiwicGFkZGluZ0xlZnQiLCJCbG9iT2JqZWN0Iiwic2VsZWN0ZWQiLCJibG9iIiwicGF0aCIsInNpemUiLCJvbkJsb2IiLCJkZXB0aCIsImZpbGVwYXRoIiwiY2xhc3NlcyIsIl9maWxlcGF0aCIsIlBhdGgiLCJqb2luIiwiX2Jsb2IiLCJpY29uIiwibWFyZ2luUmlnaHQiLCJwcm9wVHlwZXMiLCJQcm9wVHlwZXMiLCJzaGFwZSIsInN0cmluZyIsImlzUmVxdWlyZWQiLCJ1cmwiLCJudW1iZXIiLCJib29sIiwiZnVuYyIsImRlZmF1bHRQcm9wcyJdLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUtBOztBQUtBOzs7Ozs7Ozs7O0FBRUEsSUFBTUEsU0FBUyxHQUFHLHdCQUFXLFVBQUFDLEtBQUs7QUFBQSxTQUFLO0FBQ3JDQyxJQUFBQSxJQUFJLEVBQUU7QUFDSkMsTUFBQUEsWUFBWSxFQUFFO0FBRFYsS0FEK0I7QUFJckNDLElBQUFBLFFBQVEsRUFBRTtBQUNSQyxNQUFBQSxXQUFXLEVBQUU7QUFETDtBQUoyQixHQUFMO0FBQUEsQ0FBaEIsQ0FBbEI7QUFTQTtBQUNBO0FBQ0E7O0FBQ0EsU0FBU0MsVUFBVCxPQVVHO0FBQUEsTUFUREMsUUFTQyxRQVREQSxRQVNDO0FBQUEsTUFSREMsSUFRQyxRQVJEQSxJQVFDO0FBQUEsdUJBUERBLElBT0M7QUFBQSxNQU5DQyxJQU1ELGFBTkNBLElBTUQ7QUFBQSxNQUxDQyxJQUtELGFBTENBLElBS0Q7QUFBQSxNQUhEQyxNQUdDLFFBSERBLE1BR0M7QUFBQSxNQUZEQyxLQUVDLFFBRkRBLEtBRUM7QUFBQSxNQUREQyxRQUNDLFFBRERBLFFBQ0M7QUFDRCxNQUFNQyxPQUFPLEdBQUdkLFNBQVMsRUFBekI7O0FBQ0EsTUFBTWUsU0FBUyxHQUFHQyxjQUFLQyxJQUFMLENBQVVKLFFBQVEsSUFBSSxFQUF0QixFQUEwQkosSUFBMUIsQ0FBbEI7O0FBQ0EsTUFBTVMsS0FBSyxtQ0FBUVYsSUFBUjtBQUFjSyxJQUFBQSxRQUFRLEVBQUVFO0FBQXhCLElBQVg7O0FBRUEsTUFBTUksSUFBSSxHQUFHWixRQUFRLGdCQUNuQiw2QkFBQyxXQUFELE9BRG1CLGdCQUVuQiw2QkFBQyxtQkFBRCxPQUZGO0FBSUEsc0JBQ0UsNkJBQUMsY0FBRDtBQUNFLElBQUEsTUFBTSxNQURSO0FBRUUsSUFBQSxRQUFRLEVBQUVBLFFBRlo7QUFHRSxJQUFBLFNBQVMsRUFBRU8sT0FBTyxDQUFDWixJQUhyQjtBQUlFLElBQUEsS0FBSyxFQUFFO0FBQUVHLE1BQUFBLFdBQVcsRUFBRU8sS0FBSyxHQUFHO0FBQXZCLEtBSlQ7QUFLRSxJQUFBLE9BQU8sRUFBRSxtQkFBTTtBQUNiLFVBQUlELE1BQUosRUFBWTtBQUFFQSxRQUFBQSxNQUFNLENBQUNPLEtBQUQsQ0FBTjtBQUFnQjtBQUMvQjtBQVBILGtCQVNFLDZCQUFDLGtCQUFEO0FBQWMsSUFBQSxLQUFLLEVBQUU7QUFBRUUsTUFBQUEsV0FBVyxFQUFFO0FBQWY7QUFBckIsS0FDR0QsSUFESCxDQVRGLGVBWUUsNkJBQUMsa0JBQUQ7QUFDRSxJQUFBLFNBQVMsRUFBRUwsT0FBTyxDQUFDVixRQURyQjtBQUVFLElBQUEsT0FBTyxFQUFFSyxJQUZYO0FBR0UsSUFBQSxTQUFTLEVBQUUsNEJBQWNDLElBQWQ7QUFIYixJQVpGLENBREY7QUFvQkQ7O0FBRURKLFVBQVUsQ0FBQ2UsU0FBWCxHQUF1QjtBQUNyQjtBQUNBYixFQUFBQSxJQUFJLEVBQUVjLG1CQUFVQyxLQUFWLENBQWdCO0FBQ3BCO0FBQ0FkLElBQUFBLElBQUksRUFBRWEsbUJBQVVFLE1BQVYsQ0FBaUJDLFVBRkg7O0FBR3BCO0FBQ0FDLElBQUFBLEdBQUcsRUFBRUosbUJBQVVFLE1BSks7O0FBS3BCO0FBQ0FkLElBQUFBLElBQUksRUFBRVksbUJBQVVLO0FBTkksR0FBaEIsQ0FGZTs7QUFVckI7QUFDQXBCLEVBQUFBLFFBQVEsRUFBRWUsbUJBQVVNLElBWEM7O0FBWXJCO0FBQ0FqQixFQUFBQSxNQUFNLEVBQUVXLG1CQUFVTyxJQWJHOztBQWNyQjtBQUNBakIsRUFBQUEsS0FBSyxFQUFFVSxtQkFBVUssTUFmSTs7QUFnQnJCO0FBQ0FkLEVBQUFBLFFBQVEsRUFBRVMsbUJBQVVFO0FBakJDLENBQXZCO0FBb0JBbEIsVUFBVSxDQUFDd0IsWUFBWCxHQUEwQjtBQUN4QnZCLEVBQUFBLFFBQVEsRUFBRSxLQURjO0FBRXhCSyxFQUFBQSxLQUFLLEVBQUU7QUFGaUIsQ0FBMUI7ZUFLZU4sVSIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBQYXRoIGZyb20gJ3BhdGgnO1xyXG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xyXG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xyXG5pbXBvcnQgeyBtYWtlU3R5bGVzIH0gZnJvbSAnQG1hdGVyaWFsLXVpL2NvcmUvc3R5bGVzJztcclxuaW1wb3J0IHtcclxuICBMaXN0SXRlbSxcclxuICBMaXN0SXRlbUljb24sXHJcbiAgTGlzdEl0ZW1UZXh0LFxyXG59IGZyb20gJ0BtYXRlcmlhbC11aS9jb3JlJztcclxuaW1wb3J0IHtcclxuICBOb3RlLFxyXG4gIE5vdGVPdXRsaW5lZCxcclxufSBmcm9tICdAbWF0ZXJpYWwtdWkvaWNvbnMnO1xyXG5cclxuaW1wb3J0IHsgaHVtYW5GaWxlU2l6ZSB9IGZyb20gJy4vaGVscGVycyc7XHJcblxyXG5jb25zdCB1c2VTdHlsZXMgPSBtYWtlU3R5bGVzKHRoZW1lID0+ICh7XHJcbiAgcm9vdDoge1xyXG4gICAgcGFkZGluZ1JpZ2h0OiAnMC43ZW0nLFxyXG4gIH0sXHJcbiAgcGF0aFRleHQ6IHtcclxuICAgIHBhZGRpbmdMZWZ0OiAnMC43ZW0nLFxyXG4gIH1cclxufSkpO1xyXG5cclxuLyoqXHJcbiAqIEEgQmxvYiBDb21wb25lbnQgdG8gcmVuZGVyIGEgR2l0IFRyZWUgYmxvYiBvYmplY3QuXHJcbiAqL1xyXG5mdW5jdGlvbiBCbG9iT2JqZWN0KHtcclxuICBzZWxlY3RlZCxcclxuICBibG9iLFxyXG4gIGJsb2I6IHtcclxuICAgIHBhdGgsXHJcbiAgICBzaXplLFxyXG4gIH0sXHJcbiAgb25CbG9iLFxyXG4gIGRlcHRoLFxyXG4gIGZpbGVwYXRoLFxyXG59KSB7XHJcbiAgY29uc3QgY2xhc3NlcyA9IHVzZVN0eWxlcygpO1xyXG4gIGNvbnN0IF9maWxlcGF0aCA9IFBhdGguam9pbihmaWxlcGF0aCB8fCAnJywgcGF0aCk7XHJcbiAgY29uc3QgX2Jsb2IgPSB7IC4uLmJsb2IsIGZpbGVwYXRoOiBfZmlsZXBhdGggfTtcclxuXHJcbiAgY29uc3QgaWNvbiA9IHNlbGVjdGVkID9cclxuICAgIDxOb3RlIC8+IDpcclxuICAgIDxOb3RlT3V0bGluZWQgLz47XHJcblxyXG4gIHJldHVybiAoXHJcbiAgICA8TGlzdEl0ZW1cclxuICAgICAgYnV0dG9uXHJcbiAgICAgIHNlbGVjdGVkPXtzZWxlY3RlZH1cclxuICAgICAgY2xhc3NOYW1lPXtjbGFzc2VzLnJvb3R9XHJcbiAgICAgIHN0eWxlPXt7IHBhZGRpbmdMZWZ0OiBkZXB0aCArICdlbScgfX1cclxuICAgICAgb25DbGljaz17KCkgPT4ge1xyXG4gICAgICAgIGlmIChvbkJsb2IpIHsgb25CbG9iKF9ibG9iKTsgfVxyXG4gICAgICB9fVxyXG4gICAgPlxyXG4gICAgICA8TGlzdEl0ZW1JY29uIHN0eWxlPXt7IG1hcmdpblJpZ2h0OiAwIH19PlxyXG4gICAgICAgIHtpY29ufVxyXG4gICAgICA8L0xpc3RJdGVtSWNvbj5cclxuICAgICAgPExpc3RJdGVtVGV4dFxyXG4gICAgICAgIGNsYXNzTmFtZT17Y2xhc3Nlcy5wYXRoVGV4dH1cclxuICAgICAgICBwcmltYXJ5PXtwYXRofVxyXG4gICAgICAgIHNlY29uZGFyeT17aHVtYW5GaWxlU2l6ZShzaXplKX1cclxuICAgICAgLz5cclxuICAgIDwvTGlzdEl0ZW0+XHJcbiAgKTtcclxufVxyXG5cclxuQmxvYk9iamVjdC5wcm9wVHlwZXMgPSB7XHJcbiAgLyoqIEJsb2IgZGF0YSB0byByZW5kZXIsIGlmIHVybCBub3QgcHJvdmlkZWQuICovXHJcbiAgYmxvYjogUHJvcFR5cGVzLnNoYXBlKHtcclxuICAgIC8qKiBUaGUgZmlsZXBhdGggaW4gdGhlIEdpdCBUcmVlIEJsb2IgT2JqZWN0ICovXHJcbiAgICBwYXRoOiBQcm9wVHlwZXMuc3RyaW5nLmlzUmVxdWlyZWQsXHJcbiAgICAvKiogVGhlIHVybCBpbiB0aGUgR2l0IFRyZWUgQmxvYiBPYmplY3QgKi9cclxuICAgIHVybDogUHJvcFR5cGVzLnN0cmluZyxcclxuICAgIC8qKiBUaGUgY29udGVudCBzaXplIG9mIHRoZSBHaXQgVHJlZSBCbG9iIE9iamVjdCAqL1xyXG4gICAgc2l6ZTogUHJvcFR5cGVzLm51bWJlcixcclxuICB9KSxcclxuICAvKiogU2V0IHdoZXRoZXIgb3Igbm90IHRoZSBGaWxlIG9iamVjdCBpcyBjdXJyZW50bHkgc2VsZWN0ZWQuICovXHJcbiAgc2VsZWN0ZWQ6IFByb3BUeXBlcy5ib29sLFxyXG4gIC8qKiBGdW5jdGlvbiB0byBwcm9wb2dhdGUgd2hlbiB0aGUgQmxvYiBpcyBzZWxlY3RlZC4gKi9cclxuICBvbkJsb2I6IFByb3BUeXBlcy5mdW5jLFxyXG4gIC8qKiBUaGUgZGVwdGggb2YgdGhlIHBhdGggaW4gdGhlIHRyZWUgc2V0cyB0aGUgaW5zZXQgb2YgdGhlIGNvbXBvbmVudC4gKi9cclxuICBkZXB0aDogUHJvcFR5cGVzLm51bWJlcixcclxuICAvKiogVGhlIG5lc3RlZCBmaWxlcGF0aCB0aGF0IHdpbGwgY29uY2F0ZW5hdGUuICovXHJcbiAgZmlsZXBhdGg6IFByb3BUeXBlcy5zdHJpbmcsXHJcbn07XHJcblxyXG5CbG9iT2JqZWN0LmRlZmF1bHRQcm9wcyA9IHtcclxuICBzZWxlY3RlZDogZmFsc2UsXHJcbiAgZGVwdGg6IDEsXHJcbn07XHJcblxyXG5leHBvcnQgZGVmYXVsdCBCbG9iT2JqZWN0O1xyXG4iXX0=